# Java内存模型

## JMM定义

**内存模型：在特定的操作协议下，对特定的内存或高速缓存进⾏读写访问的过程抽象**。

不同的硬件之间的内存模型有些许差异，Java内存模型(JMM)屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到⼀致的内存访问效果。

## 并发编程的通信和同步

在并发编程中，**线程间通信有两种模型：共享内存和消息传递**。

### 共享内存

- 共享内存是指线程间共享，通过读写内存中的公共状态来实现隐式通信。
- 共享内存的同步是显式执⾏的，必须显⽰的指定某个⽅法或者某段代码在程序之间互斥执⾏。

### 消息传递

- 消息传递线程间没有共享状态，线程间必须通过发送/接受消息来进⾏显式通信。
- 消息传递的同步是隐式执⾏的，消息的发送⼀定在消息的接受之前。

**Java采⽤的是共享内存模型：隐式通信、显式同步**。

- 共享内存存在缓存一致性问题。

## 缓存一致性(寄存器-高速缓存-内存)

**存储器层次结构：寄存器 > Cache > 内存**。

高速缓存带来了一个新问题，缓存一致性：

- 如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要协议来解决，保证缓存一致性。

### 主内存与线程工作内存

所有变量都存储在主内存中，线程共享。

线程有自己的工作内存，工作内存在高速缓存或者寄存器中，保存了该线程使用的变量主内存副本拷贝。

线程只能直接操作工作内存中的变量，线程之间的变量值传递需要通过主内存来完成（共享内存），所以存在缓存一致性问题。

![image-20250910205254399](assets/image-20250910205254399.png)

- 主内存对应于Java堆内存中的数据部分（对象等）。

- 局部变量表和⽅法参数等线程私有，不会被共享，分配在线程虚拟机栈上。

## 内存间交互操作（8个原子操作）

![image-20250910205306312](assets/image-20250910205306312.png)

- read：把一个变量的值从主内存传输到工作内存中
- load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
- use：把工作内存中一个变量的值传递给执行引擎
- assign：把一个从执行引擎接收到的值赋给工作内存的变量
- store：把工作内存的一个变量的值传送到主内存中
- write：在 store 之后执行，把 store 得到的值放入主内存的变量中
- lock：加锁，作用于主内存的变量
- unlock：解锁，作用于主内存的变量

相关规则

- unlock 必须在lock 之后
- read、load两两成对
- store、write两两成对

## volatile 内存语义实现（限制部分重排序）

### load和store

和volatile相关的记住两个重要操作：load和store。

### 限制部分重排序

变量被volatile标注会限制⼀部分重排序，防止结果被改变。

| 是否能重排序   | 第二个操作 |             |             |
| -------------- | ---------- | ----------- | ----------- |
| **第一个操作** | 普通读/写  | volatile 读 | volatile 写 |
| 普通读/写      |            |             | NO          |
| volatile 读    | NO         | NO          | NO          |
| volatile 写    |            | NO          | NO          |

1. 第一个操作是volatile 读，不允许重排序，确保volatile 读之后的操作不会被编译器重排序到 volatile 读之前。
2. 第二个操作是volatile 写，不允许重排序，确保volatile 写之前的操作不会被编译器重排序到 volatile 写之后。
3. 第一个操作是volatile 写，第二个操作是volatile 读/写，不允许重排序。

### 内存屏障（Memory Barrier）

为了实现volatile限制重排序的功能，编译器在⽣成字节码时会插⼊内存屏障来禁止特定类型的处理器重排序。
因为每个处理器重排序规则都不⼀样，JMM采取了保守策略插⼊内存屏障，保证JMM在不同处理器上的重排序限制都相同。

- 在每个 volatile 写操作的前⾯插⼊⼀个 StoreStore 屏障
- 在每个 volatile 写操作的后⾯插⼊⼀个 StoreLoad 屏障

## final内存语义

对于 final 域，编译器和处理器要遵守排序规则。

1. 这两个操作之间不能重排序（先写入final值再引用）
   1. **构造函数内对 `final` 域的写入**
   1. **随后将被构造对象的引用赋值给一个引用变量**


2. 这两个操作之间不能重排序（先读引用再读final值）
   1. **初次读一个包含 `final` 域的对象的引用**
   1. **随后初次读这个 `final` 域**

3. 这两个操作之间不能重排序
   1. **在构造函数内对一个 `final` 引用的对象的成员域的写入**
   2. **随后在构造函数外将被构造对象的引用赋值给一个引用变量**

`final` 语义还保证了内存的可见性：

- **`final` 域的写入：** 在构造函数中对一个 `final` 域的写入，**会确保该写入操作对其它线程可见**（即会将值从当前线程的工作内存刷新到主内存）。
- **`final` 域的读取：** 读一个 `final` 域，**会确保从主内存中读取最新的值**（即会使当前线程的工作内存中该 `final` 域的缓存失效）。

### 总结与表格

| 场景                      | 规则描述                                                     | 保证效果                                                     |
| :------------------------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **`final` 基本类型/引用** | 禁止将构造函数内的 `final` 域写入重排序到对象发布之后。      | 只要对象正确发布，任何线程看到的 `final` 域都是构造完成的值。 |
| **读取顺序**              | 禁止初次读对象引用与初次读该对象的 `final` 域这两个操作重排序。 | 保证了读取 `final` 域时，对象引用一定是有效的。              |
| **`final` 引用类型内部**  | 禁止将构造函数内对 `final` 引用所指对象的修改重排序到对象发布之后。 | 防止了“内部 `this` 逃逸”，保证了 `final` 引用所指对象的内部状态在发布时已初始化完毕。 |

**重要前提：**

这些强大的保证都有一个**共同的前提：对象必须被正确地构造和发布，不能发生“`this` 逃逸”**。

正确使用 `final` 并结合安全的对象发布实践（如避免 `this` 逃逸），是编写无需同步就能实现线程安全的不可变对象的关键。

## 内存模型三大特性

### 1.原子性

原子性：不可被中断的一个或一系列操作

read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，单个操作具备原子性 。

Java通过**锁和循环CAS**的方式实现原子操作

- 显式锁-`Lock`、隐式锁-`synchronized`
  - 对应的内存间交互操作为：lock 和 unlock
  - 在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit

- CAS(乐观锁)-JUC的原子类

### 2.可见性

可见性：当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。

主要有三种实现可见性的方式：

1. `volatile`，不能保证原子性，两条实现原则：
   1. `Lock`前缀指令会引起处理器**缓存回写到内存**。
   2. 一个处理器的缓存回写到内存操作会导致其它处理器的**缓存失效** 。
2. `synchronized`，对一个变量执行 unlock  操作之前，必须把变量值同步回主内存。
3. `final` ，只要对象引用本身是正确发布的（没有发生 `this` 逃逸），任何线程都能看到 `final` 字段被构造函数正确初始化后的值。

### 3. 有序性

有序性：**在多线程环境下**，虽然一个线程内部的指令可能被重排序，但通过 Java 内存模型提供的一系列规则，保证所有线程的操作都是按某种“正确的”顺序执行的。从而保证程序执行结果的正确性。

JMM 的有序性**并不禁止重排序**，而是**通过规则约束重排序的发生条件**，使得即使发生了重排序，从程序执行结果上看，也**像是**没有重排序一样。

JMM 解决有序性问题的核心工具就是 **`Happens-Before` 规则**。例如

- `volatile`通过添加内存屏障来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。
- `synchronized`保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。

# 重排序

现代计算机系统和编译器为了极致的性能，会对指令进行各种优化，这些优化会改变指令的执行顺序。

**1. 编译器的重排序**
编译器在不改变单线程程序语义的前提下，可能会重新排列语句的顺序，以利用CPU指令流水线，提高执行效率。

**2. 处理器(指令)的重排序**
现代CPU普遍采用**指令级并行（ILP）** 技术。为了避免空闲等待（比如等待从内存中加载数据），CPU可能会将多条指令乱序执行（Out-of-Order Execution）。

**3. 内存系统的重排序**
由于CPU有多级缓存（L1, L2, L3），一个处理器对内存的写操作可能不会立即对其他处理器可见，导致其他处理器看到的操作顺序与实际执行顺序不一致。

![image-20250915212628683](assets/image-20250915212628683.png)

## 数据依赖性

如果两个操作**访问同⼀个变量**，且这两个操作中**有⼀个为写操作**，此时这两个操作之间就**存在数据依赖性**。

数据依赖分为三种情况：写后读、写后写、读后写

**只要前后任意操作涉及到写，就存在数据依赖性，只要重排序两个操作的执⾏顺序，程序的执⾏结果就会被改变。**

编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执⾏顺序。

- 数据依赖性只是单个处理器和单个线程中的操作
- 不同处理器和不同线程之间的数据依赖不被编译器和处理器考虑（需要同步）

## **as-if-serial 语义**

**语义：不管怎么重排序，单线程程序的执⾏结果不能被改变。**

各种重排序必须遵守as-if-serial 语义。⽐如：数据依赖性，不会重排存在数据依赖性的操作，因为这样会改变结果。

as-if-serial很好理解，单线程如果都不能保证，那整个程序就乱套啦。

它使单线程程序员⽆需担⼼重排序会⼲扰程序，也⽆需担⼼内存可见性问题。

但as-if-serial 隐含的意思时，只要重排序不影响最后的结果，那么你怎样重排都是可以的。

单线程不会有影响，但多线程就会出现可见性问题，需要正确的同步。