# 并发底层实现原理

## volatile （可见性，免锁）

`volatile` 是轻量级的`synchronized`，它在多处理器开发中保证了共享变量的“可见性”。

- Java内存模型保证所有线程看到的变量值是一致的，当`volatile`变量被修改，修改对于所有读取变量的线程可见。

`volatile` 关键字为实例字段的同步访问提供了一种免锁机制。

`volatile` 不会引起上下文的切换。

`volatile` 不能提供原子性 。

```java
volatile count；
count ++ // ++操作不能保证原子性
```

### CPU术语

- 内存屏障
- **缓存行：缓存的最小操作单位**
- 原子操作
- **缓存行填充**
- 缓存命中
- 写命中
- 写缺失

### volatile 原理

`volatile`变量转变成汇编语言，会多出`Lock`前缀的汇编代码，`Lock`前缀指令在多处理器下会引发两件事：

1. 将当前处理器**缓存行**的数据写回到系统内存。
2. 这个写回内存操作会使在其它CPU里缓存了该内存地址的数据失效。

如果对`volatile`变量进行写操作，JVM会向处理器发送一条`Lock`前缀的指令，将这个变量在缓存行的数据写回到系统内存。同时，根据缓存一致性协议 ，当处理器发现自己缓存行对应的**内存地址**被修改，就将当前处理器的缓存行设置为无效状态 ，当处理器对这个数据进行修改操作的时候，重新从系统内存把数据读取到处理器缓存里（**缓存行填充**）。

#### volatile的两条实现原则：

1. `Lock`前缀指令会引起处理器**缓存回写到内存**。
2. 一个处理器的缓存回写到内存操作会导致其他处理器的**缓存失效** 。

## synchronized（**原⼦性、可见性、有序性**）

Java中的锁分为显式锁和隐式锁

- 隐式锁由`synchronized`关键字实现
- 显式锁是由实现了`Lock`接口和`AQS`框架等类来实现

`synchronized`关键字通过**对象头、锁升级机制和字节码指令**实现线程同步，解决了对共享变量操作的原⼦性、保证了其他线程对共享变量的可见性、有序性，确保了并发情况下的线程安全。 

### 同步实现方式

**同步代码块**：通过`monitorenter`和`monitorexit`字节码指令实现。

- 每个对象都有一个`monitor`与之关联，当一个`monitor`被持有后，它将处于锁定状态 
- 线程会尝试获取对象对应的`monitor`的所有权，即尝试获取对象的锁 
- 线程执行到`monitorenter`时尝试获取对象锁，`monitorexit`释放锁。
- 编译后，`monitorenter`指令插入到开始位置，`monitorexit` 插入到结束处和异常处

**同步方法**：通过方法访问标志`ACC_SYNCHRONIZED`标识，JVM隐式调用锁机制。

## Java中的每个对象都可以作为锁，有三种加锁⽅式

1. 对于普通同步⽅法，锁是当前实例对象。
2. 对于静态同步⽅法，锁是当前类的 `Class` 对象。
3. 对于同步⽅法块，锁是 `synchonized` 括号⾥配置的对象。