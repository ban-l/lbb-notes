# 知识点

## Java线程和操作系统线程区别

**现代Java线程（HotSpot JVM）就是操作系统线程的直接映射**。

### 核心结论（现代JVM）

在目前主流的HotSpot JVM（Oracle/Sun JDK、OpenJDK）上，**一个Java线程通常直接对应一个操作系统内核线程（Kernel-Level Thread）**。

这意味着Java线程的创建、调度、执行都在操作系统内核的支持下完成。

这种“一对一”的模型意味着：
*   **创建和销毁成本较高**：需要从用户态切换到内核态。
*   **调度由OS负责**：OS内核的调度器决定哪个线程获得CPU时间片。
*   **能够利用多核CPU**：内核线程可以在多个CPU核心上真正地并行运行。

---

### 详细区别与关系

尽管Java线程依赖于OS线程，但它们并不完全等同，JVM在OS线程之上提供了一个抽象层。

| 特性           | Java线程 (java.lang.Thread)                                  | 操作系统线程 (OS Thread)                                     |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **抽象层级**   | **高级抽象**，是JVM层面的概念。程序员通过Thread类及其API来操作。 | **底层实现**，是操作系统内核管理的执行实体。                 |
| **可移植性**   | **强**。“编写一次，到处运行”。代码在不同OS上的行为一致。     | **弱**。直接使用OS线程的API（如pthreads）编写的代码不可移植。 |
| **创建与管理** | 通过`new Thread().start()`创建，由**JVM统一管理**（但底层依赖OS）。 | 通过OS特定的API（如Linux的`pthread_create`）创建，由**OS内核管理**。 |
| **开销**       | **相对较大**（因为1:1映射）。创建数万个线程不现实，会耗尽系统资源。 | **很大**。每个线程都需要独立的内核数据结构（如PCB）和栈空间。 |
| **调度机制**   | **JVM参与协作**，但最终**由OS线程调度器抢占式调度**。JVM的线程优先级只是建议，OS可以忽略。 | **完全由OS内核的调度器进行抢占式调度**。                     |
| **状态模型**   | 定义了6种状态（NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED）。 | 不同OS有自己的状态定义（如就绪、运行、阻塞等），但概念相似。 |
| **栈内存**     | 可以通过JVM参数（如`-Xss`）设置**Java线程的栈大小**。        | OS也为每个内核线程分配栈空间（通常更大，默认1MB左右）。Java线程栈是OS线程栈的一部分。 |

---

### 历史的视角：绿色线程（Green Threads）

在Java的早期版本（JDK 1.1之前），一些JVM实现了 **“绿色线程”（Green Threads）** 或称为用户态线程。

*   **什么是绿色线程？** 由JVM自己模拟实现的线程，完全在用户空间管理，**多个Java线程对应一个OS内核线程**（多对一模型）。
*   **优点**：
    *   **创建和切换速度快**：不需要陷入内核态，开销小。
    *   **调度可控**：JVM可以自己实现调度算法。
*   **缺点**：
    *   **不能利用多核CPU**：所有绿色线程都在一个OS内核线程上运行，无法实现真正的并行。
    *   **容易阻塞**：一个绿色线程进行阻塞式I/O调用（如读网络），会导致整个底层OS线程阻塞，从而阻塞了所有映射到该OS线程的绿色线程。

由于多核CPU成为主流，为了充分利用多核计算能力，Java从**JDK 1.2**开始，主流JVM（HotSpot）转向使用基于OS内核线程的1:1模型。绿色线程模型逐渐被废弃。

---

### 未来的趋势：虚拟线程（Virtual Threads - JDK 19+）

为了解决OS线程（平台线程）高开销的问题，无法轻松创建大量线程（如百万级别）以应对高并发I/O密集型场景，Java在**JDK 19**引入了**虚拟线程（Virtual Threads）** 作为预览特性，并在**JDK 21**中正式发布。

*   **它是什么？** 这是一种 **“M:N”模型**（多对多模型）。**大量（M个）的虚拟线程被调度到少量（N个）平台线程（即OS线程）上执行**。
*   **谁负责调度？** **JVM**，而不是操作系统。JVM的调度器负责将可运行的虚拟线程挂载到平台线程（称为载体线程 - Carrier Thread）上执行。
*   **核心优势**：
    *   **开销极低**：可以轻松创建数百万个虚拟线程。
    *   **简化并发编程**：可以用简单的“一个请求一个线程”的同步代码风格，获得异步非阻塞代码的高性能。
    *   **并非更快**：它的目标是提高吞吐量（Throughput），而不是降低延迟（Latency）。

**虚拟线程和操作系统线程的关系**：虚拟线程运行在平台线程（OS线程）之上，由JVM管理其生命周期和调度，但在执行时仍然需要借用OS线程的CPU执行能力。

### 总结

1.  **现代Java（HotSpot JVM）**：Java线程（`Thread`）是**操作系统内核线程的1:1包装**。创建、调度、销毁都依赖于操作系统，开销大，但能实现真正并行。
2.  **历史Java**：曾使用**绿色线程（用户线程）**，多对一模型，无法利用多核，已被淘汰。
3.  **未来Java（JDK 21+）**：推荐使用**虚拟线程**来处理大规模并发任务。它运行在平台线程之上，由JVM调度，开销极小，是编写高吞吐量并发应用程序的新范式。而平台线程（OS线程）则被保留用于执行计算密集型任务。

在当前环境中，通常认为Java线程就是OS线程；而在即将成为主流的JDK 21及以后，开发者会更关注虚拟线程与底层平台线程（OS线程）的协同工作。

## synchronized锁升级

1. 无锁
2. 偏向锁（单线程，不同步）
3. 轻量级锁（不阻塞，多线程竞争不激烈）
4. 重量级锁（阻塞，多线程竞争激烈）

## synchronized 和 volatile 的区别是什么？

原理

- volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读；
- synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

范围

- volatile 仅能使用在变量级别；
- synchronized 则可以使用在 变量、方法、和类级别；

特性

- volatile 仅能实现变量的修改可见性，不能保证原子性；

- synchronized 则可以 保证变量的修改可见性和原子性；

阻塞

- volatile 不会造成线程的阻塞；
- synchronized 可能会造成线程的阻塞。

优化

- volatile 标记的变量不会被编译器优化；
- synchronized 标记的变量可以被编译器优化。

## synchronized指令

对应内存间交互操作为：lock 和 unlock

对应在虚拟机实现上对应的字节码指令为：monitorenter 和 monitorexit

## 锁的分类

从宏观上看，锁的分类有多种不同划分。

可以分为乐观锁和悲观锁，可以分为共享锁和排他锁，还可以分为可重⼊锁和不可重⼊等等。

### 乐观锁（非同步阻塞）

乐观锁对数据冲突保持乐观点态度，认为不会有其他线程同时修改数据。

因此乐观锁不会上锁，只是在更新数据时 判断是否有其他线程更新。

- 如果没有其他线程修改，则更新数据。
- 如果有其他线程修改，则放弃数据，重新读取数据处理（CAS）。

### 悲观锁（同步阻塞）

悲观锁对数据冲突保持悲观态度，认为总是发⽣数据冲突。

因此它以⼀种预防的态度，先⾏把数据锁住，知道操作完成才释放锁，在此期间其他线程⽆法操作数据。