# 知识点

## synchronized锁升级

无锁 -> 偏向锁（单线程，不同步）-> 轻量级锁（不阻塞，多线程竞争不激烈）->重量级锁（阻塞，多线程竞争激烈）

## synchronized 和 volatile 的区别是什么？

原理

- volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读；
- synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

范围

- volatile 仅能使用在变量级别；
- synchronized 则可以使用在 变量、方法、和类级别；

特性

- volatile 仅能实现变量的修改可见性，不能保证原子性；

- synchronized 则可以 保证变量的修改可见性和原子性；

阻塞

- volatile 不会造成线程的阻塞；
- synchronized 可能会造成线程的阻塞。

优化

- volatile 标记的变量不会被编译器优化；
- synchronized 标记的变量可以被编译器优化。



## synchronized

对应内存间交互操作为：lock 和 unlock

对应在虚拟机实现上对应的字节码指令为：monitorenter 和 monitorexit



## 锁的分类

从宏观上看，锁的分类有多种不同划分。

可以分为乐观锁和悲观锁，可以分为共享锁和排他锁，还可以分为可重⼊锁和不可重⼊等等。

### 乐观锁（非同步阻塞）

乐观锁对数据冲突保持乐观点态度，认为不会有其他线程同时修改数据。

因此乐观锁不会上锁，只是在更新数据时 判断是否有其他线程更新。

- 如果没有其他线程修改，则更新数据。
- 如果有其他线程修改，则放弃数据，重新读取数据处理（CAS）。

### 悲观锁（同步阻塞）

悲观锁对数据冲突保持悲观态度，认为总是发⽣数据冲突。

因此它以⼀种预防的态度，先⾏把数据锁住，知道操作完成才释放锁，在此期间其他线程⽆法操作数据。