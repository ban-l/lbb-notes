# 轻量级锁

- 轻量级锁是相对于使⽤操作系统互斥量来实现的传统锁（重量级锁）⽽⾔的。
- 轻量级锁并不是⽤来代替重量级锁的。
- 目标是在无实际竞争或短时间竞争(多线程交替执行)场景下，避免使用操作系统互斥量（重量级锁），减少用户态与内核态的切换开销。  
- 适合多个线程竞争不激烈场景。

## 加锁（CAS+自旋）

1. 线程执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间（`Lock Record`）。锁记录空间（`Lock Record`）包含两部分：
   1. `Displaced Mark Word`：⽤于存储锁对象⽬前的`Mark Word`的拷贝。
   2. `owner`：指向当前锁对象的指针。

![image-20250807212912358](assets/image-20250807212912358.png)

2. 然后线程尝试使用CAS将对象头中的`Mark Word` 替换为指向`Lock Record`的指针。
   1. 如果成功，当前线程获得锁，对象锁标志位变为00。
   2. 如果失败，表示存在其它线程竞争锁，当前线程尝试使用自旋获取锁 (自旋超过次数，变为重量级锁)。





![image-20250807212926491](assets/image-20250807212926491.png)

## 解锁（CAS）

使用原子CAS操作将`Lock Record`中的`Displaced Mark Word`替换为对象头。

- 如果成功，表示没有竞争。
- 如果失败，表示当前锁存在竞争，锁会膨胀为重量锁 。

![image-20250813220126686](assets/image-20250813220126686.png)

### 轻量级锁⾃旋

- 当轻量级出现竞争以后，会尝试进⾏⾃旋。
- ⾃旋就是CPU空转，消耗CPU，线程没有挂起依然在执⾏，等过⼀段时间后再去加锁。
- 因为如果升级为重量级锁，是通过操作系统来实现，涉及到内核态和⽤户态之间的切换，操作比较耗时。
- 如果竞争没有那么激烈，同步代码块执⾏的时间还没有切换上下⽂花的时间多，反⽽得不偿失。

因此采⽤⾃旋锁，出现竞争后等⼀等再去尝试，可能前⾯获得锁的线程已经执⾏完了，再次加锁，避免升级重量锁带来的消耗。

### 优点

- 适合多个线程不同时访问同步对象场景（竞争不激烈）
  - 多个线程访问，出现竞争，偏向锁撤销比较耗费资源，直接变成轻量级锁

- 轻量锁则很⽅便，直接CAS替换就可以，对多线程竞争不激烈的场景很适⽤。

- 锁的⾃旋也是为此设计。

### 缺点

-  竞争激烈的场景下不适⽤，此时进⾏⾃旋就是再浪费CPU资源。
- 竞争激烈时可能多次⾃旋都不会获得锁，这种浪费的代价⽐上下⽂切换的代价要⼤，所以引⼊⾃适应⾃旋来裁决。
