# 散列表（数据结构）

散列表(Hash table，哈希表)，是根据关键码值(Key)直接访问(value)的数据结构。

- 通过把关键码值(Key)**映射**到表中一个**位置**来访问记录，以加快查找的速度。
- 映射函数叫做**散列函数**，存放记录的数组叫做**散列表**。
- 散列函数 - 除留余数法
  - 散列表长为`m`的散列函数公式为：`f(key) = key mod p(p ≤ m)`
  - 通常`p`为小于或等于表长(最好接近`m`)的最小质数

## 散列冲突 

**不同的关键字可能得到同一散列地址**，即`k1≠k2`，而`f(k1)==f(k2)`，这种现象称为冲突。

### 解决散列冲突办法

#### 1.开放定址法(再散列法)

在遇到哈希冲突时，去寻找一个新的空闲哈希地址。

- 线性探测法：存放值的位置被占了，往后一直加1并对m取模，直到存在一个空余的地址存放值(不冲突)
- 平方探测法（二次探测）：存放值的位置被占了，会前后寻找，而不是单独方向的寻找。

注意：`hash`表长度 `>=` 存放元素数量，而且因为存在再次`hash`，所以只能在删除的节点上做标记，而不能真正删除节点。

#### 2.再哈希法(双重散列，多重散列)

- 提供多个不同的`hash`函数，当`R1=H1(key1)`发生冲突时，再计算`R2=H2(key1)`，直到没有冲突为止。 
- 这样做虽然不易产生堆集，但增加了计算时间。

#### 3.链地址法(拉链法，HashMap采用)

- 将所有**哈希地址相同**的记录都链接在同一链表中(同义词链表)。

- 并将单链表的**头指针**存放在哈希表的第`i`个单元中，查找、插入和删除主要在同义词链表中进行。
- 链表法适用于经常进行插入和删除的情况。

#### 4.建立公共溢出区

- 将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

## Java散列表

**Java中，散列表使用链表数组实现（解决冲突），每一个链表被称为桶。**

- 标准库类桶数为2的幂，默认16（`HashMap`、`HashSet`等）。
- 提供的任意值都将自动转换为2的下一个幂值。

查找表中对象位置：先计算散列码，然后与桶的总数取余，得到索引。

装填因子：填入表中的元素个数/散列表的长度，默认为0.75。