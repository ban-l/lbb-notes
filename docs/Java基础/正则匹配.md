# 正则匹配

## 元字符

`\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+.)+[A-Za-z]{2,14}`

- \d  匹配一个数字字符。等价于 [0-9]。
- \D  匹配一个非数字字符。等价于 [^0-9]。
- \w  匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'
- \W  匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'
- \s  匹配任何空白字符，包括空格、制表符、换页符
- \S  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]
- .   匹配除换行符（\n、\r）之外的任何单个字符。
- \f  匹配一个换页符。
- \n  匹配一个换行符。
- \  匹配一个回车符。
- \t  匹配一个制表符。
- \v  匹配一个垂直制表符。
- ^  匹配输入字符串开始的位置。
- $  匹配输入字符串结尾的位置
- \b  匹配一个单词边界，也就是指单词和空格间的位置。
	- 例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
- \B  与 \b 相反：er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

**样例**

- 匹配ing结尾单词
	- ing\b
- 匹配11位数的中国手机号
	- 1\d\d\d\d\d\d\d\d\d\d

## 区间
- [ ]
- [0-9]  匹配 0-9 之间的数字
- [A-Z]  匹配 A-Z 之间的字母，也可以组合 [A-Za-z0-9]
- [-\w.+] 区间
	- 表示 匹配符号 -
	- **或字母、数字、下划线**
	- 或符号 .
	- 或符号 +

## 限定符
- `*`匹配前面的子表达式零次或多次。 * 等价于{0,}
- `+`匹配前面的子表达式一次或多次。 + 等价于 {1,}
- ?  匹配前面的子表达式零次或一次。 ? 等价于 {0,1}
- {n}  n 是一个非负整数。匹配确定的 n 次。
- {n,}  n 是一个非负整数。至少匹配n 次。
- {n,m}  m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。

**样例**

- 匹配9位数的QQ邮箱
	- `[0-9]{9}@qq.com`
- 身份证号：
	- `\d{17}[0-9Xx] | \d{15}`
- ip地址：
	- `\d{0,3}\.\d{0,3}\.\d{0,3}\.\d{0,3}`

## 普通字符 和 转义
```
\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+[A-Za-z]{2,14}
```

- @ 是普通字符，标识必定会出现的内容
- 但符号
- /
- .
- (
- )
- 等等在正则是特殊字符，所以需要用转义符 \ 转义

## 子表达式

用**圆括号**组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式。
```
var reg=/(\d)([a-z]*)/gi
```

- (\d)就是第一个子表达式
- `([a-z])` 是第二个子表达式


## 贪婪
当正则表达式中包含能接受重复的限定符时

通常的行为是（在使整个表达式能得到匹配的前提下）**匹配尽可能多**的字符

这匹配方式叫做贪婪匹配

```
var str = '1adkk adkkk adkkkk';
var reg = /([a-z]){4,6}/gi;
var result = str.match(reg);
console.log(result);

输出结果：  
0: "adkk"
1: "adkkk"
2: "adkkkk"
```


## 懒惰 / 非贪婪
当正则表达式中包含能接受重复的限定符时

通常的行为是（在使整个表达式能得到匹配的前提下）**匹配尽可能少**的字符

这匹配方式叫做懒惰匹配

- 懒惰量词是在贪婪量词后面加个 `?`
- *?  重复多次，但尽可能少重复
- +? 重复1次、多次，但尽可能少重复
- ?? 重复0次、1次，但尽可能少重复
- {n,m}? 重复n~m次，但尽可能少重复
- {n,}? 重复n次以上，但尽可能少重复
```
var str = '1adkk adkkk adkkkk';
var reg = /(\w{3,4}?)/gi;
var result = str.match(reg);
console.log(result);

输出结果：
0: "1ad"
1: "adk"
2: "adk"
3: "kkk"
```