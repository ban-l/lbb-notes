# Java IO

## 一 IO 整体架构概览

JDK 8中的IO系统主要分为以下几个层次：

```
Java应用程序
    ↓
IO流类 (java.io)
    ↓
NIO类 (java.nio) 
    ↓
底层系统调用
    ↓
操作系统/文件系统
```

## 二 传统IO - 基于流的IO

### 2.1 核心概念：流(Stream)
- 流是数据的序列，可以是字节序列或字符序列
- 输入流：从数据源读取数据
  - **磁盘、网络 -> 内存**

- 输出流：向目标写入数据
  - **内存 -> 磁盘、网络**


### 2.2 字节流 vs 字符流

| 类型   | 基类                             | 用途                                    | 示例                                     |
| ------ | -------------------------------- | --------------------------------------- | ---------------------------------------- |
| 字节流 | `InputStream`<br/>`OutputStream` | 处理二进制数据<br/>图片、视频、任何文件 | `FileInputStream`<br/>`FileOutputStream` |
| 字符流 | `Reader`<br/>`Writer`            | 处理文本数据<br/>考虑字符编码           | `FileReader`<br/>`FileWriter`            |

### 2.3 装饰器模式在IO中的应用
Java IO大量使用装饰器模式，为核心流添加功能：

```java
// 基础流
FileInputStream fileIn = new FileInputStream("test.txt");

// 添加缓冲功能（装饰器）
BufferedInputStream bufferedIn = new BufferedInputStream(fileIn);

// 添加对象序列化功能（另一个装饰器）
ObjectInputStream objectIn = new ObjectInputStream(bufferedIn);
```

### 2.4 常用字节流类

```java
public class ByteStreamExample {
    public static void main(String[] args) {
        // 1. 文件复制 - 基础字节流
        try (FileInputStream fis = new FileInputStream("source.jpg");
             FileOutputStream fos = new FileOutputStream("copy.jpg")) {
            
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, bytesRead);
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 2. 缓冲流 - 提高性能
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("largefile.dat"));
             BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.dat"))) {
            
            int data;
            while ((data = bis.read()) != -1) {
                bos.write(data);
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 3. 数据流 - 处理基本数据类型
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.bin"))) {
            dos.writeInt(123);
            dos.writeDouble(3.14);
            dos.writeUTF("Hello");
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 读取数据
        try (DataInputStream dis = new DataInputStream(new FileInputStream("data.bin"))) {
            int i = dis.readInt();
            double d = dis.readDouble();
            String s = dis.readUTF();
            System.out.println(i + ", " + d + ", " + s);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 2.5 常用字符流类

```java
public class CharacterStreamExample {
    public static void main(String[] args) {
        // 1. 文件读写 - 指定字符编码
        try (FileReader reader = new FileReader("input.txt", StandardCharsets.UTF_8);
             FileWriter writer = new FileWriter("output.txt", StandardCharsets.UTF_8)) {
            
            char[] buffer = new char[1024];
            int charsRead;
            while ((charsRead = reader.read(buffer)) != -1) {
                writer.write(buffer, 0, charsRead);
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 2. 缓冲字符流 + 行读取
        try (BufferedReader br = new BufferedReader(new FileReader("text.txt"));
             BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"))) {
            
            String line;
            while ((line = br.readLine()) != null) {
                bw.write(line);
                bw.newLine(); // 跨平台换行符
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        // 3. 打印流 - 方便的格式化输出
        try (PrintWriter pw = new PrintWriter(new FileWriter("log.txt"))) {
            pw.println("Info: Application started");
            pw.printf("Time: %tT%n", new Date());
            pw.printf("PI = %.2f%n", Math.PI);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 三 NIO (New IO) - java.nio包

### 3.1 NIO 核心概念

| 概念     | 传统IO         | NIO                |
| -------- | -------------- | ------------------ |
| 数据流   | 面向流(Stream) | 面向缓冲区(Buffer) |
| 阻塞性   | 阻塞IO         | 非阻塞IO           |
| 工作方式 | 单向流动       | 通道双向传输       |

### 3.2 三大核心组件

a. 缓冲区(Buffer)
```java
public class BufferExample {
    public static void main(String[] args) {
        // 创建ByteBuffer，容量为1024字节
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        
        System.out.println("初始状态:");
        printBufferState(buffer); // position=0, limit=1024, capacity=1024
        
        // 写入数据
        String data = "Hello NIO";
        buffer.put(data.getBytes());
        
        System.out.println("写入数据后:");
        printBufferState(buffer); // position=9, limit=1024, capacity=1024
        
        // 切换为读模式
        buffer.flip();
        
        System.out.println("flip()之后:");
        printBufferState(buffer); // position=0, limit=9, capacity=1024
        
        // 读取数据
        byte[] readData = new byte[buffer.limit()];
        buffer.get(readData);
        System.out.println("读取的数据: " + new String(readData));
        
        // 清空缓冲区，准备再次写入
        buffer.clear();
        System.out.println("clear()之后:");
        printBufferState(buffer); // position=0, limit=1024, capacity=1024
    }
    
    private static void printBufferState(ByteBuffer buffer) {
        System.out.printf("Position: %d, Limit: %d, Capacity: %d%n",
            buffer.position(), buffer.limit(), buffer.capacity());
    }
}
```

b. 通道(Channel)
```java
public class ChannelExample {
    // 使用FileChannel复制文件
    public static void fileCopyWithChannel(String source, String target) throws IOException {
        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(target);
             FileChannel inChannel = fis.getChannel();
             FileChannel outChannel = fos.getChannel()) {
            
            // 方法1: transferTo - 高效的文件传输
            inChannel.transferTo(0, inChannel.size(), outChannel);
            
            // 方法2: 手动缓冲区复制
            // ByteBuffer buffer = ByteBuffer.allocate(4096);
            // while (inChannel.read(buffer) != -1) {
            //     buffer.flip();
            //     outChannel.write(buffer);
            //     buffer.clear();
            // }
        }
    }
    
    // 内存映射文件 - 处理大文件
    public static void memoryMappedFileExample() throws IOException {
        try (RandomAccessFile file = new RandomAccessFile("largefile.dat", "rw");
             FileChannel channel = file.getChannel()) {
            
            // 将文件映射到内存
            MappedByteBuffer mappedBuffer = channel.map(
                FileChannel.MapMode.READ_WRITE, 0, channel.size());
            
            // 直接操作内存，不需要系统调用
            while (mappedBuffer.hasRemaining()) {
                byte b = mappedBuffer.get();
                // 处理数据...
            }
        }
    }
}
```

c. 选择器(Selector) - 非阻塞IO的核心
```java
public class NonBlockingServer {
    private static final int PORT = 8080;
    
    public static void startServer() throws IOException {
        // 创建Selector
        Selector selector = Selector.open();
        
        // 创建ServerSocketChannel并配置为非阻塞
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false);
        serverChannel.bind(new InetSocketAddress(PORT));
        
        // 注册到Selector，监听ACCEPT事件
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        System.out.println("服务器启动在端口: " + PORT);
        
        while (true) {
            // 阻塞，直到有事件发生
            int readyChannels = selector.select();
            if (readyChannels == 0) continue;
            
            // 获取就绪的通道
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
            
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                
                if (key.isAcceptable()) {
                    // 接受新连接
                    acceptConnection(key, selector);
                } else if (key.isReadable()) {
                    // 读取数据
                    readData(key);
                } else if (key.isWritable()) {
                    // 写入数据
                    writeData(key);
                }
                
                keyIterator.remove();
            }
        }
    }
    
    private static void acceptConnection(SelectionKey key, Selector selector) throws IOException {
        ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();
        SocketChannel clientChannel = serverChannel.accept();
        clientChannel.configureBlocking(false);
        
        // 注册读事件
        clientChannel.register(selector, SelectionKey.OP_READ);
        System.out.println("接受连接: " + clientChannel.getRemoteAddress());
    }
    
    private static void readData(SelectionKey key) throws IOException {
        SocketChannel channel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        
        int bytesRead = channel.read(buffer);
        if (bytesRead == -1) {
            channel.close();
            return;
        }
        
        buffer.flip();
        byte[] data = new byte[buffer.remaining()];
        buffer.get(data);
        String message = new String(data);
        System.out.println("收到消息: " + message);
        
        // 注册写事件，准备回复
        channel.register(key.selector(), SelectionKey.OP_WRITE, message);
    }
    
    private static void writeData(SelectionKey key) throws IOException {
        SocketChannel channel = (SocketChannel) key.channel();
        String message = (String) key.attachment();
        
        String response = "Echo: " + message;
        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());
        channel.write(buffer);
        
        // 切换回读模式
        channel.register(key.selector(), SelectionKey.OP_READ);
    }
}
```

## 四 NIO.2 (JDK 7+ 引入) - java.nio.file包

### 4.1 Path 接口 - 替代File类
```java
public class NIO2Examples {
    public static void pathOperations() {
        // 创建Path对象
        Path path = Paths.get("/home/user/documents", "file.txt");
        Path absolutePath = path.toAbsolutePath();
        
        System.out.println("文件名: " + path.getFileName());
        System.out.println("父目录: " + path.getParent());
        System.out.println("根目录: " + path.getRoot());
        System.out.println("绝对路径: " + absolutePath);
        
        // 路径解析
        Path resolved = path.resolveSibling("newfile.txt");
        System.out.println("兄弟文件: " + resolved);
    }
    
    public static void filesOperations() throws IOException {
        Path source = Paths.get("source.txt");
        Path target = Paths.get("target.txt");
        
        // 文件操作
        if (!Files.exists(source)) {
            Files.createFile(source);
        }
        
        // 复制文件
        Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
        
        // 读取文件属性
        System.out.println("文件大小: " + Files.size(source) + " bytes");
        System.out.println("最后修改: " + Files.getLastModifiedTime(source));
        System.out.println("是否为目录: " + Files.isDirectory(source));
        
        // 读取所有行
        List<String> lines = Files.readAllLines(source, StandardCharsets.UTF_8);
        
        // 写入文件
        Files.write(target, Arrays.asList("Line1", "Line2"), 
                   StandardCharsets.UTF_8, StandardOpenOption.APPEND);
    }
    
    // 遍历目录树
    public static void walkFileTreeExample() throws IOException {
        Path startDir = Paths.get(".");
        
        Files.walkFileTree(startDir, new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                if (file.toString().endsWith(".java")) {
                    System.out.println("Java文件: " + file);
                }
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                System.out.println("进入目录: " + dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }
}
```

## 五 JDK 8 新增特性

### 5.1 Files类的增强
```java
public class JDK8IOEnhancements {
    public static void filesStreamOperations() throws IOException {
        Path dir = Paths.get("src/main/java");
        
        // 使用Stream API处理文件
        try (Stream<Path> paths = Files.list(dir)) {
            paths.filter(Files::isRegularFile)
                 .filter(p -> p.toString().endsWith(".java"))
                 .map(Path::getFileName)
                 .forEach(System.out::println);
        }
        
        // 深度遍历
        try (Stream<Path> paths = Files.walk(dir)) {
            long javaFileCount = paths.filter(p -> p.toString().endsWith(".java"))
                                     .count();
            System.out.println("Java文件数量: " + javaFileCount);
        }
        
        // 查找文件
        try (Stream<Path> paths = Files.find(dir, 3, 
                (path, attrs) -> attrs.isRegularFile() && 
                               path.toString().endsWith(".class"))) {
            paths.forEach(System.out::println);
        }
        
        // 读取文件行流
        Path logFile = Paths.get("application.log");
        try (Stream<String> lines = Files.lines(logFile, StandardCharsets.UTF_8)) {
            long errorCount = lines.filter(line -> line.contains("ERROR"))
                                  .count();
            System.out.println("错误日志数量: " + errorCount);
        }
    }
}
```

## 六 性能比较与选择建议

| 场景         | 推荐方案                   | 理由                 |
| ------------ | -------------------------- | -------------------- |
| 小文件读写   | 传统IO + 缓冲流            | 简单易用，代码清晰   |
| 大文件处理   | NIO FileChannel + 内存映射 | 性能高，减少系统调用 |
| 网络应用     | NIO Selector               | 支持高并发，非阻塞   |
| 复杂文件操作 | NIO.2 Files/Path           | API丰富，功能强大    |
| 遍历目录     | Files.walk() + Stream API  | 函数式编程，简洁高效 |

## 七 总结

JDK 8中的IO体系提供了完整的多层次解决方案：

1. 传统IO (java.io)：简单场景，易于理解
2. NIO (java.nio)：高性能，非阻塞，适合网络应用
3. NIO.2 (java.nio.file)：现代文件操作，替代File类
4. Stream API集成：JDK 8的函数式风格，处理更优雅

最佳实践建议：
- 总是使用try-with-resources确保资源关闭
- 根据数据量选择缓冲区大小（通常4KB-8KB）
- 文本文件务必指定字符编码
- 大文件考虑使用内存映射(MappedByteBuffer)
- 高并发网络服务使用NIO Selector模式