# Java IO

JDK 8 提供了**三套主要的I/O系统**：传统的 `java.io`（BIO）、`java.nio`（NIO/NIO2）、`java.nio.file`（NIO.2文件系统API）。

```text
Java应用程序
    ↓
IO流类 (java.io)
    ↓
NIO类 (java.nio) 
    ↓
底层系统调用
    ↓
操作系统/文件系统
```

## 一、传统 I/O (`java.io`) - 阻塞式 I/O

### 1. **核心设计：基于流（Stream）**

   - **字节流**：处理二进制数据
   - **字符流**：处理文本数据，带有字符编码支持
   - 输入流：从数据源读取数据
     - **磁盘、网络 -> 内存**
- 输出流：向目标写入数据
  - **内存 -> 磁盘、网络**

| 类型   | 基类                             | 用途                                    | 示例                                     |
| ------ | -------------------------------- | --------------------------------------- | ---------------------------------------- |
| 字节流 | `InputStream`<br/>`OutputStream` | 处理二进制数据<br/>图片、视频、任何文件 | `FileInputStream`<br/>`FileOutputStream` |
| 字符流 | `Reader`<br/>`Writer`            | 处理文本数据<br/>考虑字符编码           | `FileReader`<br/>`FileWriter`            |

### 2. **核心类层次结构**

```
字节流：
InputStream (抽象类)
├── FileInputStream (文件输入)
├── ByteArrayInputStream (字节数组输入)
├── BufferedInputStream (带缓冲)
├── ObjectInputStream (对象序列化)
└── ...

OutputStream (抽象类)
├── FileOutputStream (文件输出)
├── ByteArrayOutputStream (字节数组输出)
├── BufferedOutputStream (带缓冲)
├── ObjectOutputStream (对象序列化)
└── ...

字符流：
Reader (抽象类)
├── InputStreamReader (字节到字符的桥接)
│   └── FileReader (文件读取)
├── BufferedReader (带缓冲)
├── CharArrayReader (字符数组)
└── ...

Writer (抽象类)
├── OutputStreamWriter (字符到字节的桥接)
│   └── FileWriter (文件写入)
├── BufferedWriter (带缓冲)
├── CharArrayWriter (字符数组)
└── ...
```

### 3. **装饰器模式的应用**

```java
// 典型的装饰器模式使用
BufferedReader reader = new BufferedReader(
    new InputStreamReader(
        new FileInputStream("file.txt"), "UTF-8"
    )
);

// 等价于直接使用 FileReader（简化版）
BufferedReader reader = new BufferedReader(
    new FileReader("file.txt")
);
```

### 4. **关键特性**

- **阻塞式操作**：线程在读/写时会等待，直到操作完成
- **同步执行**：调用线程必须等待I/O操作完成
- **流式处理**：数据像水流一样，按顺序处理

### 5. **常见使用模式**

```java
// 1. 基本的文件复制
try (FileInputStream fis = new FileInputStream("source.txt");
     FileOutputStream fos = new FileOutputStream("target.txt")) {
    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = fis.read(buffer)) != -1) {
        fos.write(buffer, 0, bytesRead);
    }
}

// 2. 使用缓冲提高性能
try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"));
     BufferedWriter writer = new BufferedWriter(new FileWriter("output.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        writer.write(line);
        writer.newLine();
    }
}

// 3. 对象序列化
try (ObjectOutputStream oos = new ObjectOutputStream(
        new FileOutputStream("data.ser"))) {
    oos.writeObject(myObject);
}
```

## 二、NIO (`java.nio`) - 新I/O

### 1. **核心设计理念**

- **面向缓冲区（Buffer-oriented）**
- **非阻塞模式（Non-blocking）**
- **选择器（Selector）实现多路复用**

| 概念     | 传统IO         | NIO                |
| -------- | -------------- | ------------------ |
| 数据流   | 面向流(Stream) | 面向缓冲区(Buffer) |
| 阻塞性   | 阻塞IO         | 非阻塞IO           |
| 工作方式 | 单向流动       | 通道双向传输       |

### 2. **核心组件深度解析**

#### **2.1 缓冲区（Buffer）**

```java
// Buffer 的状态转换
ByteBuffer buffer = ByteBuffer.allocate(1024); // 创建，position=0, limit=capacity

// 写模式
buffer.put("Hello".getBytes()); // position移动

// 切换到读模式
buffer.flip(); // limit=position, position=0

// 读数据
while (buffer.hasRemaining()) {
    System.out.print((char) buffer.get());
}

// 准备再次写入
buffer.clear(); // position=0, limit=capacity
// 或 buffer.compact(); // 保留未读数据
```

#### **2.2 通道（Channel）**

```java
// 文件通道示例
try (FileChannel channel = FileChannel.open(
        Paths.get("file.txt"), 
        StandardOpenOption.READ, 
        StandardOpenOption.WRITE)) {
    
    // 1. 文件锁
    FileLock lock = channel.lock(); // 排他锁
    // FileLock sharedLock = channel.lock(0, Long.MAX_VALUE, true); // 共享锁
    
    // 2. 直接内存映射（零拷贝）
    MappedByteBuffer mappedBuffer = channel.map(
        FileChannel.MapMode.READ_WRITE, 0, channel.size());
    
    // 3. 文件传输（高效）
    try (FileChannel destChannel = FileChannel.open(
            Paths.get("dest.txt"), StandardOpenOption.CREATE, 
            StandardOpenOption.WRITE)) {
        channel.transferTo(0, channel.size(), destChannel);
        // 或 destChannel.transferFrom(channel, 0, channel.size());
    }
}
```

#### **2.3 选择器（Selector）**

```java
// 完整的NIO服务器示例
public class NioServer {
    private static final int PORT = 8080;
    
    public void start() throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false);
        serverChannel.bind(new InetSocketAddress(PORT));
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        System.out.println("服务器启动在端口 " + PORT);
        
        while (true) {
            int readyChannels = selector.select();
            if (readyChannels == 0) continue;
            
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> keyIterator = selectedKeys.iterator();
            
            while (keyIterator.hasNext()) {
                SelectionKey key = keyIterator.next();
                
                if (key.isAcceptable()) {
                    handleAccept(key, selector);
                } else if (key.isReadable()) {
                    handleRead(key);
                } else if (key.isWritable()) {
                    handleWrite(key);
                }
                
                keyIterator.remove();
            }
        }
    }
}
```

## 三、NIO.2 (`java.nio.file`) - 文件系统API

JDK 7引入，JDK 8中完善的现代文件系统API。

### 1. **核心类**

#### **1.1 Path - 路径的现代化表示**

```java
Path path = Paths.get("/home/user", "documents", "file.txt");
// 或 Path path = Paths.get("/home/user/documents/file.txt");

// 常用操作
Path parent = path.getParent();      // 父目录
Path fileName = path.getFileName();  // 文件名
Path root = path.getRoot();          // 根目录

// 路径解析和组合
Path resolved = path.resolve("subdir/another.txt");
Path sibling = path.resolveSibling("other.txt");
Path relative = path.relativize(Paths.get("/home/user"));

// 路径标准化
Path normalized = Paths.get("/home/./user/../documents/file.txt").normalize();
```

#### **1.2 Files - 强大的文件操作工具类**

```java
// 1. 文件读写（简化版）
// 读取所有行
List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);
// 读取所有字节
byte[] bytes = Files.readAllBytes(path);
// 写入
Files.write(path, lines, StandardCharsets.UTF_8);
Files.write(path, bytes, StandardOpenOption.CREATE, StandardOpenOption.WRITE);

// 2. 使用Stream API（JDK 8新特性）
try (Stream<Path> stream = Files.list(Paths.get("/tmp"))) {
    stream.filter(Files::isRegularFile)
          .map(Path::getFileName)
          .forEach(System.out::println);
}

try (Stream<String> linesStream = Files.lines(path, StandardCharsets.UTF_8)) {
    long count = linesStream.filter(line -> line.contains("error"))
                           .count();
}

// 3. 文件操作
Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);
Files.delete(path);
Files.deleteIfExists(path);

// 4. 文件属性
boolean exists = Files.exists(path);
boolean isDirectory = Files.isDirectory(path);
boolean isReadable = Files.isReadable(path);
boolean isWritable = Files.isWritable(path);
boolean isExecutable = Files.isExecutable(path);

// 5. 获取文件信息
FileStore store = Files.getFileStore(path);
long totalSpace = store.getTotalSpace();
long usableSpace = store.getUsableSpace();

// 6. 文件元数据
BasicFileAttributes attrs = Files.readAttributes(
    path, BasicFileAttributes.class);
System.out.println("创建时间: " + attrs.creationTime());
System.out.println("大小: " + attrs.size());
System.out.println("是否目录: " + attrs.isDirectory());

// 特定文件系统的属性
PosixFileAttributes posixAttrs = Files.readAttributes(
    path, PosixFileAttributes.class);
System.out.println("权限: " + posixAttrs.permissions());
System.out.println("所有者: " + posixAttrs.owner());

// 7. 设置属性
Files.setAttribute(path, "dos:hidden", true);
Files.setPosixFilePermissions(path, 
    PosixFilePermissions.fromString("rw-r-----"));
```

#### **1.3 WatchService - 文件系统监视**

```java
public class DirectoryWatcher {
    public void watchDirectory(Path dir) throws IOException {
        WatchService watchService = FileSystems.getDefault().newWatchService();
        
        // 注册感兴趣的事件
        dir.register(watchService, 
            StandardWatchEventKinds.ENTRY_CREATE,
            StandardWatchEventKinds.ENTRY_MODIFY,
            StandardWatchEventKinds.ENTRY_DELETE);
        
        System.out.println("开始监视: " + dir);
        
        while (true) {
            WatchKey key;
            try {
                key = watchService.take(); // 阻塞等待事件
            } catch (InterruptedException e) {
                return;
            }
            
            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();
                
                if (kind == StandardWatchEventKinds.OVERFLOW) {
                    continue;
                }
                
                @SuppressWarnings("unchecked")
                WatchEvent<Path> ev = (WatchEvent<Path>) event;
                Path fileName = ev.context();
                Path child = dir.resolve(fileName);
                
                System.out.printf("事件: %s, 文件: %s%n", kind.name(), fileName);
                
                // 根据事件类型处理
                if (kind == StandardWatchEventKinds.ENTRY_CREATE) {
                    System.out.println("新文件创建: " + child);
                } else if (kind == StandardWatchEventKinds.ENTRY_MODIFY) {
                    System.out.println("文件修改: " + child);
                } else if (kind == StandardWatchEventKinds.ENTRY_DELETE) {
                    System.out.println("文件删除: " + child);
                }
            }
            
            boolean valid = key.reset();
            if (!valid) {
                break;
            }
        }
    }
}
```

## 四、异步 I/O (AsynchronousFileChannel)

### 1. **基于 Future 的异步操作**

```java
public class AsyncFileOperations {
    public void readFileWithFuture() throws IOException, ExecutionException, 
            InterruptedException {
        AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
            Paths.get("largefile.bin"), StandardOpenOption.READ);
        
        ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024); // 1MB
        
        // 开始异步读取（立即返回）
        Future<Integer> operation = fileChannel.read(buffer, 0);
        
        // 可以在这里做其他事情...
        System.out.println("读取操作进行中，继续其他工作...");
        
        // 当需要结果时，等待完成
        int bytesRead = operation.get(); // 阻塞直到完成
        
        System.out.println("读取完成，读取了 " + bytesRead + " 字节");
        
        buffer.flip();
        // 处理数据...
        
        fileChannel.close();
    }
}
```

### 2. **基于 CompletionHandler 的异步操作**

```java
public class AsyncFileOperations {
    public void readFileWithCallback() throws IOException {
        AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(
            Paths.get("largefile.bin"), StandardOpenOption.READ);
        
        ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);
        
        fileChannel.read(buffer, 0, buffer, new CompletionHandler<Integer, ByteBuffer>() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                System.out.println("读取完成，读取了 " + result + " 字节");
                attachment.flip();
                
                // 处理数据...
                byte[] data = new byte[attachment.limit()];
                attachment.get(data);
                System.out.println("数据: " + new String(data));
                
                try {
                    fileChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            
            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                System.err.println("读取失败: " + exc.getMessage());
                exc.printStackTrace();
                
                try {
                    fileChannel.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
        
        System.out.println("读取操作已启动，主线程继续执行...");
    }
}
```

## 五、JDK 8 的新特性增强

### 1. **Stream API 集成**

```java
// 1. 文件行流
try (Stream<String> lines = Files.lines(Paths.get("data.txt"))) {
    List<String> filtered = lines
        .filter(line -> !line.startsWith("#"))
        .map(String::toUpperCase)
        .collect(Collectors.toList());
}

// 2. 目录遍历
try (Stream<Path> walk = Files.walk(Paths.get("/project"), 5)) {
    walk.filter(Files::isRegularFile)
        .filter(p -> p.toString().endsWith(".java"))
        .forEach(System.out::println);
}

// 3. 深度优先查找
try (Stream<Path> find = Files.find(
        Paths.get("/project"), 
        10, 
        (path, attrs) -> attrs.isRegularFile() && 
                        attrs.size() > 1024 * 1024)) {
    find.forEach(p -> System.out.println("大文件: " + p));
}
```

### 2. **Base64 编解码支持**

```java
// 文件到Base64
String base64 = Files.readAllBytes(Paths.get("image.jpg"))
    .map(Base64.getEncoder()::encodeToString)
    .collect(Collectors.joining());

// Base64到文件
byte[] data = Base64.getDecoder().decode(base64String);
Files.write(Paths.get("output.jpg"), data);
```

## 六、I/O 最佳实践

### 1. **资源管理**

```java
// 1. 使用 try-with-resources（JDK 7+）
try (BufferedReader reader = Files.newBufferedReader(path);
     BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
    // 自动关闭资源
}

// 2. 对于需要手动管理的资源
AsynchronousFileChannel channel = null;
try {
    channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
    // 使用channel...
} finally {
    if (channel != null && channel.isOpen()) {
        channel.close();
    }
}
```

### 2. **性能考虑**

```java
// 1. 选择合适的缓冲区大小
int optimalBufferSize = 8192; // 通常8KB是个好起点

// 2. 使用直接缓冲区（Direct Buffer）进行大量I/O
ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024 * 1024);

// 3. 批量操作优于单次操作
List<String> allLines = Files.readAllLines(path); // 批量读取
Files.write(path, data); // 批量写入
```

### 3. **异常处理**

```java
try {
    Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
} catch (FileAlreadyExistsException e) {
    System.err.println("文件已存在: " + e.getFile());
} catch (AccessDeniedException e) {
    System.err.println("权限不足: " + e.getFile());
} catch (IOException e) {
    System.err.println("I/O错误: " + e.getMessage());
    e.printStackTrace();
}
```

## 七、选择指南

| 场景              | 推荐使用                           | 原因                 |
| ----------------- | ---------------------------------- | -------------------- |
| 简单文本/文件读写 | `java.io` + 缓冲流                 | 简单直观，代码量少   |
| 大量小文件操作    | NIO.2 Files/Path                   | 简洁API，性能好      |
| 大文件处理        | `FileChannel` + `MappedByteBuffer` | 内存映射，零拷贝     |
| 高并发网络服务器  | NIO Selector                       | 非阻塞，多路复用     |
| 复杂文件操作      | NIO.2 Files/Path                   | API丰富，功能强大    |
| 遍历目录          | Files.walk() + Stream API          | 函数式编程，简洁高效 |
| 异步文件操作      | `AsynchronousFileChannel`          | 不阻塞调用线程       |
| 文件系统监控      | `WatchService`                     | 事件驱动，实时响应   |
| 与Stream API集成  | `Files.lines()`, `Files.walk()`    | 函数式编程，代码简洁 |

## 总结

JDK 8 中的 I/O 系统提供了**三个层次**的选择：

1. 传统IO (java.io)：简单场景，易于理解
2. NIO (java.nio)：高性能，非阻塞，适合网络应用
3. NIO.2 (java.nio.file)：现代文件操作，替代File类
4. Stream API集成：JDK 8的函数式风格，处理更优雅

## 重要建议

- 新项目应优先考虑 NIO.2 (`java.nio.file`)
- 高并发网络服务使用NIO Selector模式
- 网络编程考虑使用成熟的框架（如 Netty），而不是直接使用裸 NIO
- 充分利用 JDK 8 的 Stream API 与 Files 类的集成
- 始终使用 `try-with-resources` 确保资源正确关闭
- 根据数据量选择缓冲区大小（通常4KB-8KB）
- 文本文件务必指定字符编码
- 大文件考虑使用内存映射(MappedByteBuffer)

