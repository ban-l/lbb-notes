# 零拷贝

在JDK 8中，零拷贝（Zero-copy）主要通过NIO（New I/O）的`FileChannel.transferTo()`和`transferFrom()`方法实现，以及`MappedByteBuffer`的内存映射机制。

## 1. **传统I/O的文件传输问题**

在传统I/O中，文件传输需要多次数据拷贝和上下文切换：

```java
// 传统方式 - 需要4次拷贝和4次上下文切换
try (FileInputStream fis = new FileInputStream("source.txt");
     FileOutputStream fos = new FileOutputStream("dest.txt")) {
    
    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = fis.read(buffer)) != -1) {
        fos.write(buffer, 0, bytesRead);
    }
}
```

**传统I/O的数据流向：**
1. DMA将磁盘数据拷贝到内核缓冲区（内核态）
2. CPU将内核缓冲区数据拷贝到用户缓冲区（用户态）
3. CPU将用户缓冲区数据拷贝到Socket缓冲区（内核态）
4. DMA将Socket缓冲区数据拷贝到网卡缓冲区

总共涉及4次拷贝和4次上下文切换。

## 2. **FileChannel.transferTo()/transferFrom()**

这是JDK中最直接的零拷贝实现：

```java
// 使用transferTo实现零拷贝 - 只需2次拷贝
try (FileInputStream fis = new FileInputStream("source.txt");
     FileOutputStream fos = new FileOutputStream("dest.txt")) {
    
    FileChannel sourceChannel = fis.getChannel();
    FileChannel destChannel = fos.getChannel();
    
    // 零拷贝传输
    long position = 0;
    long count = sourceChannel.size();
    sourceChannel.transferTo(position, count, destChannel);
    
    // 或者使用transferFrom
    // destChannel.transferFrom(sourceChannel, position, count);
}
```

**transferTo的工作原理：**
1. DMA将磁盘数据拷贝到内核缓冲区
2. DMA直接将内核缓冲区数据拷贝到网卡缓冲区（无需经过用户空间）

**优势：**
- 减少2次数据拷贝
- 减少2次上下文切换
- 完全在内核空间完成操作

## 3. **MappedByteBuffer内存映射**

内存映射通过将文件直接映射到用户空间的虚拟内存中实现零拷贝：

```java
// 使用内存映射实现零拷贝
try (RandomAccessFile file = new RandomAccessFile("source.txt", "r");
     FileChannel channel = file.getChannel()) {
    
    // 创建内存映射缓冲区
    MappedByteBuffer mappedBuffer = channel.map(
        FileChannel.MapMode.READ_ONLY,  // 映射模式
        0,                              // 起始位置
        channel.size()                  // 映射大小
    );
    
    // 直接操作内存映射的数据
    byte[] data = new byte[(int) channel.size()];
    mappedBuffer.get(data);
    
    // 或者直接写入到输出流
    try (FileOutputStream fos = new FileOutputStream("dest.txt")) {
        fos.getChannel().write(mappedBuffer);
    }
}
```

**内存映射的工作原理：**
1. 建立文件到虚拟内存的映射关系
2. 访问文件就像访问内存一样
3. 缺页异常时会自动从磁盘加载数据到内存

## 4. **网络传输中的零拷贝示例**

```java
// 服务器端：零拷贝发送文件
public class ZeroCopyServer {
    public static void main(String[] args) throws IOException {
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.socket().bind(new InetSocketAddress(9999));
        
        while (true) {
            SocketChannel socketChannel = serverSocketChannel.accept();
            
            // 准备要发送的文件
            try (FileChannel fileChannel = 
                 new FileInputStream("largefile.iso").getChannel()) {
                
                // 使用transferTo实现零拷贝传输
                long position = 0;
                long size = fileChannel.size();
                long transferred = 0;
                
                while (transferred < size) {
                    transferred += fileChannel.transferTo(
                        position + transferred, 
                        size - transferred, 
                        socketChannel
                    );
                }
            }
            socketChannel.close();
        }
    }
}

// 客户端：零拷贝接收文件
public class ZeroCopyClient {
    public static void main(String[] args) throws IOException {
        SocketChannel socketChannel = SocketChannel.open(
            new InetSocketAddress("localhost", 9999)
        );
        
        try (FileChannel fileChannel = 
             new FileOutputStream("received.iso").getChannel()) {
            
            // 使用transferFrom实现零拷贝接收
            long transferred = 0;
            while (transferred < fileChannel.size()) {
                transferred += fileChannel.transferFrom(
                    socketChannel, 
                    transferred, 
                    Long.MAX_VALUE
                );
            }
        }
    }
}
```

## 5. **性能对比分析**

| 特性     | 传统I/O | transferTo() | 内存映射    |
| ------ | ----- | ------------ | ------- |
| 拷贝次数   | 4次    | 2次           | 1-2次    |
| 上下文切换  | 4次    | 2次           | 2-3次    |
| CPU使用率 | 高     | 低            | 中       |
| 内存使用   | 中     | 低            | 高       |
| 适用场景   | 小文件   | 大文件传输        | 随机访问大文件 |

## 6. **注意事项和最佳实践**

### **注意事项：**
1. **transferTo限制**：
   - Linux系统单次传输最大限制（约2GB）
   - 需要循环传输大文件
   
2. **内存映射限制**：
   - 映射区域不能超过Integer.MAX_VALUE
   - 需要手动调用`MappedByteBuffer.force()`同步到磁盘
   - 垃圾回收问题：映射区域只有在Full GC时才会释放

### **最佳实践：**
```java
// 1. 大文件分片传输
public static void transferLargeFile(FileChannel source, 
                                     WritableByteChannel target, 
                                     long size) throws IOException {
    long position = 0;
    long transferred = 0;
    
    while (transferred < size) {
        transferred += source.transferTo(position + transferred, 
                                       size - transferred, 
                                       target);
    }
}

// 2. 安全的内存映射使用
public static void safeMemoryMap(File file) {
    try (FileChannel channel = new RandomAccessFile(file, "r").getChannel()) {
        long fileSize = channel.size();
        long position = 0;
        
        // 分片映射大文件
        while (position < fileSize) {
            long mapSize = Math.min(fileSize - position, Integer.MAX_VALUE);
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_ONLY,
                position,
                mapSize
            );
            
            // 处理数据...
            position += mapSize;
            
            // 清理映射（需要等待GC）
            clean(buffer);
        }
    }
}

// 3. 使用DirectByteBuffer减少拷贝
public static void useDirectBuffer() {
    ByteBuffer directBuffer = ByteBuffer.allocateDirect(8192);
    // 直接内存操作，避免堆内存与本地内存间的拷贝
}
```

## 7. **底层原理**

### **Linux系统的sendfile系统调用**
```c
// JDK底层调用Linux的sendfile系统调用
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

### **传输过程对比：**
- **传统I/O**：read() + write() → 4次拷贝
- **零拷贝**：sendfile() → 2次拷贝
- **支持SG-DMA的零拷贝**：真正的零拷贝（某些网卡支持）

## 总结

JDK 8中的零拷贝主要通过：
1. **`FileChannel.transferTo()/transferFrom()`**：最常用的零拷贝方式，适合大文件传输
2. **`MappedByteBuffer`**：适合随机访问大文件，但要注意内存管理
3. **`DirectByteBuffer`**：减少JVM堆与本地内存间的数据拷贝

零拷贝技术显著提升了I/O性能，特别是在网络文件传输和大文件处理场景中。

在实际应用中，应根据具体场景选择合适的技术，并注意相关限制和资源管理。