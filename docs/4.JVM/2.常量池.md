# 常量池

## Class文件常量池(磁盘)

Class文件常量池是整个常量池体系的“蓝图”和“源代码”。

- **是什么**：它是存储在`.class`文件中的一张**静态表**。
  - 当**编译**Java源代码后，编译器会将代码中出现的所有**字面量**和**符号引用**收集起来，生成这个结构。
- **存放内容**：
  - **字面量**：代码中直接书写的常量值。
    - 文本字符串：例如 `"Hello, World"`
    - `final`修饰的基本类型值：例如 `final int MAX = 100;` (注意，非`final`的`int a = 100;`中的100不属于字面量，但其值可能会在编译期被放入常量池)
    - 其他基本类型的值
  - **符号引用**：编译时无法确定具体内存地址的引用，主要包括：
    - 类和接口的全限定名
    - 字段的名称和描述符
    - 方法的名称和描述符
- **特点**：
  - **静态的**：它是`.class`文件的一部分，存在于磁盘上。
  - **准备阶段**：在JVM加载类时，Class文件常量池中的内容会被加载到内存中，从而形成“运行时常量池”。

**简单比喻**：Class文件常量池就像是一份建筑工程的**图纸清单**，列出了所有需要的材料（字面量）和构件连接方式（符号引用）。

## 运行时常量池(元空间)

运行时常量池是Class文件常量池在**内存**中的体现和运行时形态。

- **是什么**：它是**方法区**的一部分。在JDK 8中，方法区的实现叫做**元空间**，它使用的是本地内存，而不是JVM管理的堆内存。
- **生命周期**：
  - 随着类的加载而创建，在类被卸载时销毁。每个被加载的类都有自己的运行时常量池。
- **功能**：
  - 它包含了Class文件常量池中的内容。
  - 具备**动态性**：这是它与Class文件常量池最大的不同。它可以在运行时将新的常量放入池中。最典型的例子就是 `String.intern()` 方法。
  - 负责将**符号引用解析为直接引用**。在类加载的解析阶段，JVM会将在运行时常量池中的符号引用（如`java/lang/Object`）替换为指向内存中具体位置的**直接引用**（指针）。

**简单比喻**：运行时常量池就像是根据图纸清单，在工地上**实际建立起来的物料仓库**。这个仓库不仅可以存放图纸上的材料，还可以在施工过程中动态地接收新的材料。

## 字符串常量池(堆)

字符串常量池是运行时常量池中最为特殊和重要的一个部分。

- **是什么**：它是**运行时常量池的一个子集**，专门用于存储**字符串对象的字面量**和通过`intern()`方法放入的字符串的**引用**。
- **位置变化：**
  - 在**JDK 7之前**，字符串常量池位于**永久代**，也就是方法区的一部分。
  - 从**JDK 7开始**，字符串常量池被**移到了Java堆**中。
- **为什么移到堆**：
  1. **减少永久代OOM风险**：永久代大小固定，容易发生内存溢出。字符串使用频繁，容易占满永久代。
  2. **更高效的GC**：字符串常量池中的字符串和普通字符串对象一样，可以被垃圾回收器管理。当没有引用指向池中的某个字符串时，它会被GC回收。而放在堆中更便于GC操作。
- **工作机制与`intern()`方法**：
  - 当代码中出现字符串字面量（如 `String s1 = "java";`）时，JVM会首先去字符串常量池中查找是否存在相同内容的字符串。
    - 如果存在，则直接返回池中该字符串的**引用**。
    - 如果不存在，则在**堆中**创建一个新的字符串对象，并将其**引用**存入字符串常量池，然后返回这个引用。
  - `String.intern()`是一个本地方法。它的作用是：运行时调用此方法将**字符串加入String Pool**。

## 代码示例与分析

```java
public class StringConstantPoolDemo {
    public static void main(String[] args) {
        // 情况1：字面量创建
        String s1 = "Java";
        String s2 = "Java";
        System.out.println(s1 == s2); // true。s1和s2指向字符串常量池中的同一个引用。

        // 情况2：new 关键字创建
        String s3 = new String("Java");
        System.out.println(s1 == s3); // false。s3是堆中一个新对象的引用。

        // 情况3：intern方法的作用
        String s4 = s3.intern(); // 将s3对应的字符串"Java"尝试放入常量池
        System.out.println(s1 == s4); // true。s4获取到的是常量池中已存在的"Java"的引用。

        // 情况4：动态拼接（注意编译期优化）
        String s5 = "Ja" + "va"; // 编译器会优化为"Java"，所以等同于字面量创建
        System.out.println(s1 == s5); // true。

        // 情况5：含有变量的拼接
        String s6 = "Ja";
        String s7 = s6 + "va"; // 运行时会在堆中创建新的String对象
        System.out.println(s1 == s7); // false。
        
        // 使用final修饰后，变为编译期常量
        final String s8 = "Ja";
        String s9 = s8 + "va"; // 等同于 "Ja" + "va"，编译器会优化
        System.out.println(s1 == s9); // true。
    }
}
```

## 总结

| 概念                | 描述                           | 位置                 | 特点                                                 |
| :------------------ | :----------------------------- | :------------------- | :--------------------------------------------------- |
| **Class文件常量池** | `.class`文件中的静态表         | 磁盘上的`.class`文件 | 存储字面量和符号引用；静态的                         |
| **运行时常量池**    | Class文件常量池的内存映射      | **元空间**           | 每个类独有；具备动态性；负责解析符号引用             |
| **字符串常量池**    | 运行时常量池中处理字符串的部分 | **Java堆**           | 全局共享；存储字符串字面量和`intern()`的引用；可被GC |

理解这三者的关系与区别，对于深入掌握JVM内存模型、类加载机制以及字符串相关的性能优化至关重要。