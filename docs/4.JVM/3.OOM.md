# OOM

好的，作为Java技术专家，我们来深入探讨一下OOM（内存溢出）这个让所有Java开发者都头疼的问题。

## 什么是OOM？

**OOM**，全称 `OutOfMemoryError`，是Java虚拟机在内存耗尽、无法再分配对象时抛出的一个错误（`Error`，不是`Exception`）。这是一个严重的JVM级问题，会导致当前线程甚至整个应用程序崩溃。

---

## OOM的常见类型与原因

在JDK 8及以后，常见的OOM有以下几种，每种都指向不同的根本原因：

1. **`java.lang.OutOfMemoryError: Java heap space`**
   *   **原因**：这是最经典的OOM。**堆内存**不足以创建新的对象。
   *   **场景**：
       *   **内存泄漏**：对象已经不再使用，但由于错误的引用（如静态集合、缓存等），GC无法回收它们。
       *   **数据量过大**：一次性加载了过大的数据到内存（如从数据库读取百万行数据）。
       *   **堆内存设置过小**：通过`-Xmx`参数设置的堆最大值太小，无法满足应用正常需求。

2. **`java.lang.OutOfMemoryError: Metaspace`**
   *   **原因**：**元空间**内存不足。元空间在JDK 8中取代了“永久代”，用于存储类的元数据（如类名、方法信息、字段信息等）。
   *   **场景**：
       *   大量动态生成类（例如，使用CGLib、ASM、JSP等）。
       *   频繁地热部署/重新加载应用，导致旧的类加载器和其加载的类无法被卸载。
       *   元空间大小（`-XX:MaxMetaspaceSize`）设置过小或未设置（默认只受本地内存限制）。

3. **`java.lang.OutOfMemoryError: GC overhead limit exceeded`**
   *   **原因**：这是一种“友好”的OOM。JVM花费了**98%以上的时间进行垃圾回收**，但只回收了**不到2%的堆内存**。这通常意味着堆内存几乎已满，GC在做无用功。
   *   **本质**：它通常是**内存泄漏**的一个强烈信号。

4. **`java.lang.OutOfMemoryError: Unable to create new native thread`**
   *   **原因**：操作系统限制，无法创建新的本地线程。
   *   **场景**：
       *   应用创建了过多线程且未有效管理。
       *   操作系统的线程数限制（如Linux的`ulimit -u`）过低。
       *   在32位JVM或内存有限的系统中，进程的虚拟地址空间耗尽。

5. **`java.lang.OutOfMemoryError: Direct buffer memory`**

   - **原因**：直接内存（堆外内存）不足
   - **常见场景**：使用NIO的DirectByteBuffer

   **解决方案**：

   - 增加直接内存：`-XX:MaxDirectMemorySize=512m`
   - 及时释放DirectBuffer

---

## 如何排查OOM？

排查OOM是一个系统性的工作，以下是标准的排查流程和工具：

#### 第零步：复现问题
尽可能在测试或预发环境稳定复现问题，这是排查的基础。

#### 第一步：获取内存快照
这是最关键的一步！必须在JVM崩溃前或发生OOM时，保存下内存的“现场证据”。

*   **自动生成堆转储**：在启动JVM时添加参数，让它在发生OOM时自动导出堆转储文件。
    ```bash
    -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/save/dump.hprof
    ```

*   **手动生成堆转储**：如果应用还未崩溃，可以使用工具手动导出。
    *   `jmap` 命令：
        ```bash
        jmap -dump:live,format=b,file=dump.hprof <pid>
        ```
    *   JConsole / JVisualVM：通过图形化界面操作。

#### 第二步：分析内存快照
使用专业的工具加载上一步生成的`.hprof`文件。

*   **推荐工具**：
    *   **Eclipse MAT**：功能最强大、最专业，是首选。
    *   **JVisualVM**：JDK自带，基础分析足够。
    *   **JProfiler**：商业软件，功能全面，界面友好。

*   **分析思路（以MAT为例）**：
    1.  **Leak Suspects Report**：打开快照后，MAT通常会直接给出一个“泄漏嫌疑”报告，它会指出可能发生内存泄漏的对象和线程。
    2.  **Histogram**：查看内存中所有类的实例数量和总占用大小。重点关注 `char[]`, `String`, 以及你自己定义的业务对象类。
    3.  **Dominator Tree**：**支配树**。这是找出“谁持有了最多内存”的最有效工具。它会列出所有“GC Root”到对象的引用链，并显示哪些对象直接支配了最大的内存。通常，内存泄漏的元凶就在这里。
    4.  **查看引用链**：在Histogram或Dominator Tree中，对可疑的类右键选择 **`Path To GC Roots`** -> **`with all references`**。这会展示出这个对象为什么没有被GC回收，即是谁在一直引用着它。常见的罪魁祸首是静态Map、线程池、未关闭的连接等。

#### 第三步：结合运行时监控
在分析快照的同时，可以结合其他监控工具来佐证和定位问题。

*   **`jstat`**：查看GC统计信息。
    ```bash
    jstat -gcutil <pid> 1000
    ```
    这条命令每秒打印一次GC情况，观察`O`（老年代使用率）和`FGC`（Full GC次数）是否持续增长，这能帮助确认是内存泄漏还是瞬时高峰。

*   **`jstack`**：获取线程快照。对于排查线程数过多导致的OOM非常有用。
    ```bash
    jstack <pid> > thread_dump.txt
    ```

---

## 如何解决OOM？

根据排查出的根本原因，采取相应的解决方案：

1.  **针对 `Java heap space`**：
    *   **如果是内存泄漏**：根据MAT分析出的引用链，修复代码。例如：
        *   及时清理静态集合中的无用对象。
        *   使用弱引用（`WeakReference`）来实现缓存。
        *   确保关闭所有IO流、数据库连接等资源（使用try-with-resources）。
    *   **如果是数据量过大**：优化程序逻辑，避免一次性加载全部数据，采用分页、分批处理。
    *   **如果是堆大小问题**：适当调大堆内存（`-Xmx`），但这不是根本解决办法，必须先排除内存泄漏。

2.  **针对 `Metaspace`**：
    *   检查是否有不必要的动态类生成。
    *   优化应用部署和重启策略，避免频繁热部署。
    *   适当调大元空间大小：`-XX:MaxMetaspaceSize=256m`。

3.  **针对 `GC overhead limit exceeded`**：
    *   它的根本原因和 `Java heap space` 类似，所以解决方法也相同：**查找并修复内存泄漏**。
    *   作为一种临时措施，可以禁用此保护（不推荐）：`-XX:-UseGCOverheadLimit`。

4.  **针对 `Unable to create new native thread`**：
    *   优化代码，使用线程池，避免无限制地创建线程。
    *   检查并调高操作系统级别的线程数限制（`ulimit -u`）。
    *   减少每个线程的栈大小（`-Xss`），但需谨慎，可能导致栈溢出。
5.  **针对`Direct buffer memory`**：
    - 增加直接内存：`-XX:MaxDirectMemorySize=512m`
    - 及时释放DirectBuffer。

## 总结

OOM排查与解决的通用流程可以总结为：

**监控预警 -> 复现问题 -> 获取堆转储 -> 使用MAT等工具分析 -> 定位GC Roots引用链 -> 修复代码/调整配置**

记住，**预防胜于治疗**。在开发阶段就养成良好的编程习惯（如管理好资源、谨慎使用全局缓存），并在生产环境配备完善的监控和告警系统，是避免OOM的最佳实践。