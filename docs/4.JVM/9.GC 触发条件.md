# GC 触发条件

## 一 类型

- **Minor GC / Young GC**：只收集年轻代的垃圾。
- **Major GC / Old GC**：只收集老年代的垃圾。（注意：有时 Major GC 和 Full GC 被混用，但严格来说不同）。
- **Full GC**：收集整个堆，包括年轻代、老年代，以及方法区。通常停顿时间最长，应尽量避免。

好的，我们来详细解析垃圾收集的触发条件。不同区域（年轻代、老年代）和不同收集器的触发条件有所不同。

---

## 二 年轻代 GC 触发条件

年轻代 GC 通常指 **Minor GC**，其触发条件相对简单直接。

### 核心触发条件：**Eden 区空间不足**

当 JVM 尝试为一个新对象分配内存，但发现 **Eden 区已经没有足够的连续空间** 来容纳该对象时，就会触发一次 Minor GC。

**详细过程如下：**
1.  新对象优先在 Eden 区分配。
2.  随着程序运行，Eden 区被逐渐填满。
3.  当再次需要创建对象，且 Eden 区无法满足此次分配请求时，JVM 会立即发起一次 **Stop-The-World** 的 Minor GC。
4.  Minor GC 会回收整个年轻代（Eden + 一个 Survivor 区），将存活的对象复制到另一个 Survivor 区（或直接晋升到老年代）。
5.  回收完成后，Eden 区和被清空的 Survivor 区变为空闲，对象分配请求得以继续。

**注意**：`System.gc()` 方法调用**可能**会触发 Minor GC（更常见的是触发 Full GC），但这取决于 JVM 的具体实现和 `-XX:+DisableExplicitGC` 参数的设置。

---

## 三 老年代 GC 触发条件

老年代 GC 的触发条件更为复杂，根据使用的垃圾收集器不同而有所差异。老年代 GC 可能是 **Major GC**（只回收老年代）或 **Full GC**（回收整个堆）。

### 1. 通用触发条件

*   **空间分配担保失败**
    *   **背景**：在发生 Minor GC 之前，JVM 会检查老年代的**最大可用连续空间**是否大于**年轻代所有对象的总大小**。
    *   **原因**：这是为了确保，即使在最坏的情况下（年轻代的所有对象都存活），老年代也有足够的空间来容纳它们。
    *   **触发条件**：如果检查失败（老年代剩余空间 < 年轻代对象总大小），并且 `-XX:-HandlePromotionFailure` 参数不允许担保失败（在 JDK 6 Update 24 之后，这个参数不再有效，规则已内置），那么 JVM **不会先进行 Minor GC，而是会直接触发一次 Full GC**，以腾出老年代空间。

*   **老年代空间不足**
    *   当程序需要将一个大对象或晋升的对象放入老年代，但老年代没有足够的空间时，会触发 Full GC。
    *   这是最常见的 Full GC 触发原因之一。

*   **方法区（元空间）空间不足**
    *   在 JDK 8 中，方法区由**元空间**实现。当元空间需要扩容但无法从操作系统申请到更多内存，或者使用的内存达到了 `-XX:MaxMetaspaceSize` 设置的上限时，会触发 Full GC。

*   **显式调用 System.gc()**
    *   代码中调用 `System.gc()` 或 `Runtime.getRuntime().gc()` **建议** JVM 进行垃圾回收。JVM 通常会（但不是必须）响应这个建议，触发一次 Full GC。
    *   可以通过参数 `-XX:+DisableExplicitGC` 来禁止这种显式GC。

### 2. 特定于收集器的触发条件

#### **CMS 收集器**

*   **并发模式失败**
    *   **背景**：CMS 的目标是与用户线程并发执行，以降低停顿。但在并发清理过程中，用户线程还在运行，可能产生新的垃圾（"浮动垃圾"）或需要晋升新对象到老年代。
    *   **触发条件**：如果在 CMS 并发周期执行期间，老年代空间被迅速填满，导致无法满足用户线程的分配需求，此时 JVM 会中止 CMS，并触发一次 **"Stop-The-World" 的 Full GC**（通常是使用 Serial Old 收集器）。这是使用 CMS 时最需要避免的情况。
    *   **相关参数**：`-XX:CMSInitiatingOccupancyFraction` 用于设置老年代空间使用率阈值，当达到此阈值时开始 CMS 回收。如果这个值设置得过高（如 92%），就很容易导致并发模式失败。

*   **晋升失败**
    *   **触发条件**：在 Minor GC 后，需要将存活对象晋升到老年代，但老年代由于**内存碎片**严重，没有足够的**连续空间**来容纳这些对象，即使老年代的总剩余空间是足够的。这时也会触发 Full GC。

#### **G1 收集器**

G1 的触发逻辑与其独特的区域设计紧密相关。

*   **年轻代 GC 触发**：与通用条件相同，当 **Eden Region 被耗尽**时触发。

*   **并发标记周期触发**
    *   **触发条件**：当**整个 Java 堆的使用率**达到阈值时触发。
    *   **相关参数**：`-XX:InitiatingHeapOccupancyPercent`（默认 45%）。当堆总使用率达到 45% 时，G1 会启动并发标记周期。

*   **混合 GC 触发**
    *   **触发条件**：在**并发标记周期完成之后**，G1 会开始一系列混合 GC。混合 GC 不仅回收年轻代 Region，还会根据回收价值选择性回收部分老年代 Region。

*   **Full GC 触发**
    *   G1 的设计目标之一就是避免 Full GC。但当发生以下情况时，G1 会**退化**为 Serial Old 收集器进行 Full GC：
        1.  **并发模式失败**：在并发标记周期完成前，老年代就被快速填满，没有足够的空间供用户线程分配。
        2.  **晋升失败**：在混合 GC 进行期间，复制存活对象时找不到可用的空闲 Region。
        3.  **巨型对象分配失败**：无法为巨型对象找到连续的 Humongous Region。

---

## 四 总结

| GC 类型         | 主要触发条件                | 备注                                                     |
| :-------------- | :-------------------------- | :------------------------------------------------------- |
| **Minor GC**    | **Eden 区分配失败**         | 最直接、最常见的年轻代GC触发条件。                       |
| **Full GC**     | **老年代空间不足**          | 对象晋升或大对象分配时，老年代没有足够空间。             |
|                 | **空间分配担保失败**        | Minor GC 前检查老年代空间不足以容纳年轻代全部存活对象。  |
|                 | **元空间空间不足**          | 元空间使用达到 `MaxMetaspaceSize` 或无法从系统申请内存。 |
|                 | **System.gc() 调用**        | 显式建议，可通过参数禁用。                               |
| **CMS Full GC** | **并发模式失败**            | 并发回收期间，老年代被快速填满。**CMS 中最常见的问题**。 |
|                 | **晋升失败**                | 老年代碎片太多，无法容纳晋升对象。                       |
| **G1 Full GC**  | **并发模式失败 / 晋升失败** | 内存回收速度跟不上对象分配速度，导致退化。               |
| **G1 混合 GC**  | **并发标记周期完成**        | 在并发标记之后，自动开始混合回收阶段。                   |

## 五 建议

1.  **监控 GC 日志**：使用 `-XX:+PrintGCDetails` 等参数开启 GC 日志，这是诊断 GC 触发原因的最重要依据。
2.  **合理设置堆大小**：避免堆设置过小导致频繁 GC，或过大导致单次 GC 停顿过长。
3.  **关注 CMS 的 IHOP**：使用 CMS 时，合理设置 `-XX:CMSInitiatingOccupancyFraction`，为并发回收预留足够空间，避免并发模式失败。
4.  **G1 的调优重点**：对于 G1，目标是避免其发生 Full GC。需要确保堆内存足够，并监控并发标记周期是否能及时完成。
