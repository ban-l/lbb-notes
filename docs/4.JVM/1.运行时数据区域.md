# 运行时数据区域

![image-20250922205958814](assets/image-20250922205958814.png)

## 私有数据区

### 程序计数器

**定义**：一块较小的内存空间，可以看作是**当前线程所执行的字节码的行号指示器**。

**作用**：

- 字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

**特点**：

- **线程私有**：每条线程都有一个独立的程序计数器，各条线程之间互不影响，独立存储。
- 如果线程正在执行的是一个 **Java 方法**，这个计数器记录的是正在执行的**虚拟机字节码指令的地址**。
- 如果正在执行的是 **Native 方法**（本地方法，如 C++ 代码），这个计数器的值则为**空** (Undefined)。
- 此区域是**唯一一个**在《Java 虚拟机规范》中没有规定任何 `OutOfMemoryError` 情况的区域。

### Java 虚拟机栈

Java虚拟机栈是线程执行Java方法的**现场**，每一个栈帧都记录了一个方法调用所需的全部信息，包括它的局部变量、计算中间结果、如何返回以及它属于哪个方法。

**定义**：描述 Java **方法执行的内存模型**。

- 每个方法在执行的同时都会创建一个**栈帧** (Stack Frame) 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
- 每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**线程私有**：生命周期与线程相同。

**栈帧 (Stack Frame)** 的构成：

- **局部变量表** (Local Variable Table)：
  - **存储内容**：用于存放**方法参数**和**方法内部定义的局部变量**。
  
  - **存储单位**：它以**变量槽（Slot）** 为基本单位。
  
    - 对于基本数据类型（`boolean`, `byte`, `char`, `short`, `int`, `float`, `long`, `double`），除了 `long` 和 `double` 占用2个Slot，其余都占用1个Slot。
    - 对于引用类型（`reference`），它存储的是一个**指向堆内存中对象实例的引用地址**，占用1个Slot。
  
  - 所需内存空间在**编译期间**完成分配。
  
  - **索引访问**：通过索引来访问，而非内存地址。索引0通常用于存储**实例方法**的 `this` 引用（静态方法没有this），然后从1开始依次是方法的参数、方法体内定义的局部变量。
  
  - ```java
    public void myMethod(int param1, Object param2) {
        int localVar1 = 10;
        String localVar2 = "hello";
        // ...
    }
    ```
  
  - 对应的局部变量表大致如下：
  
    | 索引 | 内容        | 说明                  |
    | :--- | :---------- | :-------------------- |
    | 0    | `this`      | 当前对象的引用        |
    | 1    | `param1`    | 方法参数1             |
    | 2    | `param2`    | 方法参数2（一个引用） |
    | 3    | `localVar1` | 局部变量1             |
    | 4    | `localVar2` | 局部变量2（一个引用） |
  
- **操作数栈** (Operand Stack)：用于**执行字节码指令**。
  
  - **存储内容**：方法执行过程中，各种字节码指令（如算术运算、方法调用等）都是通过操作数栈来**写入和取出中间结果**的。
  - **工作方式**：可以把它想象成一个**工作台**。例如，执行 `iadd`（整数加法）指令时，它会从操作数栈的顶部弹出两个整数，将它们相加，然后再将结果压回栈顶。
  - **示例：**对于代码 `int a = 1 + 2;`，其字节码指令在操作数栈中的操作可能如下：
    1. `iconst_1`：将整数1压入操作数栈。 [ 1 ]
    2. `iconst_2`：将整数2压入操作数栈。 [ 1, 2 ]
    3. `iadd`：弹出栈顶的两个值（1和2），相加得到3，将3压入栈顶。 [ 3 ]
    4. `istore_1`：将栈顶的整数值3弹出，并存入局部变量表索引1的位置（对应变量a）。 [ ]
  
- **动态链接** (Dynamic Linking)：
  
  - **存储内容**：指向**运行时常量池(方法区)**中该栈帧所属方法的引用。
  - **作用**：在方法调用过程中，需要将符号引用（如方法名、描述符）转换为具体的直接引用（如方法在内存中的实际地址）。动态链接的作用就是在**运行时**完成这个转换。这与“静态解析”（在类加载阶段完成转换）相对应。Java的多态性（虚方法调用）很大程度上依赖于动态链接。
  
- **方法返回地址** (Return Address)：
  - **存储内容**：方法被调用时，**调用者程序计数器的值**。
  - **作用**：当一个方法正常执行完成或通过异常终止后，JVM需要知道接下来应该回到哪里继续执行。这个地址就是用来告诉JVM应该跳转回调用该方法的下一条指令位置。

**异常** (Error)：

- **`StackOverflowError`**：如果线程请求的栈深度大于虚拟机所允许的深度（例如无限递归）。
- **`OutOfMemoryError`**：如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的内存。


### 本地方法栈

**作用**：与虚拟机栈非常相似。其区别在于：**虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

**线程私有**。

《Java 虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

**异常**：与虚拟机栈一样，也会抛出 `StackOverflowError` 和 `OutOfMemoryError`。

## 共享数据区

### 堆（heap，GC 堆）

**定义**：这是 JVM 所管理的**内存中最大的一块**。是被所有线程**共享**的一块内存区域，在虚拟机启动时创建。

**作用**：**此内存区域的唯一目的就是存放对象实例。几乎所有的对象实例以及数组都在这里分配内存。**

- **普通对象**：例如 `new String()`, `new ArrayList<>()`, `new MyCustomClass()` 等。

- **数组对象**：无论是基本类型数组（如 `int[]`）还是引用类型数组（如 `String[]`），数组本身这个对象是在堆上的。

- **字符串常量池**：
  - **字符串字面量**：例如，代码中直接写的 `"hello"`。
  - 调用 `String` 的 `intern()` 方法后，如果池中不存在，则会将该字符串的引用放入池中。


  > **注意**：随着 JIT 编译器的发展与**逃逸分析**技术的逐渐成熟，**栈上分配**和**标量替换**优化技术允许某些线程私有的对象被拆分后直接在栈上分配，而不一定全部在堆上分配。但这属于优化行为，从 JVM 规范的角度看，对象实例的分配地点是堆。

**特点**：

- 是**垃圾收集器管理的主要区域**，因此很多时候也被称作 **“GC 堆”** (Garbage Collected Heap)。
- 从内存分配的角度看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer, TLAB)，以提升对象分配时的效率。
- 现代 JVM（如 HotSpot）的堆内存结构不再是简单的“新生代+老年代”，但其主流GC（如G1, ZGC）仍然遵循分代收集理论来设计。

**新生代** (Young Generation)：新创建的对象首先在这里分配。又可细分为：
- **Eden 区（伊甸园）**：新对象出生的地方。
- **Survivor 区（幸存者区）**：分为 S0 和 S1（也称为 From 和 To）。在 Minor GC 后，存活的对象会从 Eden 区被移动到空的 Survivor 区，并且年龄加 1。多次 GC 后仍然存活的对象（默认年龄达到 15）会被晋升到老年代。

**老年代** (Old Generation / Tenured Generation)：

- 在新生代中经历了多次 GC 后仍然存活的对象会被晋升到老年代
- 一些大对象（可能会直接分配在老年代）
- 老年代区域发生的垃圾回收称为 Major GC / Full GC，频率较低，但耗时通常远长于 Minor GC。

**注意**：在 G1垃圾收集器 中，堆的物理结构是不连续的区域集合，但逻辑上仍保留分代概念。

**异常**：**`OutOfMemoryError`**：如果在堆中没有内存完成实例分配，并且堆也无法再扩展时。


### 方法区

⽅法区是接口、是规范；永久代/元空间是 HotSpot 虚拟机给出的实现。方法区规定要存放的内容，都放在永久代/元空间。

#### JDK 7及以前：永久代

永久代位于虚拟机内存中。

用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
- 很难确定永久代的大小，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出OutOfMemoryError 异常。
- 永久代的空间有限，大量使用字符串场景下会导致  OutOfMemoryError 错误

#### JDK 8及以后：元空间

元空间位于本地内存中。

每个被加载的类，其相关信息都会存储在元空间里，包括：

- **类的结构信息**：例如类的全限定名、直接父类的全限定名、访问修饰符（public, final, abstract等）。
- **方法的元数据**：方法名、返回值类型、参数列表（包含参数类型和顺序）、访问修饰符、方法的字节码、异常表等。
- **字段的元数据**：字段名、类型、访问修饰符。
- **运行时常量池**：这是类文件中常量池表的运行时表示。它包含更多的符号引用，如：
  - 类和接口的全限定名
  - 字段的名称和描述符
  - 方法的名称和描述符
- **类级别的注解**。
- **方法信息表（Method Code）**：方法的字节码、局部变量表、操作数栈大小等信息（但实际执行的JIT编译后的代码存放在**代码缓存（Code Cache）** 中，不属于元空间）。

| 特性            | 永久代（JDK 7及以前）                       | 元空间（JDK 8及以后）                                        |
| :-------------- | :------------------------------------------ | :----------------------------------------------------------- |
| **位置**        | 堆内存的一部分                              | **本地内存（Native Memory）**                                |
| **大小限制**    | 固定大小，通过 `-XX:MaxPermSize` 设置       | 默认只受本地内存大小限制。可通过 `-XX:MaxMetaspaceSize` 设置上限 |
| **垃圾回收**    | Full GC时触发，回收效率低，容易导致OOM      | 当类加载器死亡时，会触发对其加载的类的元数据进行回收。独立于Java堆的GC，更高效。 |
| **出现OOM错误** | `java.lang.OutOfMemoryError: PermGen space` | `java.lang.OutOfMemoryError: Metaspace`                      |

### 直接内存

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。

这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。

**直接内存(Direct Memory)**并不是虚拟机运行时数据区的一部分，但也被频繁使用（如NIO），可能导致OutOfMemoryError。

### **简单记忆**

**堆是用来“装东西”的（装对象），而元空间 / 方法区是用来“描述东西”的（描述类、方法、字段等）**。

当你用 `new` 创建东西时，东西本身在堆里，而它的“设计图纸”（类定义）在元空间里。

## 内存参数

![image-20251105212645014](assets/image-20251105212645014.png)

---

### 1. `-Xmx`（最大堆内存）

*   **全称**：Maximum Heap Size
*   **作用**：设置 **Java 堆（Heap）的最大值**。堆是 JVM 中用于存放对象实例的内存区域。
*   **重要性**：这是**最重要**的 JVM 参数之一。它限制了你的 Java 应用程序最多能使用多少内存来创建对象。
*   **默认值**：取决于系统物理内存，通常为物理内存的 1/4。
*   **何时需要调整**：
    *   当应用程序遇到 `java.lang.OutOfMemoryError: Java heap space` 错误时，表明应用程序试图分配一个对象，但堆空间不足，且 GC 后也无法回收出足够空间。此时可以考虑增大 `-Xmx`。
    *   当系统物理内存充足，且希望应用能缓存更多数据或处理更大任务时，可以适当增加。
*   **注意事项**：
    *   不能设置得超过物理内存和操作系统对单个进程的限制。
    *   设置过大可能会导致 GC 停顿时间变长，因为需要回收和管理的区域变大了。
    *   在容器化环境（如 Docker）中，应确保 `-Xmx` 小于容器的内存限制，否则容器可能会被系统杀死。

**示例**：
```bash
java -Xmx2g -jar myapp.jar
```
这表示应用程序的堆内存最大不能超过 2 GB。

---

### 2. `-Xms`（初始堆内存）

*   **全称**：Initial Heap Size
*   **作用**：设置 **Java 堆（Heap）的初始大小**。JVM 启动时就会向操作系统申请这么多内存作为堆的开始。
*   **重要性**：通常与 `-Xmx` 配对使用。
*   **默认值**：取决于系统物理内存，通常为物理内存的 1/64。
*   **何时需要调整**：
    *   **性能调优的关键点**：将 `-Xms` 和 `-Xmx` 设置为**相同的值**。
    *   **为什么？** 这可以避免 JVM 在运行时动态调整堆大小。堆扩容是一个昂贵的操作，需要暂停应用并进行内存重分配。如果初始堆就足够大，JVM 就无需在应用运行高峰期进行扩容，从而消除了因堆大小调整带来的性能波动，使系统运行更稳定。
    *   这被称为“固定堆大小”策略，在生产环境中被广泛推荐。

**示例**：
```bash
java -Xms2g -Xmx2g -jar myapp.jar
```
这表示 JVM 启动时直接申请 2 GB 堆内存，并且最大堆内存也是 2 GB，堆大小被固定。

---

### 3. `-Xss`（线程栈大小）

*   **全称**：Thread Stack Size
*   **作用**：设置**每个 JVM 线程的栈（Stack）内存大小**。线程栈用于存储方法的局部变量、部分结果以及方法调用信息（栈帧）。
*   **默认值**：取决于操作系统和 JVM 版本，例如在 Linux/x64 上，现代 JDK 通常默认是 1 MB。
*   **何时需要调整**：
    *   **`StackOverflowError`**：如果你的应用有非常深的递归调用，可能会耗尽栈空间，抛出此错误。此时可以考虑适当增加 `-Xss`。
    *   **内存紧张且线程数多**：相反，如果你的应用创建了海量线程（例如成千上万个），每个线程默认的 1MB 栈会占用大量内存（1000个线程 ≈ 1GB内存）。在这种情况下，如果确认没有很深的调用栈，可以适当**减小** `-Xss`（例如设为 256k）来节省总内存开销。
    *   **`OutOfMemoryError: unable to create new native thread`**：这个错误有时也与 `-Xss` 和系统总内存有关，因为每个新线程都需要分配一块 `-Xss` 大小的内存。

**示例**：
```bash
java -Xss512k -jar myapp.jar
```
这表示将每个线程的栈大小设置为 512 KB。

---

### 总结与类比

为了帮助你更好地理解，我们可以用一个“工厂”来类比：

| JVM 组件       | 参数            | 类比                                                         |
| :------------- | :-------------- | :----------------------------------------------------------- |
| **堆 (Heap)**  | `-Xms`, `-Xmx`  | **主原料仓库**                                               |
|                | `-Xms` (初始堆) | 仓库刚建好时的初始面积                                       |
|                | `-Xmx` (最大堆) | 仓库法律上允许的最大面积                                     |
| **栈 (Stack)** | `-Xss`          | **每个工人的工作台**                                         |
|                |                 | 工作台大小固定，每个新招一个工人，就给他配一个这么大的工作台。工人越多，总工作台占地面积越大。 |

**生产环境常用配置示例**：

对于一个典型的 Spring Boot 微服务，部署在 4C8G 的服务器上，一个合理的启动参数可能是：

```bash
java -server \
     -Xms2g \        # 初始堆 2G
     -Xmx2g \        # 最大堆 2G，与初始堆一致，固定堆大小
     -Xss512k \      # 线程栈 512KB，节省线程多时的总内存
     -XX:+UseG1GC \  # 使用 G1 垃圾收集器
     -jar my-application.jar
```

**核心要点**：
1.  `-Xmx` 设定了你的应用创建对象的“天花板”。
2.  将 `-Xms` 和 `-Xmx` 设为相同值是提升性能稳定性的简单有效手段。
3.  `-Xss` 影响着单个线程的内存开销，需要根据应用的线程数量和调用栈深度来权衡。
