# 基础程序设计结构
# Java 与 C++ 的区别
1. Java 是纯粹的面向对象语言，所有对象都继承自` java.lang.Object`，C++ 支持面向对象和面向过程。
2. Java 通过虚拟机实现**跨平台**（**一次编译，到处执行**）特性，但是 C++ 依赖于特定的平台。
3. Java **没有指针**，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
4. Java **支持自动垃圾回收**，而 C++ 需要手动回收。
5. Java **不支持多重继承**，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
6. Java **不支持操作符重载**，而 C++ 可以。
7. Java 的 **goto 是保留字，但是不可用**，C++ 可以使用 goto。
8. Java和C/C++最大的不同：**内存管理**。

## 内存管理差异

### C/C++中的指针

在C/C++中，指针直接操作内存地址，允许对内存进行灵活控制，但也容易引发以下问题：
- 内存损坏：指针操作不当可能导致数据损坏或程序崩溃。
- 野指针：指向已释放内存的指针可能引发不可预知的行为。
- 内存泄漏：未释放不再使用的内存会导致内存泄漏。

### Java中的引用

Java使用引用而非指针，引用指向对象但不直接操作内存地址，具有以下特点：
- 内存安全：Java自动管理内存，通过垃圾回收机制回收不再使用的对象，避免内存泄漏。
- 边界检查：数组和集合在访问时进行边界检查，防止越界访问。
- 无显式指针：开发者无法直接操作内存地址，减少了内存损坏的风险。

### 总结

Java通过引用模型和自动内存管理，避免了C/C++中常见的指针问题，如内存损坏和数据损坏，提升了程序的稳定性和安全性。

# JRE or JDK

JRE：Java Runtime Environment，**Java 运行环境**，提供了 Java 所需的**运行环境**。

- JRE是一个 **JVM 程序**，主要包括了 **JVM** **的标准实现**和一些 Java **基本类库**。

JDK：Java Development Kit，**Java 开发工具包**，提供了 Java 的**开发及运行环境**。

- JDK是Java 开发的核心，集成了**JRE**以及一些**其它工具**，如编译Java 源码的**编译器 javac** 等。

# 基础

1. **Java是解释型语言**
2. Java存在即时编译(“热点”字节码转化为机器码)
3. Javac：Java编译器，`.java`编译为`.class`，Java虚拟机执行字节码
4. Java自动进行垃圾回收，如果一个内存块不再使用了，系统将回收。
5. Java没有运算符重载功能
6. Java中，对象值即为引用，任何对象变量的值都是对存储在另一个地方的某个对象的引用。
7. 所有的Java对象都存储在堆中
8. Java区分大小写

9. 访问修饰符：public、protected、default、private 控制访问级别
10. Java代码以分号`;`结束
11. 类名必须以字母为开头，后跟字母和数字，但不能使用Java保留字
12. 骆驼命名法
13. java9中，单下划线_不能作为变量名
14. Java虚拟机从指定类中的`main`方法的代码开始执行
15. 三种注释
       1. 单行注释 / /
       2. 多行注释 /*  */ ，此注释不可嵌套
       3. 文档注释 /  / 
16. 空白符会被Java编译器（Javac）忽略
17. `final` 指示常量，只赋值一次且不能再次修改，常量名使用全大写
18. `static` 指示类常量，定义在main方法外部，可以在一个类的多个方法中使用
19. 变量的取值在一个有限集合内，自定义枚举类型（`enumerate`），枚举类型包括有限个命名的值（对象）
    1. `enum Size { M, S, L, XL, XXL, XXXL}; Size s = Size.XXXL;`

# 数据类型（**强类型**）

1. **Java是强类型语言：必须为每一种变量声明一种类型**

2. 8种基本数据类型
   1. byte：1字节
   2. short：2字节
   3. int：4字节
   4. long：8字节
   5. float：4字节
   6. double：8字节
   7. char：2字节
   8. boolean
      1. **单独声明** 的 `boolean`：通常占用 **1 个字节**。
      2. **数组中的 `boolean`**：通常占用 **1 个字节**。
      3. 在某些 JVM 实现中，`boolean` 可能被优化为占用 **4 个字节（32 位）**，尤其是在栈上分配时，以对齐内存。

3. 数据类型前后缀表示
   - 后缀L，l ：long
   - 后缀F，f：float 有效数字6-7位
   - 后缀D，d：double 有效数字15位
   - 前缀0x，0X ：十六进制
   - 前缀0：八进制
   - **前缀0b，0B：二进制**

4. 字符采用**Unicode格式**存储

5. 所有浮点数值计算遵循：IEEE 754规范

6. BigDecimal：任意精度的浮点数运算

- BigInteger：任意精度的整数运算

8. 不能使用算术运算符处理大数，使用add和multiply方法

9. **特殊浮点数值：**
   - 正无穷大
   - 负无穷大
   - NAN（不是数字）：0/0 、负数的平方根结果为NAN

10. 整型值和布尔值之间不能进行相互转换

11. 数据类型之间的合法转换，虚线表示可以强转（可能有精度丢失），如下图：

    ![image-20250227224157823](assets/image-20250227224157823.png)

# 隐式类型转换

```java
short s1 = 1;
s1 = s1 + 1; // 报错
```

字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型，需要强转。

但是使用 `+= `或者 `++`运算符会执行隐式类型转换。

```java
short s1 = 1;
s1 += 1;
s1++;
```

上面语句相当于将 `s1 + 1`的结果进行了向下转型(强转)：`s1 = (short) (s1 + 1)`

如果运算符得到一个值，其类型与左侧操作数的类型不同，就会强转（隐式类型转换）

- x为int类型，`x += 3.5` ，会把x设置为`(int)(x+3.5)`，强转为int

# 运算符

## 优先级: 单运移比,按逻三赋

- **单**目： `+(正)  –(负)  ++  -- ~`
- **运**算： `* / % + -`
- **位**移：<<  >> `
- **比**较：`>  <  >=  <=  ==  !=`
- **按**位：`& | ^`
- **逻**辑： `&& || !` 短路运算符
- **三目**： `A > B ? X : Y`
- **赋**值： `=`

 注意

- `&& || !` 是短路运算符

- `/`（除法运算）的两个操作数都是**整数**时，表示**整数除法**，否则，表示浮点除法

- 自增自减

  - ++前：先+1，再参与运算

  - 后++：先运算（使用原来的值），再+1

## 位运算符

| 位运算符 | 作用     | 优先级 | 类型       |
| -------- | -------- | ------ | ---------- |
| ~        | 按位取反 | 1      | 单目       |
| <<       | 左移     | 2      | 位移、双目 |
| >>       | 右移     | 2      | 位移、双目 |
| &        | 按位与   | 3      | 按位、双目 |
| ^        | 按位异或 | 4      | 按位、双目 |
| \|       | 按位或   | 5      | 按位、双目 |

在Java中，位运算符用于直接操作整数类型的**二进制位**。

位运算符通常用于低级别的编程任务，如硬件控制、加密算法和性能优化。

- 如`int`、`long`、`short`、`byte`和`char`

运算规则：**位运算后若无赋值操作，则变量值不变**。

 ```java
  int i = 1;
  // 1 << 3 = 1 * 2^3 = 8
  System.out.println(i << 3);
  // 1 >> 3 = 1 / 2^3 = 1/8 = 0
  System.out.println(i >> 3);
  // 位运算后若无赋值操作，则变量的值不变。
  // i = 1
  System.out.println(i);
 ```

### 1. 按位与（`&`）

对两个操作数的每一位进行与操作。如果两个对应的位都为1，则结果为1，否则为0。

```java
// 1&1=1  0&0=0  1&0=0  0&1=0

int a = 5;  // 二进制: 0101
int b = 3;  // 二进制: 0011
int result = a & b;  // 结果: 0001 (十进制1)
System.out.println(result);  // 输出: 1
```

### 2. 按位或（`|`）

对两个操作数的每一位进行或操作。如果两个对应的位中至少有一个为1，则结果为1，否则为0。

```java
// 1|1=1  0|0=0  1|0=1  0|1=1

int a = 5;  // 二进制: 0101
int b = 3;  // 二进制: 0011
int result = a | b;  // 结果: 0111 (十进制7)
System.out.println(result);  // 输出: 7
```

### 3. 按位异或（`^`）

对两个操作数的每一位进行异或操作。如果两个对应的位不同，则结果为1，否则为0。

```java
// 1^1=0  0^0=0  1^0=1  0^1=1

int a = 5;  // 二进制: 0101
int b = 3;  // 二进制: 0011
int result = a ^ b;  // 结果: 0110 (十进制6)
System.out.println(result);  // 输出: 6
```

### 4. 按位取反（`~`）

对操作数的每一位进行取反操作。即1变为0，0变为1。

```java
int a = 5;  // 二进制: 0101
int result = ~a;  // 结果: 1010 (补码表示，实际值为-6)
System.out.println(result);  // 输出: -6
```

### 5. 左移（`<<`）n* 2^i 

将操作数的二进制位向左移动指定的位数，右边空出的位用0填充。

```java
int a = 5;  // 二进制: 0101
int result = a << 1;  // 结果: 1010 (十进制10)
System.out.println(result);  // 输出: 10
```

### 6. 右移（`>>`）n/2^i 

将操作数的二进制位向右移动指定的位数，左边空出的位用符号位填充（正数用0，负数用1）。

```java
int a = 5;  // 二进制: 0101
int result = a >> 1;  // 结果: 0010 (十进制2)
System.out.println(result);  // 输出: 2
```

### 7. 无符号右移（`>>>`）

将操作数的二进制位向右移动指定的位数，左边空出的位用0填充，不考虑符号位。

```java
int a = -5;  // 二进制: 11111111111111111111111111111011
int result = a >>> 1;  // 结果: 01111111111111111111111111111101 (很大的正数)
System.out.println(result);  // 输出: 2147483645
```

# 控制流程

- for、 while、 if else 、do while
- java不能在嵌套的两个块中声明同名的变量
- 块（复合语句）若干条Java语句组成的语句，并用一对大括号括起来，块确定了变量的作用域

- **for循环（初始化：检测：更新）**

- 当需要对某个表达式的多个值进行检测时，可以使用switch语句
- switch语句，case标签可以是
  - byte、short 、int 、char 、以及它们的包装类
  - 枚举常量
  - 字符串字面量
- switch不允许传入 null

## 中断控制流程(return、continue和break的区别)

- return：直接跳出当前的方法，返回到该调用的方法的语句处，继续执行
- break：在循环体内结束整个循环过程，跳出最近一层循环
  - 带标签的break语句，用于跳出多重嵌套的循环语句
- continue：结束本次的循环，直接进行下一次的循环

# 数组

数组存储**相同类型**的值，数组一旦创建，不能改变长度。

**二维数组，数组的数组。**

存在不规则数组。

数组的 `equals`方法 等同与` ==`

数组排序：`Arrays.sort(arr);` 优化的快速排序方法

数组长度：`arr.length`，无小括号

打印数组信息

- `Arrays.toString();`一维
- `Arrays.deepToString();`二维

## 数组拷贝

普通拷贝：两个变量将引用同一个数组

`Arrays.copyOf()`：两个新数组

```java
int[] a = new int[]{1, 2, 3};
int[] b = a;
int[] c = Arrays.copyOf(a, a.length);
// 数组的 equals方法 等同与 ==
System.out.println(a.equals(b)); // true
System.out.println(a.equals(c)); // false
```
