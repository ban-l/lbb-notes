# 继承

基本思想：基于已有的类创建新的类。

继承已存在的类就是复用（继承）这些类的方法，而且可以增加新的方法和字段，使新类能适应新的情况。

## 类、超类和子类

关键字`extends`表示继承

- 关键字`extends`表示正在构造的新类派生于一个已存在的类，这个已存在的类称为超类、基类或父类，新类称为子类、派生类或者孩子类
- 关键字`super`表示父类，是调用父类方法的特殊关键字
- 在子类中可以增加字段、增加方法或覆盖父类的方法，不允许删除
- 子类构造器不能访问父类的私有字段，需要通过`super`调用父类构造器来**初始化父类私有字段**
- 子类构造器的第一条语句，`super(params)`

## this和super

`this`

- 指示隐式参数的引用
- 调用该类的其它构造器

`super`

- 调用超类的方法
- 调用超类的构造器

## 多态

- 方法多态：同一行为，不同子类对象具有不同的表现形式（同名同参不同类）
- 对象多态：一个对象变量可以指示为多种实际类型
- 静态解析：方法重载（同名同类不同参）
- 动态绑定：在运行时能够自动选择适当的方法（方法重写）

**is-a 规则**

- is-a 规则，它指出子类的每个对象也是超类的对象，反之则不然
- is-a 规则，另一种表述是替换原则，超类对象的任何地方都可以使用子类对象替换

**多态存在的3个条件：继承、重写、父类引用指向子类对象(向上转型)**

## 强制类型转换

向上转型（upcasting）：自动类型转换 

- 父类型 <- 子类型
- `Object o = new Main();`

向下转型（downcasting）：强制类型转换

- 子类型 <- 父类型
- `Main m = (Main) new Object();`

## 方法调用

假设要调用`x.f(args)`

1. 编译器查看**对象声明类型和方法名**
   1. 有可能存在多个名字为 `f`但参数类型不一样的方法，一一列举出来。
2. 编译器要确定方法调用中提供的**参数类型**
   1. 找到名字`f`和参数类型完全匹配的方法，这个过程称为**重载解析（方法重载）** 
3. **静态绑定**：`private`方法、`static`方法、`final`方法、构造器，准确知道调用哪个方法。
4. **动态绑定**：依赖隐式参数，在运行时能够自动选择适当的方法（**方法重写**）
5. 采用动态绑定调用方法时，虚拟机必须调用与`x` 所引用对象的**实际类型对应的那个方法**

### 方法表

- 每次调用方法都要完成这个搜索，时间开销相当大，为了减少开销，虚拟机预先为每个类计算了一个方法表
- 方法表：列出了所有**方法签名（名字，参数列表）**和要**调用的实际方法**
- 子类方法不能低于超类方法的可见性（访问修饰符）

## 抽象类(abstract)

- `abstract`修饰的方法为抽象方法，需要实现
- 包含一个或多个抽象方法的类本身必须被声明为抽象的
- 不含抽象方法，也可以定义为抽象类
- 抽象类不能实例化，只能被继承
- 可以定义一个抽象类的对象变量，引用非抽象子类的对象

## 访问控制修饰符

- private：本类可见
- default：本包可见
- protected：本包和所有子类可见
- public：对外部完全可见

|           | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| --------- | -------- | -------- | ------------ | -------------- |
| private   | ✓        | ×        | ×            | ×              |
| default   | ✓        | ✓        | ×            | ×              |
| protected | ✓        | ✓        | ✓            | ×              |
| public    | ✓        | ✓        | ✓            | ✓              |

# Object 

```java
package java.lang;
public class Object {
    private static native void registerNatives();
  	public final native Class<?> getClass();
    public native int hashCode();
    public boolean equals(Object obj) {}
    protected native Object clone() throws CloneNotSupportedException;
    public String toString() {}
    public final native void notify();
    public final native void notifyAll();
    public final native void wait(long timeout) throws InterruptedException;
    public final void wait(long timeout, int nanos) throws InterruptedException {}
    public final void wait() throws InterruptedException {}
    protected void finalize() throws Throwable {}
}
```

`Object`是所有类的超类

- java中每个类、所有数组类型，都扩展了`Object`类
- `Object`类型的变量可以引用任何类型的对象
- Object类型的变量作为各种值的一个泛型容器

- 基本数据类型不是对象

- `getClass`方法将返回一个对象所属的类 

## 同一性 ==，等同性 equals

同一性：`==`，比较引用是否相等（**存储位置**）

等同性：`equals`

对于基本类型

- `==`判断两个值是否相等
- 基本类型没有`equals`方法

对于引用类型

- `==`判断两个变量是否引用同一个对象（存储位置）
- `equals`判断引用的对象是否等价

## equals方法

```java
public boolean equals(Object obj) {
  return (this == obj);
}
```

`Object`类的`equals`方法：引用是否相等（ 存储位置）

### equals方法特性

1. 自反性：`x.equals(x)`; // true
2. 对称性：`x.equals(y) == y.equals(x)`; // true
3. 传递性：`if(x.equals(y) && y.equals(z))`；`x.equals(z);`// true
4. 一致性：多次调用 `equals()` 方法结果不变，`x.equals(y) == x.equals(y);` // true
5. 任意非空：`x.equals(null)`  // false

### 覆写equals（是否同一引用、类型、对象状态）

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Demo demo = (Demo) o;
    return number == demo.number;
}
```

1. 比较两个对象存储位置是否相等 `==`，即是否同一引用
2. 检测是否为`null`
3. 比较对象所属类是否相等，即是否同一类型
4. 强转
5. **字段比较（比较对象状态**）

### 数组的equals

数组的`equals`方法是基于同一性`==`

```java
// 数组的 equals方法 等同与 ==
int[] a = new int[]{1, 2, 3};
int[] b = new int[]{1, 2, 3};
System.out.println(a.equals(b)); // false
System.out.println(a == b); // false
```

`Arrays.equals`方法：长度相同，对应元素也相同，返回`true`

```java
int[] a = new int[]{1, 2, 3};
int[] b = new int[]{1, 2, 3};
System.out.println(Arrays.equals(a, b)); // true
```

## hashCode方法

散列码（hash code）是由对象导出的一个整数值，无规律

- `Object`类的`hashCode`方法，每个对象都有一个默认的散列码，其值由对象的**存储地址**得出

- `String`类的散列码由**内容**导出

### 覆写/不覆写hashCode方法

- 不覆写`hashCode`方法，其值由对象的存储地址得出

- 覆写`hashCode`方法，`Objects.hash()`方法生成散列码

```java
Demo d1 = new Demo();
Demo d2 = new Demo();
// 不覆写hashCode，不相等
System.out.println(d1.hashCode()); // 1360875712
System.out.println(d2.hashCode()); // 1625635731

// 覆写hashCode，相等
public int hashCode() {
    return Objects.hash(number);
}
Demo d1 = new Demo();
Demo d2 = new Demo();
System.out.println(d1.hashCode()); // 31
System.out.println(d2.hashCode()); // 31
```

## toString方法

```java
// 不覆写toString
Demo d = new Demo();
System.out.println(d.toString());
// org.java.demo.Demo@1f
```

- `toString`默认返回 `org.java.demo.Demo@1f` 这种形式，` @` 后面为**散列码的无符号十六进制**表示。
- 自定义类覆写`toString`方法，按需返回内容。