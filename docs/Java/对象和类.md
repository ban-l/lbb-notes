# 对象和类
# 面向对象程序设计

面向对象程序设计（Object Oriented Programming）

- 面向对象的**程序由对象组成**
- 每个对象包含对用户公开特定功能部分和隐藏实现部分
- 面向对象更适加合解决规模较大的问题

## 类

- 类是构造对象的模板或者蓝图
- **由类构造对象的过程称为创建类的实例**
- **封装**（数据隐藏）
  - 是处理对象的的一个重要概念
  - **将数据和行为组合在一个包中**，并对对象的使用者隐藏具体的实现方式
  - **对象的数据称为实例字段**
    - 设为私有，只能通过访问器方法访问
  - **操作数据的过程称为方法**
- **实现封装**：不能让类中方法直接访问其他类的实例字段，**只能通过对象的方法与对象数据进行交互**
  - 一个私有的数据字段
  - 一个公有的字段访问器方法
  - 一个公有的字段更改器方法

## 对象（行为、状态、标识）

对象的三个主要特性

- 对象的行为：方法（方法可以访问所属类任何对象的私有特性）

- 对象的状态：调用方法时，对象会如何响应（数据/实例字段的状态）
- 对象的标识：如何区分具有相同行为与状态的不同对象

## 类之间的关系

- 依赖（"uses-a"）：一个类的方法使用或者操纵另一个类的的对象
  - 方法参数为其它类对象，要尽可能将相互依赖的类减至最少，减少类之间的耦合
- 聚合（"has-a"）：实例字段为其它类对象，整体不存在了，部分存在
  - 例如：类A的对象包含类B的对象
- 组合（"has-a"）：整体不存在了，部分也不存在了
- 继承（"is-a"）
- UML符号表示类关系

## 对象与对象变量（引用）

- **对象变量 引用 对象**
  - `Date deadLine;` // deadLine没有引用任何对象；
  - `s = deadLine.toString` //会产生编译错误；
  - 定义了一个对象变量`deadLine`，它可以引用Date类型的对象；
  - 变量`deadLine`不是一个对象，它此时没有引用任何对象，所以还不能使用Date方法；
  - 对象变量并没有实际包含一个对象，它只是引用一个对象；
- Java中，任何**对象变量的值**都是对存储在另一个地方的某个**对象的引用**。

- 显式地将对象变量设置为 null ，指示这个对象变量目前没有引用任何对象。
- 所有的Java对象都存储在堆中

## 访问器方法和更改器方法（get、set）

- 更改器方法：修改对象状态的方法
- 访问器方法：只访问对象而不修改对象的方法

# 对象构造

- 重载：同类同名不同参（静态，编译）
- 覆写：同名同参不同类（动态，运行）

- **方法签名：方法名、参数类型**
- 默认字段初始化，若构造器中没有显式地为字段设置初值，则自动赋为默认值：
  - 数值为0
  - 布尔值为`false`
  - 对象引用为`null`
- 字段与局部变量的重要区别：
  - 类中字段自动初始化为默认值
  - 方法中的局部变量必须明确地初始化

- 无参构造器，对象状态为默认值

- `this`指示隐式参数，即所构造的对象

- 静态字段、静态代码块按**声明顺序**执行

## 构造器

- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0、1或者多个参数

- 构造器没有返回值

- 构造器总是伴随着`new`操作符一起调用

## 构造器具体处理步骤

1. 如果构造器第⼀⾏调⽤了第⼆个构造器，则基于所提供的的参数执⾏第⼆个构造器
2. 所有数据域被初始化为默认值（0、`false` 、`null`)
3. 按**声明顺序**依次初始化（初始化语句和初始化块）
   1. 先执⾏静态初始化块
   2. 再执⾏对象初始化块
   3. 静态初始化块只执⾏⼀次，对象初始化块在每次创建对象时均执⾏

4. 执行这个构造器的主体

5. 计算出一个引用值

## 隐式参数和显式参数

```java
Demo demo= new Demo();
demo.test(100);
```

- 隐式参数：方法名前的对象，`demo`
- 显式参数：方法名后面括号中的值，100
- 在每一个方法中，关键字 `this `指示隐式参数

# 内部类

内部类是定义在另一个类中的类，内部类方法可以访问外部类字段。

为什么使用内部类：

- 内部类可以对同⼀个包中的其他类隐藏。
- 内部类⽅法可以访问定义这个类的作⽤域中的数据，包括私有数据。

## 使用内部类访问对象状态

- ⼀个内部类⽅法可以访问⾃⾝的数据字段，也可以访问创建它的外围对象的数据字段，为此，内部类对象总有⼀个隐式引⽤，指向创建它的外部类对象`outer`
- **外围类引用`outer`在构造器中设置**，编译器会修改所有内部类的构造器，添加一个对应外围类引用的参数
- 只有内部类是可以是 `private`
- 常规类只有包可见性(`default`、`protected`) 或 公共可见性(`public`)

## 内部类的特殊语法规则

外围类引用 `OuterClass.this`，如：`Person.this`

内部类对象的构造器

- `outerObject.new InnerClass(construction param)`

外围类的作用域之外引⽤内部类

- `OuterClass.InnerClass` ，比如：`Map.Entry`

内部类中声明的所有**静态字段**都必须是 `final`，并初始化为⼀个编译时常量：`static final`

内部类不能有`static`⽅法(除了访问外围类静态字段和方法的静态方法)

## 内部类与编译器

内部类是一个编译器现象，与虚拟机无关

编译器会将内部类转换为常规类文件，用`$`分隔外部类名和内部类名

## 局部内部类(方法中)

- **当这个类对象只被一个方法法创建一次时**，在一个方法中的局部地定义这个类
- 不能有访问说明符，局部类的作用域被限定在声明这个局部类的块中 
- 对外部完全隐藏
- 局部类可以访问外部类变量
- 与其他内部类相比较，局部类可以访问方法中的局部变量(`final`变量 )

```java
public class InnerClassDemo {
    String name;
    public InnerClassDemo(String name) {
        this.name = name;
    }

    public void method() {
        class InnerClassTest2 { // 局部内部类,当这个类的对象只被⼀个⽅法创建⼀次时
            int high;
            public void test2() {
                System.out.println(InnerClassDemo.this.name); // 外围类引用 OuterClass.this
                System.out.println(high);
            }
        }
        // 只创建一次
        InnerClassTest2 test2 = new InnerClassTest2();
        test2.test2();
    }

    public static void main(String[] args) {
        InnerClassDemo demo = new InnerClassDemo("hi");
        InnerClassTest test = demo.new InnerClassTest(); // 内部类对象的构造器 
        test.test();
        demo.method(); // 方法中有局部内部类

    }

    class InnerClassTest { // 内部类
        int age;
        void test() {
            System.out.println(InnerClassDemo.this.name); // 外围类引用 OuterClass.this
            System.out.println(age);
        }
    }
}

```

## 匿名内部类

只创建这个类的一个对象，不需要为类指定名字

- `new superType(construcrion param) {...} `
  - `superType`可以是接口，内部类要**实现**这个接口
  - `superType`可以是类，内部类要**扩展**这个类

构造器名字必须与类名相同

  - 匿名内部类没有类名，所以**匿名内部类不能有构造器**
  - 若`superType`是类，构造参数要传递给超类(`superType`)的构造器。
  - 若`superType`是接口，不能有任何构造参数，不过仍然要小括号` ()`
  - 尽管匿名内部类不能有构造器，但可以提供一个对象初始化块
    - `new Person("asd") { {init} ....}`

**定义匿名内部类**：构造参数列表的结束小括号` ()` 后跟一个开始⼤括号 `{}`

- `new Person(...) {....}`

静态方法中要得到当前类名，不能使用`this`，静态方法没有`this`，可以使用如下技巧

- `new Object(){}.getClass().getEnclosingClass()`
- 创建了一个匿名内部类，`getEnclosingClass`得到他的外围类

## 双括号初始化

利用内部类语法，使用匿名列表。

```java
List<String> list = new ArrayList<String>() {{
    add("hello");
    add("world");
}};
```

- 外层括号`{}`建立了`ArrayList`的一个匿名⼦类
- 内层括号`{}`则是一个对象初始化块
- 适用于这些数组列表不需要再使用的情况 
- `Map`，`Deque`，`Set`等集合也有类似技巧

## 静态内部类(static声明的类 ，不需要访问外围类对象)

- 不需要外部类引用，声明内部类为`static`，不会生成它外围类对象的引用`outer`
- **只要内部类不需要访问外围类对象，就应该使⽤静态内部类** 
- 与常规内部类不同，静态内部类可以有静态字段和⽅法 
- **接口中声明的内部类**⾃动是`public` 和 `static `

# final

- `final`修饰实例字段，构造对象时**必须初始化**，不可修改，即没有`set`方法
- `final`修饰对象引用，**不会再引用别的对象**

- `final`指示常量，**只赋值一次**且不能再次修改，常量名全大写
- `final`修饰方法，**子类不允许覆盖**

- `final`修饰类，**不允许被扩展**（不能被继承），方法自动为final方法

# static

- 静态字段：属于类，不属于任何对象
  - 一个字段定义为static，每个类只有一个这样的字段
  - 类所有的实例都共享静态字段
  - 非静态的实例字段，每个对象都有自己的一个副本(对象的状态)
- 静态常量：`public static final` 修饰，常量名全大写
  
- 静态方法：不在对象上执行的方法
  - `Math.pow(x,a)`，x的a次幂
  - 没有`this`、`super`参数的方法(可通过匿名内部类得到外围类)
- 使用静态方法的两种情况
  - 方法不需要访问对象状态
  - 方法只需要访问类的静态字段
- 工厂方法：静态工厂方法构造对象
- `main`方法：每个类只有一个man方法
- 静态语句块：静态语句块在类初始化时运行一次。

## 初始化数据域的⽅法

1. 在构造器中设置值
2. 在声明中赋值(普通字段、静态字段)
3. 初始化块(普通块、静态块)

## 初始化顺序

存在继承的情况下，初始化顺序为：

1. 父类（静态字段、静态语句块）
2. 子类（静态字段、静态语句块）
3. 父类（实例字段、普通语句块）
4. **父类（构造函数）**
5. 子类（实例字段、普通语句块）
6. **子类（构造函数）**

# 方法参数（按值调用）

- 按值调用：方法接收是调用者**传递的值**
  - 方法不能修改按值传递的变量值

- 按引用调用：方法接收的是调用者**传递的变量地址**
  - 方法可以修改按引用传递的变量值

- **Java总是采用按值调用，方法得到的所有参数值都是副本**
  - 具体来说，方法不能修改传递给它的任何参数变量的内容(**变量地址不会变**)
  - 基本数据类型——值副本
  - 对象引用——引用副本，对象引用按值传递（也是一种值）

## 总结

- 方法不能修改基本数据类型的参数（即数值型和布尔型）
- 方法可以改变对象的状态
- 方法不能让一个对象参数引用一个新的对象

# 包

- 放在第1条语句
- 使用包主要原因是确保类名的唯一性
- 用因特网域名以逆序的形式作为包名
- 一个类可以使用所属包的所有类，以及其他包中的公共类
- 两种方式访问另一个包中的公共类：完全限定名、`import`语句
- `import`语句允许导入静态方法和静态字段，不仅仅是类
- 若是没有访问修饰符（`default `），类、方法、变量可以被同一个包中的所以方法访问

# JAR文件

- JAVA归档文件
- 包含类文件，也可以包含图像，声音等其他类型的文件
- ZIP压缩格式
- 创建JAR文件：Jar cvf….
  
- 包含一个清单文件，用于描述归档文件的特殊特性：清单文件被命名为`MANIFEST.MF`

# 类设计技巧

1. 一定要保证数据**私有**
2. 一定要对数据进行**初始化**

1. 不要在类中使用过多的基本类型：用其它的类替换使用多个相关的基本类型
   
1. 不是所有的字段都需要单独的字段访问器和字段更改器

1. 分解有过多职责的类

1. 类名和方法名要能体现它们的职责(**见名知意**)

7. **优先使用不可变的类**：若类不可变，可以安全地在多个线程间共享