# 面向对象程序设计

面向对象程序设计（Object Oriented Programming）

- 面向对象的**程序由对象组成**
- 每个对象包含对用户公开特定功能部分和隐藏实现部分
- 面向对象更适加合解决规模较大的问题

## 类

- 类是构造对象的模板或者蓝图
- **由类构造对象的过程称为创建类的实例**
- **封装**（数据隐藏）
  - 是处理对象的的一个重要概念
  - **将数据和行为组合在一个包中**，并对对象的使用者隐藏具体的实现方式
  - **对象的数据称为实例字段**
    - 设为私有，只能通过访问器方法访问
  - **操作数据的过程称为方法**
- **实现封装**：不能让类中方法直接访问其他类的实例字段，**只能通过对象的方法与对象数据进行交互**
  - 一个私有的数据字段
  - 一个公有的字段访问器方法
  - 一个公有的字段更改器方法

## 对象（行为、状态、标识）

对象的三个主要特性

- 对象的行为：方法（方法可以访问所属类任何对象的私有特性）

- 对象的状态：调用方法时，对象会如何响应（数据/实例字段的状态）
- 对象的标识：如何区分具有相同行为与状态的不同对象

## 类之间的关系

- 依赖（"uses-a"）：一个类的方法使用或者操纵另一个类的的对象
  - 方法参数为其它类对象，要尽可能将相互依赖的类减至最少，减少类之间的耦合
- 聚合（"has-a"）：实例字段为其它类对象，整体不存在了，部分存在
  - 例如：类A的对象包含类B的对象
- 组合（"has-a"）：整体不存在了，部分也不存在了
- 继承（"is-a"）
- UML符号表示类关系

## 对象与对象变量（引用）

- **对象变量 引用 对象**
  - `Date deadLine;` // deadLine没有引用任何对象；
  - `s = deadLine.toString` //会产生编译错误；
  - 定义了一个对象变量`deadLine`，它可以引用Date类型的对象；
  - 变量`deadLine`不是一个对象，它此时没有引用任何对象，所以还不能使用Date方法；
  - 对象变量并没有实际包含一个对象，它只是引用一个对象；
- Java中，任何**对象变量的值**都是对存储在另一个地方的某个**对象的引用**。

- 显式地将对象变量设置为 null ，指示这个对象变量目前没有引用任何对象。
- 所有的Java对象都存储在堆中

## 访问器方法和更改器方法（get、set）

- 更改器方法：修改对象状态的方法
- 访问器方法：只访问对象而不修改对象的方法

# 对象构造

- 重载：同类同名不同参（静态，编译）
- 覆写：同名同参不同类（动态，运行）

- **方法签名：方法名、参数类型**
- 默认字段初始化，若构造器中没有显式地为字段设置初值，则自动赋为默认值：
  - 数值为0
  - 布尔值为`false`
  - 对象引用为`null`
- 字段与局部变量的重要区别：
  - 类中字段自动初始化为默认值
  - 方法中的局部变量必须明确地初始化

- 无参构造器，对象状态为默认值

- `this`指示隐式参数，即所构造的对象

- 静态字段、静态代码块按**声明顺序**执行

## 构造器

- 构造器与类同名
- 每个类可以有一个以上的构造器
- 构造器可以有0、1或者多个参数

- 构造器没有返回值

- 构造器总是伴随着`new`操作符一起调用

## 构造器具体处理步骤

1. 如果构造器第⼀⾏调⽤了第⼆个构造器，则基于所提供的的参数执⾏第⼆个构造器
2. 所有数据域被初始化为默认值（0、`false` 、`null`)
3. 按**声明顺序**依次初始化（初始化语句和初始化块）
   1. 先执⾏静态初始化块
   2. 再执⾏对象初始化块
   3. 静态初始化块只执⾏⼀次，对象初始化块在每次创建对象时均执⾏

4. 执行这个构造器的主体

5. 计算出一个引用值

## 隐式参数和显式参数

```java
Demo demo= new Demo();
demo.test(100);
```

- 隐式参数：方法名前的对象，`demo`
- 显式参数：方法名后面括号中的值，100
- 在每一个方法中，关键字 `this `指示隐式参数

# 内部类

内部类是定义在另一个类中的类，内部类方法可以访问外部类字段。

为什么使用内部类：

- 内部类可以对同⼀个包中的其他类隐藏。
- 内部类⽅法可以访问定义这个类的作⽤域中的数据，包括私有数据。

## 使用内部类访问对象状态

- ⼀个内部类⽅法可以访问⾃⾝的数据字段，也可以访问创建它的外围对象的数据字段，为此，内部类对象总有⼀个隐式引⽤，指向创建它的外部类对象`outer`
- **外围类引用`outer`在构造器中设置**，编译器会修改所有内部类的构造器，添加一个对应外围类引用的参数
- 只有内部类是可以是 `private`
- 常规类只有包可见性(`default`、`protected`) 或 公共可见性(`public`)

## 内部类的特殊语法规则

外围类引用 `OuterClass.this`，如：`Person.this`

内部类对象的构造器

- `outerObject.new InnerClass(construction param)`

外围类的作用域之外引⽤内部类

- `OuterClass.InnerClass` ，比如：`Map.Entry`

内部类中声明的所有**静态字段**都必须是 `final`，并初始化为⼀个编译时常量：`static final`

内部类不能有`static`⽅法(除了访问外围类静态字段和方法的静态方法)

## 内部类与编译器

内部类是一个编译器现象，与虚拟机无关

编译器会将内部类转换为常规类文件，用`$`分隔外部类名和内部类名

## 局部内部类(方法中)

- **当这个类对象只被一个方法法创建一次时**，在一个方法中的局部地定义这个类
- 不能有访问说明符，局部类的作用域被限定在声明这个局部类的块中 
- 对外部完全隐藏
- 局部类可以访问外部类变量
- 与其他内部类相比较，局部类可以访问方法中的局部变量(`final`变量 )

```java
public class InnerClassDemo {
    String name;
    public InnerClassDemo(String name) {
        this.name = name;
    }

    public void method() {
        class InnerClassTest2 { // 局部内部类,当这个类的对象只被⼀个⽅法创建⼀次时
            int high;
            public void test2() {
                System.out.println(InnerClassDemo.this.name); // 外围类引用 OuterClass.this
                System.out.println(high);
            }
        }
        // 只创建一次
        InnerClassTest2 test2 = new InnerClassTest2();
        test2.test2();
    }

    public static void main(String[] args) {
        InnerClassDemo demo = new InnerClassDemo("hi");
        InnerClassTest test = demo.new InnerClassTest(); // 内部类对象的构造器 
        test.test();
        demo.method(); // 方法中有局部内部类

    }

    class InnerClassTest { // 内部类
        int age;
        void test() {
            System.out.println(InnerClassDemo.this.name); // 外围类引用 OuterClass.this
            System.out.println(age);
        }
    }
}

```

## 匿名内部类

只创建这个类的一个对象，不需要为类指定名字

- `new superType(construcrion param) {...} `
  - `superType`可以是接口，内部类要实现这个接口
  - `superType`可以是类，内部类就要扩展这个类

构造器名字必须与类名相同
  - 匿名内部类没有类名，所以匿名内部类不能有构造器
  - 若`superType`是类，构造参数要传递给超类的构造器。
  - 若`superType`是接口，就不能有任何构造参数，不过仍然要小括号` ()`
  - 尽管匿名内部类不能有构造器，但可以提供一个对象初始化块
    - `new Person("asd") { {init} ....}`

如果构造参数列表的结束小括号` ()` 后面跟一个开始⼤括号 `{}`，就是在定义匿名内部类

静态方法中要得到当前类名，不能使用`this`，静态方法没有`this`，可以使用如下技巧
- `new Object(){}.getClass().getEnclosingClass()`
- 创建了一个匿名内部类，`getEnclosingClass`得到他的外围类

## 双括号初始化

利用内部类语法，使用匿名列表

```java
List<String> list = new ArrayList<String>() {{
    add("hello");
    add("world");
}};
```

- 外层括号建立了`ArrayList`的一个匿名⼦类
- 内层括号则是一个对象初始化块
- 适用于这些数组列表不需要再使用的情况 
- `Map`，`Deque`，`Set`等集合也有类似技巧