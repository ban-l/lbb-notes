# Mybatis 缓存

MyBatis一级缓存和二级缓存的主要目的是减少数据库查询次数，提升系统性能，但作用域和生命周期完全不同。

---

## 一、一级缓存：本地会话缓存

**1. 定义与作用域**
*   **作用域**： **SqlSession级别**。在同一个`SqlSession`中执行多次相同的查询，MyBatis会默认提供一级缓存来避免重复访问数据库。
*   **生命周期**： 与`SqlSession`共存亡。当`SqlSession`被`close()`、`commit()`、`rollback()`或执行了**增、删、改**操作（即使修改的不是当前缓存的数据）后，该`SqlSession`中的所有一级缓存都会被清空。

**2. 工作流程**
1.  第一次查询ID为1的用户：`select * from user where id = 1`
    *   先去缓存（一个类似`HashMap`的结构）中查找，key由`statementId`、SQL、参数值、分页信息等构成。
    *   未命中，查询数据库，并将结果存入缓存。
2.  在同一个`SqlSession`中，再次执行**完全相同**的查询。
    *   缓存命中，直接返回缓存中的对象（**注意：是同一个对象引用**）。
3.  执行`update user set name = 'xxx' where id = 2`。
    *   **清空**当前`SqlSession`的一级缓存。
4.  再次查询ID为1的用户。
    *   缓存已无，重新查询数据库。

**3. 核心特点**
*   **默认开启**，无法关闭。
*   **本地性**： 它存在于`SqlSession`内部，不同的`SqlSession`之间的缓存完全隔离。
*   **快照机制**： 一级缓存存储的是对象的**引用**。如果程序修改了从缓存中取出的对象，后续再取出时，拿到的是被修改过的对象（可能会产生意想不到的副作用，需注意）。
*   **清空触发**： `commit()`, `rollback()`, `update/insert/delete`操作都会清空缓存。

---

## 二、二级缓存：全局命名空间缓存

**1. 定义与作用域**
*   **作用域**： **Mapper（Namespace）级别**，也可以跨`SqlSession`。多个`SqlSession`操作同一个Mapper的SQL，可以共享其二级缓存。
*   **生命周期**： 与应用生命周期同步。只有当应用重启或手动清空时，缓存才会被销毁。

**2. 开启与配置**
二级缓存**默认是关闭的**，需要手动开启。

**步骤1：全局开关（mybatis-config.xml）** - 通常默认就是`true`，可以省略。
```xml
<settings>
    <setting name="cacheEnabled" value="true"/>
</settings>
```

**步骤2：在具体的Mapper XML文件中声明**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.dao.UserMapper">
    <!-- 启用该Mapper的二级缓存 -->
    <cache/>
    <!-- 或者使用自定义配置 -->
    <!--
    <cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/>
    -->
    <select id="selectById" resultType="User">
        select * from user where id = #{id}
    </select>
</mapper>
```
**步骤3：实体类实现Serializable接口**
因为二级缓存的数据可能会被序列化后存储到磁盘或传输，所以对应的实体类必须实现`Serializable`接口。

**3. 工作流程**
1.  `SqlSession1`查询ID为1的用户，查询完成后**必须关闭`SqlSession1`**（或执行`commit()`），查询结果才会被提交到二级缓存中。
2.  `SqlSession2`查询ID为1的用户。
    *   先去二级缓存（UserMapper命名空间下）查找。
    *   命中，直接返回数据。`SqlSession1`和`SqlSession2`获取的**不是同一个对象实例**（除非设置`readOnly=true`），因为二级缓存存储的是数据的序列化形式，取出时会反序列化生成新对象。

**4. 核心特点**
*   **需要显式开启**。
*   **跨SqlSession共享**： 这是与一级缓存最本质的区别。
*   **缓存策略可配置**：
    *   `eviction`： 清除策略，如`LRU`（最近最少使用）、`FIFO`（先进先出）等。
    *   `flushInterval`： 刷新间隔（毫秒）。
    *   `size`： 缓存最多可以存储的对象个数。
    *   `readOnly`： 是否只读。为`true`时，返回的是缓存对象的引用（性能高，但不安全）；为`false`时，会通过序列化反序列化返回拷贝（安全，性能稍低）。
*   **清空触发**： 执行了该Mapper下的`insert`, `update`, `delete`操作后，该命名空间的二级缓存会被清空。也可以手动调用`sqlSession.clearCache()`来清空。

---

## 三、对比总结与注意事项

| 特性         | 一级缓存                               | 二级缓存                                  |
| :----------- | :------------------------------------- | :---------------------------------------- |
| **作用域**   | `SqlSession` 内部                      | `Mapper` (Namespace) 级别，跨`SqlSession` |
| **默认状态** | **开启**，且无法关闭                   | **关闭**，需手动配置                      |
| **生命周期** | 随`SqlSession`创建和关闭               | 随应用程序生命周期                        |
| **共享性**   | 不能共享，完全隔离                     | 可以被多个`SqlSession`共享                |
| **存储结构** | 存储对象引用（内存）                   | 存储序列化后的数据（可到磁盘）            |
| **清空条件** | `commit()`, `rollback()`, `增删改`操作 | 同命名空间下的`增删改`操作，或配置过期    |

**重要注意事项：**
1.  **脏读问题**： 在分布式或读写分离环境中，二级缓存可能导致脏数据。例如，另一个应用直接更新了数据库，MyBatis应用无法感知，仍然从缓存中读取旧数据。因此，**在更新频繁、对实时性要求高的场景下，慎用二级缓存**。
2.  **事务提交**：
    1.   一级缓存的数据在`SqlSession`提交或关闭时才会被**清除**；
    2.  二级缓存的数据在`SqlSession`关闭或提交时才会被**写入**。

3.  **使用建议**：
    *   一级缓存是“免费的”，无需关注，但要知道其存在和清空时机。
    *   二级缓存是一把“双刃剑”。对于**读远多于写、数据实时性要求不高、数据量不大**的场景（如字典表、配置表），可以考虑使用。对于电商商品、订单等高频变动的数据，通常建议使用更专业的集中式缓存（如Redis）来替代MyBatis的二级缓存。
