# #{}和${}区别

## 核心区别总结

| 特性            | `#{}`                                              | `${}`                                           |
| :-------------- | :------------------------------------------------- | :---------------------------------------------- |
| **本质**        | **参数占位符**                                     | **字符串替换/拼接**                             |
| **处理方式**    | MyBatis 会创建 `PreparedStatement`，使用 `?` 占位  | MyBatis 会直接替换为变量的值（字符串）          |
| **SQL 类型**    | 预编译 SQL（安全）                                 | 静态 SQL 字符串拼接（不安全）                   |
| **防 SQL 注入** | **✅ 天然防止**（参数化查询）                       | **❌ 无法防止**（直接拼接）                      |
| **参数处理**    | 自动进行类型转换（TypeHandler）                    | 原样替换，不做类型处理                          |
| **使用场景**    | **绝大部分情况**，尤其是 **WHERE 条件、VALUES 值** | **动态表名、列名、ORDER BY 排序字段**等非值位置 |
| **示例**        | `SELECT * FROM user WHERE id = #{id}`              | `ORDER BY ${orderByColumn}`                     |

---

## 详细解析

### 1. `#{}` - 安全优先的预编译占位符

**工作原理：**
- MyBatis 在解析 SQL 时，会将 `#{}` 替换为 `?` 占位符。
- 执行时，通过 `PreparedStatement` 的 `setXxx()` 方法安全地设置参数值。
- 会对传入值进行适当的转义和处理。

**示例：**
```xml
<select id="findUser" resultType="User">
    SELECT * FROM user 
    WHERE name = #{name} AND age = #{age}
</select>
```
**最终执行的 SQL：**
```sql
-- 数据库收到的预编译SQL模板
SELECT * FROM user WHERE name = ? AND age = ?

-- 参数值被安全地设置（假设name="Alice", age=25）
-- 实际执行时：PreparedStatement.setString(1, "Alice"); setInt(2, 25);
```

**优点：**
- **绝对安全**：防止 SQL 注入攻击
- **性能优化**：数据库可以缓存预编译的 SQL 执行计划
- **类型安全**：自动处理类型转换（字符串加引号、日期格式化等）
- **代码清晰**：参数与 SQL 逻辑分离

---

### 2. `${}` - 灵活但危险的字符串替换

**工作原理：**
- MyBatis 在解析 SQL 时，会直接将 `${}` 中的**内容替换为对应的变量值**（字符串形式）。
- 不做任何转义或类型处理，是纯粹的**文本替换**。

**示例：**
```xml
<select id="findUser" resultType="User">
    SELECT * FROM user 
    WHERE name = '${name}' 
    ORDER BY ${orderBy}
</select>
```
如果传入参数：`name = "Alice' OR '1'='1"`, `orderBy = "id DESC"`
**最终执行的 SQL：**
```sql
SELECT * FROM user 
WHERE name = 'Alice' OR '1'='1' 
ORDER BY id DESC
```
**⚠️ 看到了吗？这导致了 SQL 注入！**

---

## 关键对比场景

### 场景1：WHERE 条件中的值（必须用 `#{}`）
```xml
<!-- 安全 ✅ -->
<select id="findByCondition" resultType="User">
    SELECT * FROM user 
    WHERE username = #{username} 
    AND status = #{status}
</select>

<!-- 危险 ❌ 有SQL注入风险 -->
<select id="findByConditionUnsafe" resultType="User">
    SELECT * FROM user 
    WHERE username = '${username}' 
    AND status = ${status}
</select>
```

### 场景2：动态表名/列名（只能用 `${}`）
```xml
<!-- 必须用 ${}，因为表名/列名不能是预编译参数 -->
<select id="findFromTable" resultType="map">
    SELECT * FROM ${tableName}
    WHERE ${columnName} = #{value}
    ORDER BY ${orderBy}
</select>
```

### 场景3：ORDER BY 排序（建议的处理方式）
```xml
<!-- 方式1：直接使用 ${}（有风险） -->
<select id="findUsers" resultType="User">
    SELECT * FROM users
    ORDER BY ${orderBy}
</select>

<!-- 方式2：更安全的动态ORDER BY（推荐） -->
<select id="findUsersSafe" resultType="User">
    SELECT * FROM users
    ORDER BY
    <choose>
        <when test="orderBy == 'name'">name</when>
        <when test="orderBy == 'age'">age</when>
        <when test="orderBy == 'createTime'">create_time</when>
        <otherwise>id</otherwise>
    </choose>
    <choose>
        <when test="orderDirection == 'desc'">DESC</when>
        <otherwise>ASC</otherwise>
    </choose>
</select>

<!-- 方式3：白名单校验（最安全） -->
<select id="findUsersWhiteList" resultType="User">
    SELECT * FROM users
    <if test="orderBy != null and orderBy != ''">
        <!-- 使用${}但通过白名单控制 -->
        ORDER BY 
        <choose>
            <when test="@com.example.util.SqlInjectionChecker@isSafeColumn(orderBy)">
                ${orderBy}
            </when>
            <otherwise>id</otherwise>
        </choose>
        ${orderDirection}
    </if>
</select>
```

## 常见问题与陷阱

### 1. 为什么 `${}` 在 ORDER BY 中有风险？
如果前端传入：
```java
Map<String, Object> params = new HashMap<>();
params.put("orderBy", "id; DROP TABLE users; --");
```
生成的 SQL 将是：
```sql
SELECT * FROM users ORDER BY id; DROP TABLE users; --
```
这会导致删除表！

### 2. LIKE 查询的正确用法
```xml
<!-- 错误 ❌ -->
<select id="findLike" resultType="User">
    SELECT * FROM user WHERE name LIKE '%${name}%'
</select>

<!-- 正确 ✅ 使用 #{} 配合 CONCAT -->
<select id="findLike" resultType="User">
    SELECT * FROM user WHERE name LIKE CONCAT('%', #{name}, '%')
</select>

<!-- 正确 ✅ 使用 #{} 配合 bind（推荐） -->
<select id="findLike" resultType="User">
    <bind name="pattern" value="'%' + name + '%'" />
    SELECT * FROM user WHERE name LIKE #{pattern}
</select>
```

### 3. IN 查询的陷阱
```xml
<!-- 错误 ❌ 这样会报错 -->
<select id="findInIds" resultType="User">
    SELECT * FROM user WHERE id IN (#{ids})
</select>
<!-- 传入 List<Integer> ids = Arrays.asList(1,2,3) -->
<!-- 生成：WHERE id IN (?) -> 参数被当作一个字符串处理 -->

<!-- 正确 ✅ 使用动态SQL的foreach -->
<select id="findInIds" resultType="User">
    SELECT * FROM user 
    WHERE id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}  <!-- 这里必须用 #{} -->
    </foreach>
</select>
```

## 最佳实践总结

1. **默认使用 `#{}`**：99% 的情况下都应该使用 `#{}`，尤其是在值的位置。
2. **谨慎使用 `${}`**：仅在**表名、列名、ORDER BY 字段**等 SQL 关键字位置使用，且必须对输入进行**白名单校验**。
3. **永远不要用 `${}` 处理用户输入的值**：这是 SQL 注入的根源。
4. **动态 SQL 优先**：对于 ORDER BY、动态表名等需求，优先考虑使用 MyBatis 的动态 SQL 标签（`<choose>`、`<if>`）来避免直接使用 `${}`。
5. **进行安全检查**：如果必须使用 `${}`，在业务层或拦截器中对传入参数进行白名单验证。

记住这个简单规则：**如果它是"值"（value），用`#{}`；如果它是"名字"（name），用`${}`但要小心验证。**