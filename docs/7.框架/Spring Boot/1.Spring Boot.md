# Spring Boot

Spring Boot 是 **Spring 生态系统的革命性框架**，它彻底改变了 Java 企业级应用的开发方式。

## 一、Spring Boot 核心理念

### 1.1 什么是 Spring Boot？
Spring Boot 是一个**约定优于配置**的框架，旨在简化 Spring 应用的**初始搭建**和**开发过程**。它并不是 Spring 的替代品，而是 Spring 的**增强工具**。

```java
// 传统 Spring MVC 应用 vs Spring Boot 应用

// 传统 Spring（繁琐配置）
┌─────────────────────────────────────────┐
│ web.xml                                │
│   - DispatcherServlet 配置              │
│   - ContextLoaderListener 配置         │
│                                         │
│ applicationContext.xml                  │
│   - 组件扫描配置                        │
│   - 数据源配置                         │
│   - 事务管理器配置                      │
│                                         │
│ spring-mvc.xml                          │
│   - 视图解析器配置                      │
│   - 静态资源配置                       │
│   - 消息转换器配置                      │
│                                         │
│ pom.xml (大量依赖)                       │
│   - spring-core, spring-web, spring-mvc │
│   - jackson, logging, etc.             │
└─────────────────────────────────────────┘

// Spring Boot（极简配置）
┌─────────────────────────────────────────┐
│ Application.java                        │
│   @SpringBootApplication                │
│   public static void main() {           │
│     SpringApplication.run(...);         │
│   }                                     │
│                                         │
│ application.properties                  │
│   server.port=8080                      │
│   spring.datasource.url=jdbc:mysql://...│
│                                         │
│ pom.xml (少量依赖)                       │
│   spring-boot-starter-web               │
│   spring-boot-starter-data-jpa          │
└─────────────────────────────────────────┘
```

### 1.2 Spring Boot 的设计目标
- **快速创建独立运行的 Spring 应用**
- **提供各种 starter 简化依赖管理**
- **自动配置 Spring 和第三方库**
- **无需 XML 配置（零配置或基于 Java 的配置）**
- **提供生产级特性（监控、健康检查、外部化配置）**
- **无需部署到外部服务器（内嵌 Servlet 容器）**

## 二、Spring Boot 核心特性

### 2.1 自动配置（Auto-Configuration）
```java
// Spring Boot 自动配置原理
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

// @SpringBootApplication 由三个注解组成：
// 1. @SpringBootConfiguration：标记为配置类
// 2. @EnableAutoConfiguration：启用自动配置
// 3. @ComponentScan：自动扫描组件

// 自动配置的工作流程：
// 1. 扫描 classpath 下的 META-INF/spring.factories 文件
// 2. 加载所有 AutoConfiguration 类
// 3. 根据条件注解 (@Conditional) 决定是否生效
// 4. 创建并配置相应的 Bean

// 示例：DataSourceAutoConfiguration
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })  // 条件1：类路径存在
@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")    // 条件2：不存在指定Bean
@EnableConfigurationProperties(DataSourceProperties.class)            // 条件3：属性配置
@Import({ DataSourcePoolMetadataProvidersConfiguration.class, 
          DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {
    
    @Configuration(proxyBeanMethods = false)
    @Conditional(EmbeddedDatabaseCondition.class)      // 嵌入式数据库条件
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import(EmbeddedDataSourceConfiguration.class)
    protected static class EmbeddedDatabaseConfiguration {
    }
    
    @Configuration(proxyBeanMethods = false)
    @Conditional(PooledDataSourceCondition.class)       // 连接池条件
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import({ DataSourceConfiguration.Hikari.class,     // 默认使用 HikariCP
              DataSourceConfiguration.Tomcat.class,
              DataSourceConfiguration.Dbcp2.class,
              DataSourceConfiguration.Generic.class })
    protected static class PooledDataSourceConfiguration {
    }
}
```

### 2.2 Starter 依赖
```xml
<!-- 传统 Spring 依赖管理 -->
<dependencies>
    <!-- Web -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-web</artifactId>
        <version>5.3.23</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.3.23</version>
    </dependency>
    
    <!-- JSON -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.13.4</version>
    </dependency>
    
    <!-- 日志 -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>1.7.36</version>
    </dependency>
    
    <!-- 内嵌容器 -->
    <dependency>
        <groupId>org.apache.tomcat.embed</groupId>
        <artifactId>tomcat-embed-core</artifactId>
        <version>9.0.65</version>
    </dependency>
</dependencies>

<!-- Spring Boot Starter 方式 -->
<dependencies>
    <!-- 一个 starter 包含所有相关依赖 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>

<!-- spring-boot-starter-web 内部结构 -->
spring-boot-starter-web
├── spring-boot-starter (基础starter)
├── spring-boot-starter-json (JSON处理)
├── spring-boot-starter-tomcat (内嵌Tomcat)
└── spring-webmvc (Spring MVC)
```

### 2.3 内嵌 Servlet 容器
```java
// Spring Boot 支持多种内嵌容器
// 1. Tomcat (默认)
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
        // 自动启动内嵌 Tomcat
    }
}

// 2. 切换为 Jetty
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>

// 3. 切换为 Undertow
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-undertow</artifactId>
</dependency>

// 容器配置示例
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        
        // 自定义容器配置
        app.setDefaultProperties(Collections.singletonMap(
            "server.port", "8081"
        ));
        
        app.run(args);
    }
}

// application.properties 配置
server.port=8080                    # 端口
server.servlet.context-path=/api    # 上下文路径
server.tomcat.max-threads=200       # Tomcat最大线程数
server.tomcat.connection-timeout=5000 # 连接超时
server.compression.enabled=true     # 启用压缩
```

### 2.4 外部化配置
```properties
# 1. 配置优先级（从高到低）
# 命令行参数 (--server.port=9000)
# Java系统属性 (-Dserver.port=9000)
# 操作系统环境变量
# 当前目录的 /config/ 子目录
# 当前目录
# classpath 的 /config/ 包
# classpath 根目录

# 2. 多配置文件支持
# application.properties (主配置)
# application-dev.properties (开发环境)
# application-prod.properties (生产环境)
# application-test.properties (测试环境)

# 3. YAML 配置（支持层次结构）
server:
  port: 8080
  servlet:
    context-path: /api
    
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 123456
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    
logging:
  level:
    com.example: DEBUG
    org.springframework.web: INFO
```

## 三、Spring Boot 应用结构

### 3.1 标准项目结构
```
my-spring-boot-app/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── app/
│   │   │               ├── Application.java          # 主启动类
│   │   │               ├── config/                   # 配置类
│   │   │               │   ├── WebConfig.java
│   │   │               │   ├── SecurityConfig.java
│   │   │               │   └── SwaggerConfig.java
│   │   │               ├── controller/               # 控制器
│   │   │               │   ├── UserController.java
│   │   │               │   └── ProductController.java
│   │   │               ├── service/                  # 服务层
│   │   │               │   ├── UserService.java
│   │   │               │   └── impl/
│   │   │               ├── repository/               # 数据访问层
│   │   │               │   ├── UserRepository.java
│   │   │               │   └── ProductRepository.java
│   │   │               ├── entity/                   # 实体类
│   │   │               │   ├── User.java
│   │   │               │   └── Product.java
│   │   │               └── dto/                      # 数据传输对象
│   │   │                   ├── UserDTO.java
│   │   │                   └── ApiResponse.java
│   │   └── resources/
│   │       ├── static/                              # 静态资源
│   │       │   ├── css/
│   │       │   ├── js/
│   │       │   └── images/
│   │       ├── templates/                           # 模板文件
│   │       │   ├── index.html
│   │       │   └── error/
│   │       ├── application.properties              # 配置文件
│   │       ├── application-dev.properties
│   │       ├── application-prod.properties
│   │       └── banner.txt                          # 启动横幅
│   └── test/                                       # 测试代码
│       └── java/com/example/app/
├── target/                                         # 编译输出
├── pom.xml                                         # Maven配置
└── README.md
```

### 3.2 主启动类详解
```java
// Application.java - Spring Boot 应用入口
@SpringBootApplication  // 核心注解：开启自动配置、组件扫描等
public class Application {
    
    /**
     * 主方法 - 应用启动入口
     * Spring Boot 应用打包为可执行 JAR，包含内嵌容器
     */
    public static void main(String[] args) {
        // 方式1：最简单的启动方式
        // SpringApplication.run(Application.class, args);
        
        // 方式2：自定义启动配置
        SpringApplication app = new SpringApplication(Application.class);
        
        // 设置启动参数
        app.setBannerMode(Banner.Mode.CONSOLE);  // 控制台显示banner
        app.setLogStartupInfo(true);             // 记录启动信息
        app.setAddCommandLineProperties(true);   // 启用命令行参数
        
        // 注册监听器
        app.addListeners(new ApplicationStartingListener());
        
        // 运行应用
        ConfigurableApplicationContext context = app.run(args);
        
        // 获取Bean示例
        MyService service = context.getBean(MyService.class);
        service.doSomething();
        
        // 优雅关闭
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.out.println("应用正在关闭...");
            context.close();
        }));
    }
    
    // 自定义Bean配置
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
            .setConnectTimeout(Duration.ofSeconds(5))
            .setReadTimeout(Duration.ofSeconds(10))
            .build();
    }
    
    // 命令行运行器（应用启动后执行）
    @Bean
    public CommandLineRunner initData(UserRepository repository) {
        return args -> {
            // 初始化数据
            repository.save(new User("admin", "admin@example.com"));
            System.out.println("初始化数据完成");
        };
    }
}
```

## 四、Spring Boot vs Spring

| 方面           | 传统 Spring                    | Spring Boot                        |
| -------------- | ------------------------------ | ---------------------------------- |
| **配置方式**   | XML 或 Java Config，繁琐       | 自动配置，约定优于配置             |
| **依赖管理**   | 手动管理版本，易冲突           | Starter 依赖，版本自动管理         |
| **部署方式**   | 需部署到外部服务器（Tomcat等） | 内嵌容器，可执行 JAR               |
| **启动速度**   | 相对较慢                       | 快速启动                           |
| **监控管理**   | 需集成 Spring Actuator         | 内置 Actuator，开箱即用            |
| **微服务支持** | 需额外配置                     | 原生支持，与 Spring Cloud 完美集成 |
| **开发效率**   | 较低                           | 极高                               |
| **学习曲线**   | 较陡峭                         | 平缓                               |

## 五、总结

Spring Boot 的核心价值在于：
1. **快速开发**：通过自动配置和 starter 依赖
2. **简化配置**：约定优于配置，零 XML
3. **独立运行**：内嵌容器，可执行 JAR
4. **生产就绪**：监控、健康检查、外部化配置
5. **微服务友好**：与 Spring Cloud 生态完美集成

Spring Boot 不是银弹，但在大多数 Spring 应用场景中，它能显著提高开发效率，降低维护成本。

对于新项目，强烈推荐使用 Spring Boot；对于老项目，可以考虑逐步迁移到 Spring Boot。
