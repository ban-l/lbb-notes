# Spring Boot 自动配置原理

## 一、核心流程图

```
┌─────────────────────────────────────────────────────────────┐
│                   @SpringBootApplication                     │
│                     应用主启动类注解                         │
└─────────────┬───────────────────────────────────────────────┘
              │ 由三个核心注解组成
              ▼
    ┌─────────────────────────────────────┐
    │ 1. @SpringBootConfiguration         │ ← 标记为配置类
    │ 2. @EnableAutoConfiguration         │ ← **启用自动配置**
    │ 3. @ComponentScan                   │ ← 组件扫描
    └──────────────────┬──────────────────┘
                       │
                       ▼
           ┌──────────────────────┐
           │ @EnableAutoConfiguration │
           │    导入 AutoConfigurationImportSelector │
           └───────────┬────────────┘
                       │
                       ▼
        ┌──────────────────────────────┐
        │ 扫描所有 jar 包的             │
        │ META-INF/spring.factories    │ ← **自动配置入口文件**
        └──────────────┬───────────────┘
                       │
                       ▼
        ┌──────────────────────────────┐
        │ 加载所有配置类                │
        │ org.springframework.boot.autoconfigure. │
        │ xxxAutoConfiguration         │
        └──────────────┬───────────────┘
                       │
                       ▼
        ┌──────────────────────────────┐
        │ 条件化装配                    │
        │ @ConditionalXXX 注解控制       │ ← **核心：按需装配**
        └──────────────────────────────┘
```

## 二、自动配置三要素

### 1. **条件注解（Conditional）** - 判断依据
```java
// 常见的条件注解
@ConditionalOnClass(DataSource.class)      // 类路径存在时生效
@ConditionalOnMissingBean(DataSource.class) // 不存在该Bean时生效
@ConditionalOnProperty("spring.datasource.url") // 配置属性存在时生效
@ConditionalOnWebApplication              // Web应用时生效
@ConditionalOnExpression("${app.feature.enabled:true}") // SpEL表达式
```

### 2. **配置类（AutoConfiguration）** - 配置逻辑
```java
// 示例：DataSource自动配置类
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceAutoConfiguration {
    
    @Configuration
    @Conditional(EmbeddedDatabaseCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import(EmbeddedDataSourceConfiguration.class)
    protected static class EmbeddedDatabaseConfiguration {
        // 嵌入式数据库配置
    }
    
    @Configuration
    @Conditional(PooledDataSourceCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import({ DataSourceConfiguration.Hikari.class,
              DataSourceConfiguration.Tomcat.class,
              DataSourceConfiguration.Generic.class })
    protected static class PooledDataSourceConfiguration {
        // 连接池数据库配置（默认HikariCP）
    }
}
```

### 3. **属性绑定（ConfigurationProperties）** - 外部配置
```java
// 配置属性类
@ConfigurationProperties(prefix = "spring.datasource")
public class DataSourceProperties {
    private String url;
    private String username;
    private String password;
    private String driverClassName;
    // getters/setters...
}

// application.properties 配置
spring.datasource.url=jdbc:mysql://localhost:3306/test
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

## 三、自动配置执行流程

### 1. **启动阶段**
```java
// 主类入口
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// @SpringBootApplication 展开：
@SpringBootConfiguration
@EnableAutoConfiguration  // ← 关键！
@ComponentScan
```

### 2. **加载自动配置**
```properties
# META-INF/spring.factories (spring-boot-autoconfigure包中)
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
# ... 100+ 个自动配置类
```

### 3. **条件判断执行**
```
扫描所有自动配置类
    ↓
对每个配置类进行条件判断
    ↓
条件满足 → 加载配置类 → 创建Bean
    ↓
条件不满足 → 跳过配置类
    ↓
最终：按需装配，避免冲突
```

## 四、自动配置示例：Web MVC

### 自动配置类链
```java
// WebMvcAutoConfiguration
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)  // Servlet环境
@ConditionalOnClass({ Servlet.class, 
                      DispatcherServlet.class,
                      WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)  // 用户未自定义
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class,
                      TaskExecutionAutoConfiguration.class,
                      ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
    
    // 自动配置DispatcherServlet
    // 自动配置视图解析器
    // 自动配置静态资源处理
    // 自动配置消息转换器
    // 自动配置Formatters
}
```

### 用户自定义配置
```java
// 用户可以通过以下方式自定义（优先级高于自动配置）

// 1. 定义自己的Bean
@Bean
public ViewResolver myViewResolver() {
    // 自动配置会跳过
}

// 2. 使用WebMvcConfigurer
@Configuration
public class MyWebConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 添加拦截器
    }
}

// 3. 配置文件覆盖
# application.properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
spring.resources.static-locations=classpath:/static/
```

## 五、自动配置原理总结

### 核心原理：**约定优于配置 + 条件化装配**

```java
// 简化的自动配置逻辑
public class SimplifiedAutoConfiguration {
    
    public void autoConfigure(ApplicationContext context) {
        // 1. 扫描所有spring.factories中的配置类
        List<String> configClasses = loadAutoConfigurations();
        
        for (String configClass : configClasses) {
            // 2. 检查条件注解
            if (checkConditions(configClass, context)) {
                // 3. 加载配置类
                ConfigurationClass config = loadConfigurationClass(configClass);
                
                // 4. 注册Bean定义
                registerBeanDefinitions(config, context);
            }
        }
    }
    
    private boolean checkConditions(String configClass, ApplicationContext context) {
        // 检查 @ConditionalOnClass: 类路径是否存在
        // 检查 @ConditionalOnMissingBean: Bean是否已存在
        // 检查 @ConditionalOnProperty: 配置属性是否存在
        // 检查 @ConditionalOnWebApplication: 是否是Web应用
        // ... 其他条件判断
        return true; // 所有条件满足才返回true
    }
}
```

### 关键点：
1. **启动入口**：`@EnableAutoConfiguration` 导入 `AutoConfigurationImportSelector`
2. **配置来源**：`META-INF/spring.factories` 文件
3. **条件控制**：各种 `@ConditionalOnXxx` 注解
4. **优先级**：用户配置 > 自动配置
5. **按需加载**：只有条件满足时才生效，避免资源浪费

### 一句话概括：
**Spring Boot 通过扫描 classpath 下的 `spring.factories` 文件，加载所有自动配置类，然后根据条件注解（如 `@ConditionalOnClass`、`@ConditionalOnMissingBean` 等）决定是否生效，最终实现"开箱即用"的自动配置。**

## 六、调试自动配置

### 查看生效的自动配置
```bash
# 启动时查看
java -jar app.jar --debug

# 或配置
# application.properties
debug=true
```

### 输出示例：
```
============================
CONDITIONS EVALUATION REPORT
============================

Positive matches:
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found required classes 'javax.sql.DataSource', 
        'org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType' 
      - @ConditionalOnMissingBean (types: io.r2dbc.spi.ConnectionFactory; 
        SearchStrategy: all) found no beans
        
   DataSourceAutoConfiguration.PooledDataSourceConfiguration matched:
      - @ConditionalOnMissingBean (types: javax.sql.DataSource,
        javax.sql.XADataSource; SearchStrategy: all) found no beans
        
Negative matches:
-----------------
   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 
           'javax.jms.ConnectionFactory'
           
   AopAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 
           'org.aspectj.lang.annotation.Aspect'
```

通过这种方式，可以清楚地看到哪些自动配置生效了，哪些没有生效以及原因。