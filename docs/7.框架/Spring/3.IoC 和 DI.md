# IoC 和 DI

## 一、核心概念的本质理解

### 1.1 什么是 IoC（控制反转）？

**IoC 是一种设计原则**，它**反转了传统的控制流**——将对象的创建和依赖管理的控制权从**应用程序代码**转移到**外部容器**。

```java
// 传统控制流：程序员控制一切
public class TraditionalApp {
    public void process() {
        // 程序员主动创建对象
        UserService service = new UserServiceImpl();  // 控制权在程序员
        service.process();
    }
}

// IoC控制流：容器控制一切
public class IoCApp {
    // 程序员不创建对象，只声明需要什么
    private UserService service;  // 依赖声明
    
    public void process() {
        // 由容器注入对象
        service.process();  // 控制权在容器
    }
}
```

**IoC 的核心思想**：**"不要打电话给我们，我们会打给你" (Don't call us, we'll call you)**

- 传统：应用程序主动创建和管理对象
- IoC：容器被动接收指令，主动创建和管理对象

### 1.2 什么是 DI（依赖注入）？

**DI 是实现 IoC 的一种具体技术手段**，它通过**外部注入**的方式解决对象间的依赖关系。

```java
// 没有DI：硬编码依赖
public class UserService {
    // 内部直接创建依赖（紧耦合）
    private UserRepository repository = new UserRepositoryImpl();
}

// 使用DI：外部注入依赖
public class UserService {
    // 依赖通过外部注入（松耦合）
    private UserRepository repository;
    
    // 构造器注入
    public UserService(UserRepository repository) {
        this.repository = repository;  // 依赖被"注入"
    }
}
```

## 二、IoC/DI 的演进历程

### 从原始代码到 IoC/DI 的演化

1. 硬编码（最原始）
2. 接口+工厂模式（有所改进）
3. 依赖注入（最终方案）

```java
// 阶段1：硬编码（最原始）
public class OrderService {
    // 问题1：直接new，无法替换实现
    private PaymentService payment = new AliPayService();
    
    public void pay() {
        payment.pay();  // 只能使用支付宝
    }
}

// 阶段2：接口+工厂模式（有所改进）
public class OrderService {
    // 问题2：工厂模式仍需要知道工厂类
    private PaymentService payment = PaymentFactory.create();
}

// 阶段3：依赖注入（最终方案）
public class OrderService {
    // 优点：完全解耦，由外部决定具体实现
    private PaymentService payment;
    
    public OrderService(PaymentService payment) {
        this.payment = payment;  // 可以是任何PaymentService实现
    }
}

// 使用示例
public class App {
    public static void main(String[] args) {
        // 容器负责装配
        PaymentService wechatPay = new WechatPayService();
        OrderService orderService = new OrderService(wechatPay);  // 注入微信支付
        
        // 或注入支付宝
        PaymentService aliPay = new AliPayService();
        OrderService orderService2 = new OrderService(aliPay);  // 注入支付宝
    }
}
```

## 三、IoC/DI 的三种实现方式

### 3.1 构造器注入（Spring 推荐的方式）

```java
// 优点：不可变依赖，线程安全，强制依赖
@Component
public class OrderService {
    // final关键字确保依赖不可变
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    
    // 构造器注入
    @Autowired  // Spring 4.3+ 可省略
    public OrderService(PaymentService paymentService, 
                       InventoryService inventoryService) {
        this.paymentService = paymentService;
        this.inventoryService = inventoryService;
    }
    
    public void processOrder(Order order) {
        inventoryService.checkStock(order);
        paymentService.processPayment(order);
    }
}
```

### 3.2 Setter 方法注入

```java
// 优点：可选依赖，可重新配置
@Component
public class NotificationService {
    // 可选依赖，可能有默认实现
    private EmailService emailService;
    private SmsService smsService;
    
    // Setter注入
    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
    
    @Autowired(required = false)  // 可选依赖
    public void setSmsService(SmsService smsService) {
        this.smsService = smsService;
    }
    
    public void sendNotification(User user, String message) {
        emailService.sendEmail(user, message);
        if (smsService != null) {
            smsService.sendSms(user, message);
        }
    }
}
```

### 3.3 字段注入（不推荐，但常见）

为什么字段注入不好

1. 无法设置final字段
2. 破坏封装性（使用反射直接注入私有字段）
3. 难以进行单元测试（需要Spring容器或反射）
4. 隐藏了类对依赖的需求

```java
// 缺点：隐藏依赖，难以测试，破坏封装性
@Component
public class ProductService {
    
    @Autowired  // 字段注入（避免使用！）
    private ProductRepository repository;
    
    @Autowired
    private CacheService cache;
    
    public Product getProduct(Long id) {
        // 问题：依赖关系不明确
        return repository.findById(id);
    }
}
```

## 四、Spring IoC 容器工作原理

### 4.1 IoC 容器如何工作

```java
// 简化的IoC容器实现
public class SimpleIoCContainer {
    private Map<String, Object> beans = new HashMap<>();
    private Map<String, Class<?>> beanDefinitions = new HashMap<>();
    
    // 注册Bean定义
    public void registerBean(String name, Class<?> beanClass) {
        beanDefinitions.put(name, beanClass);
    }
    
    // 初始化容器
    public void init() {
        for (Map.Entry<String, Class<?>> entry : beanDefinitions.entrySet()) {
            try {
                // 1. 创建Bean实例
                Object bean = createBean(entry.getValue());
                
                // 2. 注入依赖
                injectDependencies(bean);
                
                // 3. 初始化回调
                invokeInitMethods(bean);
                
                // 4. 放入容器
                beans.put(entry.getKey(), bean);
                
            } catch (Exception e) {
                throw new RuntimeException("创建Bean失败: " + entry.getKey(), e);
            }
        }
    }
    
    private Object createBean(Class<?> beanClass) throws Exception {
        // 查找构造器
        Constructor<?>[] constructors = beanClass.getConstructors();
        
        // 查找@Autowired构造器
        for (Constructor<?> constructor : constructors) {
            if (constructor.isAnnotationPresent(Autowired.class)) {
                // 获取构造器参数类型
                Class<?>[] paramTypes = constructor.getParameterTypes();
                Object[] params = new Object[paramTypes.length];
                
                // 为每个参数查找对应的Bean
                for (int i = 0; i < paramTypes.length; i++) {
                    params[i] = getBean(paramTypes[i]);
                }
                
                return constructor.newInstance(params);
            }
        }
        
        // 使用默认构造器
        return beanClass.newInstance();
    }
    
    private void injectDependencies(Object bean) throws Exception {
        Field[] fields = bean.getClass().getDeclaredFields();
        
        for (Field field : fields) {
            if (field.isAnnotationPresent(Autowired.class)) {
                field.setAccessible(true);
                Object dependency = getBean(field.getType());
                field.set(bean, dependency);
            }
        }
    }
    
    // 获取Bean
    public <T> T getBean(Class<T> type) {
        for (Object bean : beans.values()) {
            if (type.isInstance(bean)) {
                return type.cast(bean);
            }
        }
        throw new RuntimeException("找不到Bean: " + type.getName());
    }
}
```

### 4.2 实际应用示例

```java
// 定义Bean
public class UserService {
    private final UserRepository repository;
    
    @Autowired
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}

public class UserRepository {
    private final DataSource dataSource;
    
    @Autowired
    public UserRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}

// 使用容器
public class Application {
    public static void main(String[] args) {
        SimpleIoCContainer container = new SimpleIoCContainer();
        
        // 注册Bean定义
        container.registerBean("dataSource", DataSource.class);
        container.registerBean("userRepository", UserRepository.class);
        container.registerBean("userService", UserService.class);
        
        // 初始化容器（触发依赖注入）
        container.init();
        
        // 使用
        UserService userService = container.getBean(UserService.class);
        userService.doSomething();
    }
}
```

## 五、IoC/DI 的优势与价值

### 5.1 六大核心优势

1. 松耦合
2. 可测试性
3. 可维护性
4. 可配置性
5. 单一职责：每个类专注于自己的功能，依赖通过注入获得
6. 生命周期管理：容器统一管理Bean的创建、初始化、销毁

```java
// 优势1：松耦合
public class OrderService {
    // 不关心PaymentService的具体实现
    private final PaymentService paymentService;
    
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;  // 可以是任何实现
    }
}

// 优势2：可测试性
public class OrderServiceTest {
    @Test
    void testProcessOrder() {
        // 使用Mock对象进行测试
        PaymentService mockPayment = mock(PaymentService.class);
        OrderService service = new OrderService(mockPayment);  // 轻松注入Mock
        
        // 测试代码...
    }
}

// 优势3：可维护性
// 修改实现只需更换注入的对象，不需要修改OrderService代码

// 优势4：可配置性
@Configuration
public class AppConfig {
    
    @Bean
    @Profile("dev")  // 开发环境使用模拟支付
    public PaymentService devPaymentService() {
        return new MockPaymentService();
    }
    
    @Bean
    @Profile("prod")  // 生产环境使用真实支付
    public PaymentService prodPaymentService() {
        return new RealPaymentService();
    }
}

// 优势5：单一职责
// 每个类专注于自己的功能，依赖通过注入获得

// 优势6：生命周期管理
// 容器统一管理Bean的创建、初始化、销毁
```

### 5.2 实际业务场景对比

```java
// 场景：电商订单处理
// 不使用IoC/DI的紧耦合代码
public class OrderProcessor {
    private PaymentGateway payment = new AliPayGateway();  // 硬编码
    private InventoryManager inventory = new MySQLInventory();  // 硬编码
    private EmailNotifier notifier = new SMTPEmailNotifier();  // 硬编码
    
    public void process(Order order) {
        inventory.checkStock(order);
        payment.charge(order);
        notifier.sendReceipt(order);
        // 问题：难以测试，无法切换实现
    }
}

// 使用IoC/DI的解耦代码
@Component
public class OrderProcessor {
    private final PaymentGateway payment;
    private final InventoryManager inventory;
    private final NotificationService notifier;
    
    @Autowired
    public OrderProcessor(PaymentGateway payment,
                         InventoryManager inventory,
                         NotificationService notifier) {
        this.payment = payment;      // 可以是支付宝、微信、PayPal等
        this.inventory = inventory;  // 可以是MySQL、Redis、MongoDB等
        this.notifier = notifier;    // 可以是邮件、短信、微信等
    }
    
    public void process(Order order) {
        inventory.checkStock(order);
        payment.charge(order);
        notifier.sendReceipt(order);
        // 优点：灵活可配置，易于测试
    }
}

// 配置不同的实现
@Configuration
public class PaymentConfig {
    
    @Bean
    @ConditionalOnProperty(name = "payment.gateway", havingValue = "alipay")
    public PaymentGateway aliPayGateway() {
        return new AliPayGateway();
    }
    
    @Bean
    @ConditionalOnProperty(name = "payment.gateway", havingValue = "wechat")
    public PaymentGateway wechatPayGateway() {
        return new WechatPayGateway();
    }
    
    @Bean
    @ConditionalOnProperty(name = "payment.gateway", havingValue = "paypal")
    public PaymentGateway paypalGateway() {
        return new PayPalGateway();
    }
}
```

## 六、Spring 中的高级 DI 特性

### 6.1 多种依赖注入方式

```java
@Component
public class ComplexService {
    
    // 1. 基本注入
    @Autowired
    private UserRepository userRepository;
    
    // 2. 构造器注入（推荐）
    private final ProductRepository productRepository;
    
    @Autowired
    public ComplexService(ProductRepository productRepository) {
        this.productRepository = productRepository;
    }
    
    // 3. 方法注入
    private OrderRepository orderRepository;
    
    @Autowired
    public void setOrderRepository(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }
    
    // 4. 集合注入
    @Autowired
    private List<Validator> validators;  // 注入所有Validator实现
    
    // 5. Map注入（Key为Bean名称）
    @Autowired
    private Map<String, Processor> processors;
    
    // 6. Optional注入（Java 8+）
    @Autowired(required = false)
    private Optional<CacheService> cacheService;
    
    // 7. @Qualifier指定具体Bean
    @Autowired
    @Qualifier("primaryDataSource")
    private DataSource dataSource;
    
    // 8. @Value注入配置值
    @Value("${app.timeout:5000}")
    private int timeout;
    
    // 9. 懒加载注入
    @Lazy
    @Autowired
    private ExpensiveService expensiveService;
}
```

### 6.2 条件化依赖注入

```java
@Configuration
public class ConditionalInjection {
    
    // 条件1：根据类路径存在性
    @Bean
    @ConditionalOnClass(name = "com.fasterxml.jackson.databind.ObjectMapper")
    public JsonService jsonService() {
        return new JacksonJsonService();
    }
    
    // 条件2：根据Bean存在性
    @Bean
    @ConditionalOnMissingBean(DataSource.class)
    public DataSource embeddedDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    // 条件3：根据配置属性
    @Bean
    @ConditionalOnProperty(prefix = "cache", name = "type", havingValue = "redis")
    public CacheService redisCache() {
        return new RedisCacheService();
    }
    
    @Bean
    @ConditionalOnProperty(prefix = "cache", name = "type", havingValue = "local")
    public CacheService localCache() {
        return new LocalCacheService();
    }
    
    // 条件4：根据Profile
    @Bean
    @Profile("dev")
    public MailService devMailService() {
        return new MockMailService();  // 开发环境用模拟
    }
    
    @Bean
    @Profile("prod")
    public MailService prodMailService() {
        return new SMTPMailService();  // 生产环境用真实
    }
}
```

## 七、IoC/DI 的设计模式关联

### 7.1 IoC 与设计模式的关系

1. 工厂模式 + 反射机制
2. 模板方法
3. 策略模式
4. 观察者模式
5. 组合模式

```java
// IoC 实际上是多种设计模式的组合应用

// 1. 工厂模式（BeanFactory）
public interface BeanFactory {
    Object getBean(String name);  // 工厂方法
}

// 2. 模板方法模式（Bean生命周期）
public abstract class AbstractBeanFactory {
    // 模板方法定义Bean创建流程
    protected Object createBean() {
        // 1. 实例化
        Object bean = doCreateBean();
        // 2. 属性填充
        populateBean(bean);
        // 3. 初始化
        initializeBean(bean);
        return bean;
    }
    
    protected abstract Object doCreateBean();
}

// 3. 策略模式（依赖注入策略）
public interface InjectionStrategy {
    void inject(Object bean, BeanDefinition bd);
}

public class ConstructorInjection implements InjectionStrategy {
    public void inject(Object bean, BeanDefinition bd) {
        // 构造器注入逻辑
    }
}

public class SetterInjection implements InjectionStrategy {
    public void inject(Object bean, BeanDefinition bd) {
        // Setter注入逻辑
    }
}

// 4. 观察者模式（容器事件）
public class ApplicationEventPublisher {
    public void publishEvent(ApplicationEvent event) {
        // 通知所有监听器
        for (ApplicationListener listener : listeners) {
            listener.onApplicationEvent(event);
        }
    }
}

// 5. 组合模式（父子容器）
public interface ApplicationContext extends BeanFactory {
    ApplicationContext getParent();  // 父容器引用
}
```

### 7.2 DI 的三种形式对比

```java
// 形式1：构造器注入（Constructor Injection）
public class OrderService {
    private final PaymentService payment;
    
    // 优点：强制依赖，不可变，线程安全
    // 缺点：参数多时构造器复杂
    public OrderService(PaymentService payment, 
                       InventoryService inventory,
                       NotificationService notification,
                       AuditService audit) {
        this.payment = payment;
        // ... 
    }
}

// 形式2：Setter注入（Setter Injection）
public class UserService {
    private UserRepository repository;
    private CacheService cache;
    
    // 优点：可选依赖，可重新配置
    // 缺点：对象可能处于不完整状态
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
    
    public void setCache(CacheService cache) {
        this.cache = cache;
    }
}

// 形式3：接口注入（Interface Injection）- 较少使用
public interface RepositoryAware {
    void setRepository(UserRepository repository);
}

public class UserService implements RepositoryAware {
    private UserRepository repository;
    
    @Override
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }
}
```

## 八、实际应用中的最佳实践

### 8.1 依赖注入最佳实践

```java
// 实践1：优先使用构造器注入
@Component
public class BestPracticeService {
    // 使用final确保依赖不变
    private final DependencyA depA;
    private final DependencyB depB;
    
    // 一个构造器，明确所有必需依赖
    @Autowired
    public BestPracticeService(DependencyA depA, DependencyB depB) {
        this.depA = depA;
        this.depB = depB;
    }
}

// 实践2：避免循环依赖
// 错误示例
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;  // 循环依赖！
}

@Component  
public class ServiceB {
    @Autowired
    private ServiceA serviceA;  // 循环依赖！
}

// 解决方案1：使用setter注入打破循环
@Component
public class ServiceA {
    private ServiceB serviceB;
    
    @Autowired
    public void setServiceB(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}

// 解决方案2：使用@Lazy延迟注入
@Component
public class ServiceC {
    private final ServiceD serviceD;
    
    @Autowired
    public ServiceC(@Lazy ServiceD serviceD) {
        this.serviceD = serviceD;  // 延迟初始化
    }
}

// 实践3：合理使用@Qualifier
@Configuration
public class MultiDataSourceConfig {
    
    @Bean
    @Primary  // 主要数据源
    @Qualifier("primaryDataSource")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://primary-host:3306/db")
            .build();
    }
    
    @Bean
    @Qualifier("secondaryDataSource")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://secondary-host:3306/db")
            .build();
    }
}

@Component
public class DataService {
    
    @Autowired
    @Qualifier("primaryDataSource")
    private DataSource primaryDs;
    
    @Autowired
    @Qualifier("secondaryDataSource")  
    private DataSource secondaryDs;
}
```

### 8.2 复杂依赖场景处理

```java
// 场景1：多个同类型Bean的注入
@Component
public class NotificationService {
    
    // 注入所有MessageSender实现
    @Autowired
    private List<MessageSender> senders;
    
    // 按名称注入Map
    @Autowired
    private Map<String, MessageSender> senderMap;
    
    public void sendAll(String message) {
        for (MessageSender sender : senders) {
            sender.send(message);
        }
    }
}

// 场景2：条件化Bean创建
@Configuration
public class StrategyConfig {
    
    @Bean
    @ConditionalOnExpression("#{'${app.mode}' == 'simple'}")
    public ProcessingStrategy simpleStrategy() {
        return new SimpleStrategy();
    }
    
    @Bean
    @ConditionalOnExpression("#{'${app.mode}' == 'advanced'}")
    public ProcessingStrategy advancedStrategy() {
        return new AdvancedStrategy();
    }
}

// 场景3：原型Bean注入单例Bean
@Component
@Scope("singleton")
public class SingletonService {
    
    // 需要原型Bean时，使用Provider延迟获取
    @Autowired
    private Provider<PrototypeBean> prototypeBeanProvider;
    
    public void process() {
        // 每次调用获取新的原型实例
        PrototypeBean bean = prototypeBeanProvider.get();
        bean.doSomething();
    }
}

@Component
@Scope("prototype")
public class PrototypeBean {
    // 每次获取都是新实例
}
```

## 九、常见误解与澄清

### 9.1 误解澄清

```java
// 误解1：IoC就是DI
// 正确：DI是实现IoC的一种方式，不是全部
// 其他IoC实现：服务定位器、工厂模式、模板回调等

// 误解2：@Autowired就是IoC
// 正确：@Autowired是实现DI的一种注解，Spring还有@Resource、@Inject等

// 误解3：Spring必须有XML配置才是IoC
// 正确：XML、注解、Java Config都是配置方式，核心都是IoC

// 误解4：IoC让代码更复杂
// 实际：初期学习曲线较陡，但长期看降低复杂度

// 误解5：字段注入和构造器注入效果一样
// 实际：构造器注入更好（不可变、线程安全、明确依赖）
```

### 9.2 性能考虑

```java
// IoC容器性能优化
@Configuration
public class PerformanceConfig {
    
    // 1. 使用@Lazy减少启动时间
    @Bean
    @Lazy
    public ExpensiveService expensiveService() {
        // 延迟初始化，加快启动
        return new ExpensiveService();
    }
    
    // 2. 避免不必要的@Autowired
    // 错误：注入不必要的依赖
    @Component
    public class UnnecessaryInjection {
        @Autowired
        private ServiceA serviceA;  // 实际没用到
        @Autowired  
        private ServiceB serviceB;  // 实际没用到
    }
    
    // 3. 合理使用原型作用域
    @Component
    @Scope("prototype")
    public class StatelessProcessor {
        // 无状态Bean使用原型，避免线程安全问题
    }
    
    // 4. 避免循环依赖（影响性能）
    // Spring解决循环依赖需要三级缓存，有性能开销
}
```

## 十、总结与理解

### 10.1 一句话理解

- **IoC（控制反转）**：**"谁来控制"** 的问题——将控制权从应用程序转移到容器
- **DI（依赖注入）**：**"如何获取依赖"** 的问题——通过外部注入而非内部创建

### 10.2 类比理解

```
传统编程：自己造车
- 需要自己制造发动机、轮胎、座椅
- 所有零件都要自己生产
- 换零件需要重新造车

IoC/DI编程：组装车
- 告诉工厂需要什么配置（声明依赖）
- 工厂提供所有零件（容器注入）
- 换零件只需告诉工厂（配置变更）
```

### 10.3 核心价值总结

```java
// 价值1：解耦
// 从：ServiceA → new ServiceB()
// 到：ServiceA ←─(依赖注入)─ ServiceB

// 价值2：可测试
// 可以轻松注入Mock对象进行单元测试

// 价值3：可维护
// 修改实现只需修改配置，不修改业务代码

// 价值4：灵活
// 通过配置切换不同实现（开发/生产环境）

// 价值5：统一管理
// 容器统一管理对象生命周期、作用域、配置
```

### 10.4 实际应用口诀

```
1. 依赖声明不创建（声明接口，不new实现）
2. 构造注入是首选（final字段，线程安全）
3. 避免循环要注意（设计时就要考虑）
4. 条件注入更灵活（根据环境动态选择）
5. 测试驱动来验证（轻松Mock，方便测试）
```

**最终理解**：**IoC/DI 不是框架特性，而是设计思想。**

**它通过"控制反转"和"依赖注入"实现了对象间的松耦合，让代码更加灵活、可测试、可维护。**

**Spring 只是这种思想最成功的实现者之一。**
