# Spring 容器

## 一、Spring 容器核心概念

### 1.1 什么是 Spring 容器？
**Spring 容器**是 Spring 框架的核心，它是一个**管理 Bean 生命周期和依赖关系的运行时环境**。

```java
// 容器 = Bean工厂 + 依赖注入 + 生命周期管理
public interface SpringContainer {
    // 核心功能
    1. 创建和管理 Bean 实例
    2. 解析和注入依赖关系
    3. 管理 Bean 生命周期
    4. 提供 AOP 支持
    5. 处理事件和国际化
}
```

### 1.2 容器 vs 传统对象创建
```java
// 传统方式：手动创建和管理对象
public class TraditionalApp {
    public static void main(String[] args) {
        // 程序员手动创建对象
        UserService userService = new UserServiceImpl();
        UserDao userDao = new UserDaoImpl();
        
        // 手动设置依赖
        userService.setUserDao(userDao);
        
        // 手动管理生命周期
        userService.init();
        userService.doSomething();
        userService.destroy();
    }
}

// Spring 容器方式：容器管理对象
public class SpringApp {
    public static void main(String[] args) {
        // 创建容器
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
        
        // 从容器获取对象（Bean）
        UserService userService = context.getBean(UserService.class);
        
        // 依赖已自动注入
        userService.doSomething();
        
        // 容器关闭时自动管理销毁
        ((ConfigurableApplicationContext) context).close();
    }
}
```

## 二、Spring 容器架构层次

### 2.1 容器接口层次结构
```
┌─────────────────────────────────────────────────────────────┐
│                    Spring 容器接口层次                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │               BeanFactory (基础容器)                  │   │
│  │       提供基本的IoC功能，延迟加载，轻量级                 │   │
│  └──────────────────────────┬──────────────────────────┘   │
│                             │                               │
│  ┌──────────────────────────▼──────────────────────────┐   │
│  │          ApplicationContext (高级容器)                │   │
│  │   继承BeanFactory，增加企业级功能，立即加载               │   │
│  └──────────────────────────┬──────────────────────────┘   │
│                             │                               │
│           ┌─────────────────┼─────────────────┐             │
│           ▼                 ▼                 ▼             │
│  ┌───────────────┐  ┌───────────────────┐  ┌──────────────┐ │
│  │ Web应用容器    │  │注解配置容器         │  │响应式容器      │ │
│  │ WebApplication│  │ AnnotationConfig  │  │ ReactiveWeb  │ │
│  │ Context       │  │ ApplicationContext│  │ Application  │ │
│  └───────────────┘  └───────────────────┘  └──────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心接口详解
```java
// 1. BeanFactory - 基础容器接口
public interface BeanFactory {
    // 核心方法
    Object getBean(String name) throws BeansException;
    <T> T getBean(String name, Class<T> requiredType);
    <T> T getBean(Class<T> requiredType);
    boolean containsBean(String name);
    boolean isSingleton(String name);
    Class<?> getType(String name);
}

// 2. ApplicationContext - 高级容器接口
public interface ApplicationContext extends BeanFactory, 
                                          ApplicationEventPublisher,
                                          MessageSource,
                                          ResourcePatternResolver {
    // 扩展功能
    String getId();
    String getApplicationName();
    ApplicationContext getParent();
    AutowireCapableBeanFactory getAutowireCapableBeanFactory();
    long getStartupDate();
    
    // 环境相关
    Environment getEnvironment();
    
    // 获取Bean工厂
    ConfigurableListableBeanFactory getBeanFactory();
}
```

## 三、容器实现类详解

### 3.1 BeanFactory 实现
```java
// 常用BeanFactory实现
public class BeanFactoryImpls {
    // 1. DefaultListableBeanFactory - 最灵活的BeanFactory实现
    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
    
    // 2. XmlBeanFactory（已废弃，Spring 5.x）
    // BeanFactory factory = new XmlBeanFactory(new ClassPathResource("beans.xml"));
    
    // 使用示例
    public void demo() {
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
        
        // 注册Bean定义
        RootBeanDefinition beanDefinition = new RootBeanDefinition(UserService.class);
        factory.registerBeanDefinition("userService", beanDefinition);
        
        // 获取Bean
        UserService userService = factory.getBean("userService", UserService.class);
    }
}
```

### 3.2 ApplicationContext 实现
```java
public class ApplicationContextImpls {
    
    // ============ 基于XML配置 ============
    // 1. ClassPathXmlApplicationContext - 类路径XML配置
    ApplicationContext context1 = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    
    // 2. FileSystemXmlApplicationContext - 文件系统XML配置
    ApplicationContext context2 = new FileSystemXmlApplicationContext("file:/config/applicationContext.xml");
    
    // 3. XmlWebApplicationContext - Web应用XML配置（已废弃）
    // ApplicationContext context3 = new XmlWebApplicationContext();
    
    // ============ 基于注解配置 ============
    // 4. AnnotationConfigApplicationContext - 注解配置
    ApplicationContext context4 = new AnnotationConfigApplicationContext(AppConfig.class);
    
    // 5. AnnotationConfigWebApplicationContext - Web注解配置
    ApplicationContext context5 = new AnnotationConfigWebApplicationContext();
    
    // ============ 特殊用途 ============
    // 6. GenericApplicationContext - 通用容器
    GenericApplicationContext context6 = new GenericApplicationContext();
    
    // 7. StaticApplicationContext - 静态编程式配置
    StaticApplicationContext context7 = new StaticApplicationContext();
    
    // ============ Spring Boot 专用 ============
    // 8. SpringApplication - Spring Boot启动器
    ConfigurableApplicationContext context8 = SpringApplication.run(Application.class, args);
    
    // 9. ReactiveWebApplicationContext - 响应式Web容器
    // ApplicationContext context9 = new ReactiveWebApplicationContext();
}
```

### 3.3 Web 应用容器
```java
// Web应用特殊容器
public class WebApplicationContexts {
    
    // 1. XmlWebApplicationContext（传统方式，已废弃）
    // 配置在web.xml中
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    
    // 2. AnnotationConfigWebApplicationContext（现代方式）
    public class WebAppInitializer implements WebApplicationInitializer {
        @Override
        public void onStartup(ServletContext servletContext) {
            // 创建注解配置的Web容器
            AnnotationConfigWebApplicationContext context = 
                new AnnotationConfigWebApplicationContext();
            context.register(AppConfig.class);
            
            // 注册DispatcherServlet
            ServletRegistration.Dynamic dispatcher = 
                servletContext.addServlet("dispatcher", new DispatcherServlet(context));
            dispatcher.addMapping("/");
        }
    }
    
    // 3. Spring Boot Web容器（自动配置）
    @SpringBootApplication
    public class Application {
        public static void main(String[] args) {
            // 自动创建Web容器
            SpringApplication.run(Application.class, args);
        }
    }
}
```

## 四、容器核心工作机制

### 4.1 容器启动流程
```java
// Spring容器启动的详细流程
public class ContainerStartupProcess {
    
    public void startup() {
        // 阶段1：实例化容器
        ApplicationContext context = new AnnotationConfigApplicationContext();
        
        // 阶段2：注册配置类
        ((AnnotationConfigApplicationContext) context).register(AppConfig.class);
        
        // 阶段3：刷新容器（核心）
        context.refresh();  // 触发以下流程：
        
        // 子流程：
        // 1. prepareRefresh() - 准备刷新
        // 2. obtainFreshBeanFactory() - 获取新的BeanFactory
        // 3. prepareBeanFactory() - 准备BeanFactory
        // 4. postProcessBeanFactory() - BeanFactory后处理
        // 5. invokeBeanFactoryPostProcessors() - 执行BeanFactoryPostProcessor
        // 6. registerBeanPostProcessors() - 注册BeanPostProcessor
        // 7. initMessageSource() - 初始化消息源
        // 8. initApplicationEventMulticaster() - 初始化事件广播器
        // 9. onRefresh() - 刷新子类特定上下文
        // 10. registerListeners() - 注册监听器
        // 11. finishBeanFactoryInitialization() - 完成BeanFactory初始化（实例化单例Bean）
        // 12. finishRefresh() - 完成刷新
    }
}
```

### 4.2 Bean 创建流程
```java
// Bean创建的核心流程
public class BeanCreationProcess {
    
    public Object createBean() {
        // 1. 实例化前阶段
        Object bean = applyBeanPostProcessorsBeforeInstantiation();
        if (bean != null) return bean;
        
        // 2. 实例化（通过反射或工厂方法）
        bean = createBeanInstance();
        
        // 3. 实例化后处理
        applyMergedBeanDefinitionPostProcessors();
        
        // 4. 属性填充（依赖注入）
        populateBean(bean);
        
        // 5. 初始化
        bean = initializeBean(bean);
        
        // 6. 销毁前注册
        registerDisposableBeanIfNecessary(bean);
        
        return bean;
    }
    
    private Object initializeBean(Object bean) {
        // 初始化步骤：
        // 1. 调用Aware方法（BeanNameAware, BeanFactoryAware等）
        invokeAwareMethods(bean);
        
        // 2. 执行BeanPostProcessor的postProcessBeforeInitialization
        applyBeanPostProcessorsBeforeInitialization(bean);
        
        // 3. 调用初始化方法
        invokeInitMethods(bean);  // @PostConstruct, InitializingBean, init-method
        
        // 4. 执行BeanPostProcessor的postProcessAfterInitialization（AOP代理在此创建）
        bean = applyBeanPostProcessorsAfterInitialization(bean);
        
        return bean;
    }
}
```

### 4.3 依赖注入机制
```java
// Spring容器的依赖注入方式
public class DependencyInjection {
    
    // 方式1：构造器注入（Spring推荐）
    @Component
    public class UserService {
        private final UserRepository repository;
        
        @Autowired  // Spring 4.3+ 可省略
        public UserService(UserRepository repository) {
            this.repository = repository;
        }
    }
    
    // 方式2：Setter方法注入
    @Component
    public class OrderService {
        private PaymentService paymentService;
        
        @Autowired
        public void setPaymentService(PaymentService paymentService) {
            this.paymentService = paymentService;
        }
    }
    
    // 方式3：字段注入（不推荐）
    @Component
    public class ProductService {
        @Autowired
        private InventoryService inventoryService;
    }
    
    // 方式4：方法注入
    @Component
    public class ReportService {
        
        @Autowired
        public void setupServices(DataService dataService, 
                                  ExportService exportService) {
            // 多个依赖注入
        }
    }
}
```

## 五、容器高级特性

### 5.1 Bean 作用域（Scope）
```java
// Spring支持的Bean作用域
public class BeanScopes {
    
    // 1. singleton（默认） - 单例，容器中只有一个实例
    @Component
    @Scope("singleton")
    public class SingletonService {
        // 整个容器共享一个实例
    }
    
    // 2. prototype - 原型，每次请求都创建新实例
    @Component
    @Scope("prototype")
    public class PrototypeService {
        // 每次getBean()都返回新实例
    }
    
    // 3. request - Web请求作用域（Web环境）
    @Component
    @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public class RequestScopedBean {
        // 每个HTTP请求一个实例
    }
    
    // 4. session - 会话作用域（Web环境）
    @Component
    @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public class SessionScopedBean {
        // 每个HTTP会话一个实例
    }
    
    // 5. application - 应用作用域（Web环境）
    @Component
    @Scope("application")
    public class ApplicationScopedBean {
        // 整个Web应用一个实例
    }
    
    // 6. websocket - WebSocket作用域（WebSocket环境）
    @Component
    @Scope("websocket")
    public class WebSocketScopedBean {
        // 每个WebSocket会话一个实例
    }
    
    // 7. 自定义作用域
    @Component
    public class CustomScopeConfig {
        
        @Bean
        public static CustomScopeConfigurer customScopeConfigurer() {
            CustomScopeConfigurer configurer = new CustomScopeConfigurer();
            configurer.addScope("thread", new SimpleThreadScope());  // 线程作用域
            return configurer;
        }
    }
}
```

### 5.2 Bean 生命周期回调
```java
// Bean生命周期完整回调
@Component
public class LifecycleBean implements 
        BeanNameAware, 
        BeanFactoryAware, 
        ApplicationContextAware,
        InitializingBean, 
        DisposableBean {
    
    // 1. 构造器
    public LifecycleBean() {
        System.out.println("1. 构造函数执行");
    }
    
    // 2. BeanNameAware
    @Override
    public void setBeanName(String name) {
        System.out.println("2. BeanNameAware: bean名称 = " + name);
    }
    
    // 3. BeanFactoryAware
    @Override
    public void setBeanFactory(BeanFactory beanFactory) {
        System.out.println("3. BeanFactoryAware: 设置BeanFactory");
    }
    
    // 4. ApplicationContextAware
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        System.out.println("4. ApplicationContextAware: 设置ApplicationContext");
    }
    
    // 5. BeanPostProcessor - postProcessBeforeInitialization
    // （由其他Bean实现，非当前Bean）
    
    // 6. @PostConstruct 注解
    @PostConstruct
    public void postConstruct() {
        System.out.println("5. @PostConstruct 执行");
    }
    
    // 7. InitializingBean 接口
    @Override
    public void afterPropertiesSet() {
        System.out.println("6. InitializingBean.afterPropertiesSet 执行");
    }
    
    // 8. 自定义初始化方法
    @Bean(initMethod = "initMethod")
    public void initMethod() {
        System.out.println("7. 自定义init-method 执行");
    }
    
    // 9. BeanPostProcessor - postProcessAfterInitialization（AOP代理在此创建）
    
    // ============ 使用阶段 ============
    
    // ============ 销毁阶段 ============
    // 10. @PreDestroy 注解
    @PreDestroy
    public void preDestroy() {
        System.out.println("8. @PreDestroy 执行");
    }
    
    // 11. DisposableBean 接口
    @Override
    public void destroy() {
        System.out.println("9. DisposableBean.destroy 执行");
    }
    
    // 12. 自定义销毁方法
    @Bean(destroyMethod = "destroyMethod")
    public void destroyMethod() {
        System.out.println("10. 自定义destroy-method 执行");
    }
}
```

### 5.3 容器扩展点
```java
// 1. BeanFactoryPostProcessor - 修改Bean定义
@Component
public class CustomBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // 可以修改Bean定义，添加属性等
        BeanDefinition bd = beanFactory.getBeanDefinition("userService");
        bd.getPropertyValues().add("timeout", "5000");
    }
}

// 2. BeanPostProcessor - 修改Bean实例
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        // 初始化前处理
        System.out.println("初始化前: " + beanName);
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        // 初始化后处理（AOP代理在此生成）
        System.out.println("初始化后: " + beanName);
        if (bean instanceof UserService) {
            // 返回代理对象
            return Proxy.newProxyInstance(...);
        }
        return bean;
    }
}

// 3. FactoryBean - 创建复杂对象
@Component
public class MyFactoryBean implements FactoryBean<ComplexObject> {
    
    @Override
    public ComplexObject getObject() {
        // 创建复杂对象
        return new ComplexObject("配置", "依赖");
    }
    
    @Override
    public Class<?> getObjectType() {
        return ComplexObject.class;
    }
    
    @Override
    public boolean isSingleton() {
        return true;
    }
}

// 使用
@Autowired
private ComplexObject complexObject;  // 实际获取的是FactoryBean.getObject()的结果

@Autowired
private MyFactoryBean myFactoryBean;  // 获取FactoryBean本身需要加&前缀
```

## 六、容器配置方式

### 6.1 XML 配置（传统方式）
```xml
<!-- applicationContext.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd">
    
    <!-- 启用注解扫描 -->
    <context:component-scan base-package="com.example"/>
    
    <!-- 启用注解驱动 -->
    <context:annotation-config/>
    
    <!-- Bean定义 -->
    <bean id="userService" class="com.example.UserServiceImpl">
        <!-- 构造器注入 -->
        <constructor-arg ref="userRepository"/>
        <!-- 属性注入 -->
        <property name="timeout" value="5000"/>
    </bean>
    
    <bean id="userRepository" class="com.example.UserRepositoryImpl">
        <!-- 数据源注入 -->
        <property name="dataSource" ref="dataSource"/>
    </bean>
    
    <!-- 数据源配置 -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/test"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
    </bean>
    
    <!-- AOP配置 -->
    <bean id="loggingAspect" class="com.example.LoggingAspect"/>
    
    <aop:config>
        <aop:aspect ref="loggingAspect">
            <aop:before method="logBefore" 
                       pointcut="execution(* com.example.service.*.*(..))"/>
        </aop:aspect>
    </aop:config>
</beans>
```

### 6.2 Java Config（现代方式）
```java
// 配置类
@Configuration
@ComponentScan("com.example")
@EnableAspectJAutoProxy
@EnableTransactionManagement
@EnableCaching
public class AppConfig {
    
    // Bean定义方法
    @Bean
    public UserService userService(UserRepository userRepository) {
        UserServiceImpl service = new UserServiceImpl();
        service.setUserRepository(userRepository);
        service.setTimeout(5000);
        return service;
    }
    
    @Bean
    public UserRepository userRepository(DataSource dataSource) {
        return new UserRepositoryImpl(dataSource);
    }
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        ds.setJdbcUrl("jdbc:mysql://localhost:3306/test");
        ds.setUsername("root");
        ds.setPassword("123456");
        ds.setDriverClassName("com.mysql.cj.jdbc.Driver");
        return ds;
    }
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    
    @Bean
    public LoggingAspect loggingAspect() {
        return new LoggingAspect();
    }
}
```

### 6.3 注解配置（最常用）
```java
// 无需显式配置类，使用注解
@Service
@Transactional
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Value("${app.timeout:5000}")
    private int timeout;
    
    // 业务方法
    @Cacheable("users")
    public User getUser(Long id) {
        return userRepository.findById(id);
    }
}

@Repository
public class UserRepositoryImpl implements UserRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public User findById(Long id) {
        return entityManager.find(User.class, id);
    }
}

// 启动类（Spring Boot风格）
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

## 七、容器高级应用

### 7.1 父子容器
```java
// 父子容器架构
public class ParentChildContainers {
    
    public void demo() {
        // 父容器
        ApplicationContext parentContext = new ClassPathXmlApplicationContext("parent-context.xml");
        
        // 子容器
        GenericApplicationContext childContext = new GenericApplicationContext();
        childContext.setParent(parentContext);
        childContext.registerBean("childBean", ChildBean.class);
        childContext.refresh();
        
        // 子容器可以访问父容器的Bean
        ParentBean parentBean = childContext.getBean(ParentBean.class);
        
        // 父容器不能访问子容器的Bean
        // ParentContext.getBean(ChildBean.class)  // 报错
    }
}

// 典型应用：Spring MVC
// 父容器：业务层Bean（Service、Repository）
// 子容器：Web层Bean（Controller、Handler）
```

### 7.2 条件化 Bean 注册
```java
// 根据条件动态注册Bean
@Configuration
public class ConditionalConfig {
    
    // 根据类路径存在性注册
    @Bean
    @ConditionalOnClass(name = "com.example.SomeClass")
    public SomeService someService() {
        return new SomeService();
    }
    
    // 根据属性配置注册
    @Bean
    @ConditionalOnProperty(name = "app.feature.enabled", havingValue = "true")
    public FeatureService featureService() {
        return new FeatureService();
    }
    
    // 根据Bean存在性注册
    @Bean
    @ConditionalOnMissingBean(DataSource.class)
    public DataSource embeddedDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    // 自定义条件
    @Bean
    @Conditional(DevEnvironmentCondition.class)
    public DevService devService() {
        return new DevService();
    }
}

// 自定义条件类
public class DevEnvironmentCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String env = context.getEnvironment().getProperty("app.env");
        return "dev".equals(env);
    }
}
```

### 7.3 容器事件机制
```java
// Spring容器事件体系
public class ContainerEvents {
    
    // 1. 定义自定义事件
    public class UserRegisteredEvent extends ApplicationEvent {
        private User user;
        
        public UserRegisteredEvent(Object source, User user) {
            super(source);
            this.user = user;
        }
        
        public User getUser() { return user; }
    }
    
    // 2. 发布事件
    @Service
    public class UserService {
        
        @Autowired
        private ApplicationEventPublisher eventPublisher;
        
        public void register(User user) {
            // 保存用户
            saveUser(user);
            
            // 发布事件
            eventPublisher.publishEvent(new UserRegisteredEvent(this, user));
        }
    }
    
    // 3. 监听事件
    @Component
    public class UserEventListener {
        
        @EventListener
        public void handleUserRegistered(UserRegisteredEvent event) {
            System.out.println("用户注册: " + event.getUser().getName());
            // 发送欢迎邮件
            sendWelcomeEmail(event.getUser());
        }
        
        @EventListener
        @Async  // 异步处理
        public void handleUserRegisteredAsync(UserRegisteredEvent event) {
            // 异步处理逻辑
        }
        
        @EventListener(condition = "#event.user.vip == true")
        public void handleVipUser(UserRegisteredEvent event) {
            // 仅处理VIP用户
            sendVipWelcomeGift(event.getUser());
        }
    }
    
    // 4. 内置容器事件
    @Component
    public class ContainerEventListener {
        
        // 容器刷新事件
        @EventListener
        public void handleContextRefreshed(ContextRefreshedEvent event) {
            System.out.println("容器刷新完成");
        }
        
        // 容器启动事件
        @EventListener
        public void handleContextStarted(ContextStartedEvent event) {
            System.out.println("容器启动");
        }
        
        // 容器停止事件
        @EventListener
        public void handleContextStopped(ContextStoppedEvent event) {
            System.out.println("容器停止");
        }
        
        // 容器关闭事件
        @EventListener
        public void handleContextClosed(ContextClosedEvent event) {
            System.out.println("容器关闭");
        }
    }
}
```

## 八、容器性能与调优

### 8.1 延迟初始化
```java
// 配置延迟初始化
@Configuration
public class LazyConfig {
    
    // 单个Bean延迟
    @Bean
    @Lazy
    public ExpensiveService expensiveService() {
        // 首次使用时才初始化
        return new ExpensiveService();
    }
    
    // 配置类级别延迟
    @Configuration
    @Lazy
    public class LazyConfiguration {
        @Bean
        public ServiceA serviceA() {
            return new ServiceA();  // 延迟初始化
        }
    }
}

// 全局延迟初始化（Spring Boot）
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.setLazyInitialization(true);  // 全局延迟
        app.run(args);
    }
}

// 配置文件设置
spring.main.lazy-initialization=true
```

### 8.2 Bean 预实例化优化
```java
// 优化策略
@Configuration
public class BeanOptimization {
    
    // 1. 避免循环依赖（三种解决方案）
    
    // 方案A：使用setter注入代替构造器注入
    @Service
    public class ServiceA {
        private ServiceB serviceB;
        
        @Autowired
        public void setServiceB(ServiceB serviceB) {
            this.serviceB = serviceB;
        }
    }
    
    // 方案B：使用@Lazy打破循环
    @Service
    public class ServiceC {
        private final ServiceD serviceD;
        
        @Autowired
        public ServiceC(@Lazy ServiceD serviceD) {
            this.serviceD = serviceD;
        }
    }
    
    // 方案C：使用@DependsOn明确依赖顺序
    @Service
    @DependsOn("serviceF")
    public class ServiceE {
        // 确保serviceF先初始化
    }
    
    // 2. 合理使用原型作用域
    @Scope("prototype")
    @Component
    public class PrototypeBean {
        // 有状态的Bean使用原型
    }
    
    // 3. 避免在Bean初始化时进行耗时操作
    @Component
    public class FastInitializingBean {
        
        @PostConstruct
        public void init() {
            // 快速初始化
            // 耗时操作移到业务方法中
        }
    }
}
```

## 九、容器调试与监控

### 9.1 容器状态检查
```java
// 获取容器信息
@Component
public class ContainerInspector implements ApplicationContextAware {
    
    private ApplicationContext context;
    
    @Override
    public void setApplicationContext(ApplicationContext context) {
        this.context = context;
        inspectContainer();
    }
    
    private void inspectContainer() {
        // 1. 获取所有Bean名称
        String[] beanNames = context.getBeanDefinitionNames();
        System.out.println("容器中Bean数量: " + beanNames.length);
        
        // 2. 获取Bean详细信息
        for (String beanName : beanNames) {
            BeanDefinition bd = ((ConfigurableApplicationContext) context)
                .getBeanFactory().getBeanDefinition(beanName);
            
            System.out.println("Bean: " + beanName);
            System.out.println("  - 类型: " + bd.getBeanClassName());
            System.out.println("  - 作用域: " + bd.getScope());
            System.out.println("  - 延迟: " + bd.isLazyInit());
        }
        
        // 3. 获取父容器
        ApplicationContext parent = context.getParent();
        if (parent != null) {
            System.out.println("存在父容器: " + parent.getId());
        }
        
        // 4. 检查环境
        Environment env = context.getEnvironment();
        System.out.println("激活的Profile: " + Arrays.toString(env.getActiveProfiles()));
    }
}
```

### 9.2 使用 Actuator 监控
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: beans, env, health, info, metrics
  endpoint:
    beans:
      enabled: true
    env:
      enabled: true
```

访问端点：
- `/actuator/beans` - 查看所有Bean
- `/actuator/env` - 查看环境配置
- `/actuator/health` - 健康检查
- `/actuator/metrics` - 性能指标

## 十、总结

### Spring 容器的核心价值：
1. **控制反转（IoC）**：对象创建和依赖管理交给容器
2. **依赖注入（DI）**：通过构造器、Setter、字段等方式注入依赖
3. **生命周期管理**：完整的Bean生命周期回调
4. **AOP集成**：无缝集成面向切面编程
5. **事件机制**：基于观察者模式的事件系统
6. **国际化和资源访问**：统一的资源管理

### 容器选择建议：
1. **新项目**：使用 `ApplicationContext`（特别是 `AnnotationConfigApplicationContext`）
2. **Web项目**：使用 `WebApplicationContext`
3. **Spring Boot**：使用自动配置的容器
4. **需要精细控制**：使用 `DefaultListableBeanFactory`
5. **测试环境**：使用 `GenericApplicationContext`

### 一句话总结：
**Spring 容器是一个强大的对象工厂和依赖管理器，它通过 IoC 和 DI 实现了松耦合，通过生命周期管理和 AOP 提供了企业级功能，是现代 Java 应用开发的基石。**
