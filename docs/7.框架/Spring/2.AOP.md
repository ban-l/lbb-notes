# Spring AOP

Spring AOP（面向切面编程）是Spring框架的核心模块之一，它通过**横向抽取**的方式解决了代码重复和关注点分离的问题。

## 一、AOP核心概念

### 1.1 什么是AOP？
- **纵向继承**：传统OOP的代码复用方式（继承体系）
- **横向抽取**：AOP的代码复用方式（将横切关注点独立出来）

**示例场景**：多个业务方法都需要日志记录、事务管理、安全检查
```java
// 传统OOP方式：代码重复
class UserService {
    public void createUser() {
        log.info("开始创建用户"); // 横切关注点
        tx.begin();              // 横切关注点
        try {
            // 业务逻辑
            tx.commit();
        } catch (Exception e) {
            tx.rollback();
        }
        log.info("创建用户结束"); // 横切关注点
    }
    
    public void updateUser() {
        log.info("开始更新用户"); // 重复！
        tx.begin();              // 重复！
        // ...
    }
}

// AOP方式：横切关注点被抽取
class UserService {
    public void createUser() {
        // 只关注业务逻辑
    }
    public void updateUser() {
        // 只关注业务逻辑
    }
}
```

### 1.2 AOP核心术语

| 术语                                     | 解释                                     | 示例                                 |
| ---------------------------------------- | ---------------------------------------- | ------------------------------------ |
| **Cross-Cutting Concerns（横切关注点）** | 重复出现、与业务逻辑无直接关系的功能     | 日志，事物，监控等                   |
| **Aspect（切面）**                       | 横切关注点的模块化（如日志、事务模块）   | `@Aspect`注解的类                    |
| **Join Point（连接点）**                 | 程序执行过程中的点（方法调用、异常处理） | `UserService.createUser()`方法执行时 |
| **Advice（通知）**                       | 在特定连接点执行的动作                   | `@Before`、`@Around`等               |
| **Pointcut（切点）**                     | 匹配连接点的表达式                       | `execution(* com.service.*.*(..))`   |
| **Target Object（目标对象）**            | 被一个或多个切面通知的对象               | `UserService`实例                    |
| **Weaving（织入）**                      | 将切面应用到目标对象创建新代理对象的过程 | 编译期、类加载期、运行期             |
| **Proxy（代理）**                        | AOP框架创建的对象，包含切面逻辑          | JDK动态代理或CGLIB代理               |

## 二、Spring AOP实现原理

### 2.1 代理模式
Spring AOP底层使用**代理模式**实现：

```java
// 1. JDK动态代理（基于接口）
public interface UserService {
    void createUser();
}

public class UserServiceImpl implements UserService {
    public void createUser() {
        System.out.println("创建用户");
    }
}

// JDK动态代理创建过程
UserService proxy = (UserService) Proxy.newProxyInstance(
    classLoader,
    new Class[]{UserService.class}, // 必须基于接口
    new InvocationHandler() {
        private UserService target = new UserServiceImpl();
        
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            // 前置增强
            System.out.println("日志记录");
            // 调用目标方法
            Object result = method.invoke(target, args);
            // 后置增强
            System.out.println("事务提交");
            return result;
        }
    }
);

// 2. CGLIB代理（基于类继承）
public class UserService {  // 没有接口
    public void createUser() {
        System.out.println("创建用户");
    }
}

// CGLIB通过继承创建代理类
public class UserService$$EnhancerByCGLIB extends UserService {
    private MethodInterceptor interceptor;
    
    public void createUser() {
        // 调用拦截器
        interceptor.intercept(this, method, args, methodProxy);
    }
}
```

### 2.2 Spring AOP织入时机
- **编译时织入**：AspectJ编译器（需要特殊编译器）
- **类加载时织入**：AspectJ LTW（Load Time Weaving）
- **运行时织入**：**Spring AOP默认方式**（动态代理）

## 三、Spring AOP通知类型

1. 前置通知 - 方法执行前
2. 后置通知 - 方法正常返回后
3. 异常通知 - 方法抛出异常后
4. 最终通知 - 方法结束后（无论正常还是异常）
5. 环绕通知 - 最强大的通知类型

## 四、切点表达式详解

### 4.1 AspectJ切点表达式语法

```java
// 1. execution - 最常用的表达式
@Pointcut("execution(public * com.example.service.*.*(..))")
// 解释：任意返回类型 com.example.service包下任意类的任意public方法，参数任意

// 2. within - 匹配类型
@Pointcut("within(com.example.service.*)")       // service包下所有类
@Pointcut("within(com.example.service..*)")      // service包及其子包下所有类
@Pointcut("within(@org.springframework.stereotype.Service *)") // 所有@Service注解的类

// 3. this - 代理对象匹配
@Pointcut("this(com.example.service.UserService)") // 代理对象是UserService类型

// 4. target - 目标对象匹配
@Pointcut("target(com.example.service.UserService)") // 目标对象是UserService类型

// 5. args - 参数匹配
@Pointcut("args(java.lang.String, int)") // 匹配两个参数：String和int
@Pointcut("args(name, age)")            // 绑定参数到通知方法
public void userArgs(String name, int age) {}

@Before("userArgs(name, age)")
public void logArgs(String name, int age) {
    log.info("参数：name={}, age={}", name, age);
}

// 6. @annotation - 注解匹配
@Pointcut("@annotation(org.springframework.transaction.annotation.Transactional)")
@Pointcut("@annotation(com.example.annotation.Audit)")

// 7. @within - 类级别注解
@Pointcut("@within(org.springframework.stereotype.Service)")

// 8. @args - 参数注解匹配
@Pointcut("@args(com.example.annotation.Validated)")

// 9. bean - Spring Bean名称匹配（Spring特有）
@Pointcut("bean(userService)")          // 名为userService的Bean
@Pointcut("bean(*Service)")             // 所有以Service结尾的Bean
```

### 4.2 组合切点表达式

```java
// 逻辑运算符
@Pointcut("execution(* com.example.service.*.*(..)) && args(String)")
public void serviceMethodsWithStringArg() {}

@Pointcut("serviceLayer() || daoLayer()")
public void businessLayer() {}

@Pointcut("serviceLayer() && !transactionalMethods()")
public void serviceMethodsWithoutTx() {}

// 实际应用示例
@Pointcut("@within(org.springframework.web.bind.annotation.RestController)")
public void restController() {}

@Pointcut("execution(public * *(..))")
public void publicMethod() {}

@Pointcut("restController() && publicMethod()")
public void restControllerPublicMethod() {}

@Around("restControllerPublicMethod()")
public Object handleRestController(ProceedingJoinPoint joinPoint) throws Throwable {
    // 统一处理RestController的公共方法
    return joinPoint.proceed();
}
```

## 五、通知执行顺序

```java
@Aspect
@Order(1)  // 多个切面的执行顺序，值越小优先级越高
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore() {
        System.out.println("LoggingAspect - Before");
    }
}

@Aspect
@Order(2)
public class TransactionAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void beginTransaction() {
        System.out.println("TransactionAspect - Before");
    }
}

// 执行顺序：
// 1. LoggingAspect @Before（Order=1）
// 2. TransactionAspect @Before（Order=2）
// 3. 目标方法
// 4. TransactionAspect @After/AfterReturning（逆序）
// 5. LoggingAspect @After/AfterReturning（逆序）
```

## 六、Spring AOP与AspectJ对比

| 特性           | Spring AOP       | AspectJ                   |
| -------------- | ---------------- | ------------------------- |
| **实现方式**   | 运行时动态代理   | 编译时/类加载时织入       |
| **织入时机**   | 运行时           | 编译期、类加载期、运行期  |
| **性能**       | 运行时开销       | 无运行时开销              |
| **功能范围**   | 仅方法级别拦截   | 方法、构造器、字段访问等  |
| **依赖**       | Spring容器       | 独立（可脱离Spring使用）  |
| **配置**       | 简单（注解/XML） | 复杂（需要AspectJ编译器） |
| **对目标要求** | 需要Spring Bean  | 任意Java对象              |

## 七、Spring AOP最佳实践

### 7.1 应用场景

1. 日志记录(调用方法后记录日志)
2. 事务管理(调用方法前开启事务，调用方法后提交关闭事务 )
3. 权限控制(调用方法前校验是否有权限)
4. 监控性能(统计方法运行时间)
5. 缓存优化(第一次调用查询数据库，将查询结果缓存， 第二次调用，直接返回缓存，不需要查询数据库 )

```java
// 1. 日志记录
@Aspect
@Component
@Slf4j
public class LoggingAspect {
    @Around("@within(org.springframework.web.bind.annotation.RestController)")
    public Object logRestController(ProceedingJoinPoint joinPoint) throws Throwable {
        // 统一日志记录
    }
}

// 2. 事务管理（Spring已内置）
@EnableTransactionManagement
@Configuration
public class TransactionConfig {
    // Spring自动提供@Transactional支持
}

// 3. 权限控制
@Aspect
@Component
public class SecurityAspect {
    @Before("@annotation(RequiresPermission)")
    public void checkPermission(JoinPoint joinPoint) {
        // 权限校验逻辑
    }
}

// 4. 性能监控
@Aspect
@Component
public class PerformanceAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long duration = System.currentTimeMillis() - start;
        
        if (duration > 1000) {  // 超过1秒警告
            log.warn("方法 {} 执行过慢: {}ms", 
                    joinPoint.getSignature().getName(), duration);
        }
        return result;
    }
}

// 5. 缓存处理
@Aspect
@Component
public class CacheAspect {
    @Around("@annotation(Cacheable)")
    public Object handleCache(ProceedingJoinPoint joinPoint) throws Throwable {
        // 缓存逻辑
    }
}
```

### 7.2 常见陷阱与解决方案

```java
// 陷阱1：final方法或类无法被代理
public final class FinalService {  // 无法被CGLIB代理
    public void service() {}
}

// 解决方案：避免使用final，或使用接口+JDK代理

// 陷阱2：private方法无法被拦截
@Service
public class UserService {
    private void privateMethod() {  // AOP无法拦截
        // ...
    }
}

// 陷阱3：自调用问题
// 陷阱4：异常被"吃掉"
@Aspect
@Component
public class ProblematicAspect {
    @Around("execution(* com.example.service.*.*(..))")
    public Object problematicAdvice(ProceedingJoinPoint joinPoint) {
        try {
            return joinPoint.proceed();
        } catch (Exception e) {
            // 没有重新抛出异常！
            return null;  // 异常被隐藏了
        }
    }
}

// 正确做法：重新抛出或处理异常
@Around("execution(* com.example.service.*.*(..))")
public Object correctAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
    try {
        return joinPoint.proceed();
    } catch (BusinessException e) {
        // 处理业务异常
        throw new CustomException("业务异常", e);
    }
    // 其他异常会自动传播
}
```

## 八、Spring AOP配置方式

### 8.1 注解配置（推荐）
```java
@Configuration
@EnableAspectJAutoProxy(
    proxyTargetClass = true,  // 强制使用CGLIB代理
    exposeProxy = true        // 暴露AopContext代理
)
@ComponentScan("com.example")
public class AppConfig {
}
```

### 8.2 XML配置
```xml
<!-- 启用AspectJ自动代理 -->
<aop:aspectj-autoproxy proxy-target-class="true"/>

<!-- 定义Aspect Bean -->
<bean id="loggingAspect" class="com.example.aspect.LoggingAspect"/>

<!-- 或使用AOP Schema配置 -->
<aop:config>
    <aop:aspect id="logAspect" ref="loggingAspect">
        <aop:pointcut id="serviceMethods" 
                      expression="execution(* com.example.service.*.*(..))"/>
        <aop:before pointcut-ref="serviceMethods" method="logBefore"/>
    </aop:aspect>
</aop:config>
```

### 8.3 纯Java配置
```java
@Configuration
public class AopConfig {
    
    @Bean
    public LoggingAspect loggingAspect() {
        return new LoggingAspect();
    }
    
    @Bean
    public TransactionAspect transactionAspect() {
        return new TransactionAspect();
    }
    
    // 手动配置AOP代理
    @Bean
    public DefaultAdvisorAutoProxyCreator proxyCreator() {
        DefaultAdvisorAutoProxyCreator creator = new DefaultAdvisorAutoProxyCreator();
        creator.setProxyTargetClass(true);
        return creator;
    }
}
```

## 总结

Spring AOP通过代理模式实现了横切关注点的模块化，主要特点：
1. **基于代理**：JDK动态代理或CGLIB代理
2. **方法级拦截**：只能拦截方法执行
3. **运行时织入**：性能开销在可接受范围
4. **与Spring集成**：完美整合Spring生态

**使用建议**：
- 对于简单的横切关注点（日志、事务、安全），使用Spring AOP
- 对于需要字段拦截、构造器拦截等复杂场景，考虑AspectJ
- 注意代理内部调用问题
- 合理设计切点表达式，避免过度拦截

Spring AOP是Spring框架实现声明式编程（如`@Transactional`）的基础，理解其原理对于掌握Spring框架至关重要。 
