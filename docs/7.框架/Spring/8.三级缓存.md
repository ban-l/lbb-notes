# Spring 三级缓存机制

## 一、三级缓存是什么？

**三级缓存是Spring为了解决Setter/字段注入的循环依赖而设计的特殊缓存机制**。

它通过在Bean创建的不同阶段保存不同状态的对象引用来打破循环依赖的死锁。

## 二、三级缓存的具体内容

### 第一级缓存：**singletonObjects**

- **存放内容**：完全初始化好的单例Bean
- **状态**：Bean已创建完成，所有依赖已注入，初始化方法已执行
- **特点**：这是最终形态的Bean，可以直接使用

### 第二级缓存：**earlySingletonObjects**

- **存放内容**：早期暴露的Bean引用（半成品）
- **状态**：Bean已实例化，但依赖可能未完全注入，初始化方法未执行
- **特点**：用于解决循环依赖时的临时引用

### 第三级缓存：**singletonFactories**

- **存放内容**：Bean的ObjectFactory工厂对象
- **状态**：可以生产早期Bean引用的工厂
- **特点**：这是**最关键**的一级缓存，支持AOP代理

## 三、工作流程（以A依赖B，B依赖A为例）

### 步骤1：开始创建A

1. 标记A为"创建中"
2. 实例化A（调用构造器）
3. **将A的ObjectFactory放入三级缓存**
   - 这个工厂可以返回A的早期引用（原始对象或代理对象）

### 步骤2：A需要注入B

4. 发现A依赖B，开始创建B
5. 实例化B（调用构造器）
6. **将B的ObjectFactory放入三级缓存**

### 步骤3：B需要注入A

7. 发现B依赖A
8. **从三级缓存获取A的ObjectFactory**
9. **执行工厂的getObject()方法**，得到A的早期引用
10. **将A的早期引用放入二级缓存**，并从三级缓存移除
11. 将A的早期引用注入到B

### 步骤4：完成B的创建

12. 完成B的属性注入和初始化
13. **将B放入一级缓存**

### 步骤5：完成A的创建

14. B返回给A，完成A的属性注入
15. 完成A的初始化
16. **将A从二级缓存移除，放入一级缓存**

## 四、为什么需要三级而不是两级？

### 关键原因：**支持AOP代理**

如果没有三级缓存：

- A如果需要AOP代理，在创建早期引用时就需要生成代理
- 但AOP代理的生成需要完整的Bean信息
- 这可能导致代理逻辑执行多次，不一致

**三级缓存的精妙之处**：

```java
// singletonFactory的lambda表达式是关键
singletonFactories.put(beanName, () -> {
    // 只有真正需要解决循环依赖时，才会执行这里
    // 可以在这里生成代理对象
    return getEarlyBeanReference(beanName, bean);
});
```

**这样保证了**：

1. 普通Bean：直接从三级缓存获取早期引用
2. 需要AOP的Bean：通过工厂动态生成代理
3. 只生成一次：工厂逻辑只会在第一次获取时执行

## 五、什么情况下三级缓存失效？

### 1. **构造器循环依赖**（无法解决）

- 原因：构造器注入时，Bean还没实例化完成，无法放入三级缓存
- 结果：无法获取早期引用，直接报错

### 2. **原型(prototype)作用域**（无法解决）

- 原因：原型Bean不放入缓存，每次都是新实例
- 结果：无法共享早期引用

### 3. **多线程并发创建同一个Bean**

- Spring有同步机制保护，但复杂场景可能有问题

## 六、简单记忆法

**三级缓存可以理解为"Bean成长三阶段"：**

1. **孕育期**（三级缓存）：只有"受精卵"（工厂），能发育成Bean
2. **成长期**（二级缓存）："胎儿"状态（早期引用），不完整但可用
3. **成熟期**（一级缓存）："成年人"状态（完整Bean），功能完备

**循环依赖的解决就像"先借钱后还债"**：

- A创建时需要B → B创建时需要A
- A说："我先打个借条（三级缓存）"
- B拿着借条找A要钱 → A先给一部分（二级缓存）
- B拿到钱后还给A → A用这钱完成自己的事
- 最后双方都还清债务（一级缓存）

## 七、总结要点

1. **核心目的**：解决Setter/字段注入的循环依赖
2. **关键机制**：通过ObjectFactory延迟生成早期引用，支持AOP
3. **工作时机**：只在发生循环依赖时触发
4. **设计精妙**：将Bean创建与依赖注入解耦
5. **局限性**：无法解决构造器循环依赖和原型Bean循环依赖

**一句话理解**：**三级缓存通过"先借后还"的方式，让互相依赖的Bean能够分期完成创建，从而打破循环依赖的死锁。**

## 三级缓存机制代码示例详解

### 一、模拟Spring三级缓存的完整实现

```java
import java.lang.reflect.Constructor;
import java.util.*;

// 模拟Spring的三级缓存容器
public class ThreeLevelCacheContainer {
    
    // ============ 三级缓存定义 ============
    
    // 一级缓存：完整单例Bean
    private final Map<String, Object> singletonObjects = new HashMap<>();
    
    // 二级缓存：早期Bean引用
    private final Map<String, Object> earlySingletonObjects = new HashMap<>();
    
    // 三级缓存：Bean工厂
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>();
    
    // 正在创建的Bean集合
    private final Set<String> singletonsCurrentlyInCreation = new HashSet<>();
    
    // Bean定义注册表
    private final Map<String, BeanDefinition> beanDefinitions = new HashMap<>();
    
    // ============ 核心方法实现 ============
    
    /**
     * 获取Bean的核心方法
     */
    public Object getBean(String beanName) {
        // 1. 先从一级缓存获取
        Object bean = singletonObjects.get(beanName);
        if (bean != null) {
            return bean;
        }
        
        // 2. 如果Bean正在创建中，说明可能发生循环依赖
        if (singletonsCurrentlyInCreation.contains(beanName)) {
            // 尝试从二级缓存获取
            bean = earlySingletonObjects.get(beanName);
            if (bean != null) {
                System.out.println("【循环依赖解决】从二级缓存获取早期Bean: " + beanName);
                return bean;
            }
            
            // 从三级缓存获取工厂并创建早期引用
            ObjectFactory<?> factory = singletonFactories.get(beanName);
            if (factory != null) {
                bean = factory.getObject();
                System.out.println("【循环依赖解决】从三级缓存创建早期Bean: " + beanName);
                // 放入二级缓存，移除三级缓存
                earlySingletonObjects.put(beanName, bean);
                singletonFactories.remove(beanName);
                return bean;
            }
        }
        
        // 3. 创建Bean
        return doCreateBean(beanName);
    }
    
    /**
     * Bean创建的核心流程
     */
    private Object doCreateBean(String beanName) {
        System.out.println("\n====== 开始创建Bean: " + beanName + " ======");
        
        // 标记Bean正在创建
        singletonsCurrentlyInCreation.add(beanName);
        
        // 1. 实例化（分配内存，调用构造器）
        Object bean = createBeanInstance(beanName);
        System.out.println("1. 实例化完成: " + beanName + ", 对象: " + bean.getClass().getSimpleName());
        
        // 2. 将Bean工厂放入三级缓存（解决循环依赖的关键！）
        addSingletonFactory(beanName, () -> {
            System.out.println("  → 三级缓存工厂被调用，生成早期引用: " + beanName);
            return getEarlyBeanReference(beanName, bean);
        });
        
        // 3. 属性填充（依赖注入）
        populateBean(beanName, bean);
        
        // 4. 初始化
        initializeBean(beanName, bean);
        
        // 5. 完成创建，放入一级缓存
        singletonObjects.put(beanName, bean);
        earlySingletonObjects.remove(beanName);
        singletonFactories.remove(beanName);
        singletonsCurrentlyInCreation.remove(beanName);
        
        System.out.println("5. Bean创建完成，放入一级缓存: " + beanName);
        return bean;
    }
    
    /**
     * 添加三级缓存
     */
    private void addSingletonFactory(String beanName, ObjectFactory<?> factory) {
        if (!singletonObjects.containsKey(beanName) && 
            !singletonFactories.containsKey(beanName)) {
            singletonFactories.put(beanName, factory);
            System.out.println("2. 添加三级缓存工厂: " + beanName);
        }
    }
    
    /**
     * 获取早期Bean引用（可扩展AOP代理）
     */
    private Object getEarlyBeanReference(String beanName, Object bean) {
        // 这里可以添加AOP代理逻辑
        // 例如：if (需要代理) { return createProxy(bean); }
        return bean;  // 返回原始对象或代理对象
    }
    
    /**
     * 实例化Bean
     */
    private Object createBeanInstance(String beanName) {
        BeanDefinition bd = beanDefinitions.get(beanName);
        try {
            Class<?> beanClass = Class.forName(bd.getBeanClassName());
            Constructor<?> constructor = beanClass.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor.newInstance();
        } catch (Exception e) {
            throw new RuntimeException("创建Bean实例失败: " + beanName, e);
        }
    }
    
    /**
     * 属性填充（依赖注入）
     */
    private void populateBean(String beanName, Object bean) {
        BeanDefinition bd = beanDefinitions.get(beanName);
        System.out.println("3. 开始属性填充: " + beanName);
        
        for (String refName : bd.getDependsOn()) {
            System.out.println("  → 需要注入依赖: " + refName);
            Object refBean = getBean(refName);  // 递归获取依赖的Bean
            injectDependency(bean, refName, refBean);
        }
    }
    
    /**
     * 依赖注入（通过反射设置字段）
     */
    private void injectDependency(Object bean, String fieldName, Object value) {
        try {
            java.lang.reflect.Field field = bean.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(bean, value);
            System.out.println("    ✓ 注入成功: " + fieldName + " = " + value.getClass().getSimpleName());
        } catch (Exception e) {
            throw new RuntimeException("依赖注入失败", e);
        }
    }
    
    /**
     * 初始化Bean
     */
    private void initializeBean(String beanName, Object bean) {
        System.out.println("4. 执行初始化: " + beanName);
        // 这里可以执行@PostConstruct、InitializingBean等
    }
    
    /**
     * 打印缓存状态
     */
    public void printCacheStatus() {
        System.out.println("\n=== 当前缓存状态 ===");
        System.out.println("一级缓存（完整Bean）: " + singletonObjects.keySet());
        System.out.println("二级缓存（早期引用）: " + earlySingletonObjects.keySet());
        System.out.println("三级缓存（工厂）: " + singletonFactories.keySet());
        System.out.println("正在创建中的Bean: " + singletonsCurrentlyInCreation);
    }
    
    // ============ Bean定义和相关类 ============
    
    static class BeanDefinition {
        private String beanClassName;
        private List<String> dependsOn = new ArrayList<>();
        
        public BeanDefinition(String beanClassName) {
            this.beanClassName = beanClassName;
        }
        
        public void addDependsOn(String beanName) {
            dependsOn.add(beanName);
        }
        
        public String getBeanClassName() { return beanClassName; }
        public List<String> getDependsOn() { return dependsOn; }
    }
    
    @FunctionalInterface
    interface ObjectFactory<T> {
        T getObject();
    }
    
    // ============ 测试用例 ============
    
    public static void main(String[] args) {
        ThreeLevelCacheContainer container = new ThreeLevelCacheContainer();
        
        // 定义循环依赖的Bean
        container.beanDefinitions.put("serviceA", 
            new BeanDefinition("com.example.ServiceA"));
        container.beanDefinitions.get("serviceA").addDependsOn("serviceB");
        
        container.beanDefinitions.put("serviceB", 
            new BeanDefinition("com.example.ServiceB"));
        container.beanDefinitions.get("serviceB").addDependsOn("serviceA");
        
        // 模拟Bean类
        class ServiceA {
            private ServiceB serviceB;
            public ServiceA() { System.out.println("    ServiceA构造器被调用"); }
        }
        
        class ServiceB {
            private ServiceA serviceA;
            public ServiceB() { System.out.println("    ServiceB构造器被调用"); }
        }
        
        // 注册类加载器
        ClassLoader classLoader = new ClassLoader() {
            @Override
            public Class<?> loadClass(String name) throws ClassNotFoundException {
                if (name.equals("com.example.ServiceA")) return ServiceA.class;
                if (name.equals("com.example.ServiceB")) return ServiceB.class;
                return super.loadClass(name);
            }
        };
        
        try {
            // 触发Bean创建
            System.out.println("【测试开始】获取serviceA，触发循环依赖解决流程");
            container.getBean("serviceA");
            
            container.printCacheStatus();
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 二、更直观的简化示例

```java
/**
 * 极简版三级缓存演示
 */
public class SimpleThreeLevelCacheDemo {
    
    // 三级缓存
    static Map<String, Object> cacheLevel1 = new HashMap<>(); // 一级：成品
    static Map<String, Object> cacheLevel2 = new HashMap<>(); // 二级：半成品  
    static Map<String, Supplier<Object>> cacheLevel3 = new HashMap<>(); // 三级：工厂
    
    static Set<String> creatingBeans = new HashSet<>(); // 正在创建的Bean
    
    public static void main(String[] args) {
        System.out.println("=== 演示A和B的循环依赖解决 ===");
        
        // 场景：A依赖B，B依赖A
        // 定义Bean
        class BeanA {
            BeanB b;
            public BeanA() { System.out.println("BeanA实例化"); }
        }
        
        class BeanB {
            BeanA a;
            public BeanB() { System.out.println("BeanB实例化"); }
        }
        
        // 模拟Spring容器行为
        try {
            // 1. 获取BeanA，触发创建流程
            System.out.println("\n1. 获取BeanA:");
            BeanA a = (BeanA) getBean("beanA", BeanA.class);
            
            System.out.println("\n2. 获取BeanB:");
            BeanB b = (BeanB) getBean("beanB", BeanB.class);
            
            System.out.println("\n最终结果：");
            System.out.println("A.b == B? " + (a.b == b));
            System.out.println("B.a == A? " + (b.a == a));
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    static Object getBean(String name, Class<?> beanClass) throws Exception {
        System.out.println("  尝试获取Bean: " + name);
        
        // 检查一级缓存
        if (cacheLevel1.containsKey(name)) {
            System.out.println("  √ 从一级缓存获取: " + name);
            return cacheLevel1.get(name);
        }
        
        // 如果正在创建，说明有循环依赖
        if (creatingBeans.contains(name)) {
            System.out.println("  ⚠️ " + name + "正在创建中，检测到循环依赖");
            
            // 检查二级缓存
            if (cacheLevel2.containsKey(name)) {
                System.out.println("  √ 从二级缓存获取早期引用: " + name);
                return cacheLevel2.get(name);
            }
            
            // 检查三级缓存
            if (cacheLevel3.containsKey(name)) {
                System.out.println("  √ 从三级缓存工厂创建早期引用: " + name);
                Object bean = cacheLevel3.get(name).get();
                cacheLevel2.put(name, bean);  // 升级到二级缓存
                cacheLevel3.remove(name);     // 移除三级缓存
                return bean;
            }
        }
        
        // 创建Bean
        return createBean(name, beanClass);
    }
    
    static Object createBean(String name, Class<?> beanClass) throws Exception {
        System.out.println("  ┌─ 开始创建Bean: " + name);
        creatingBeans.add(name);
        
        // 1. 实例化
        Object bean = beanClass.newInstance();
        System.out.println("  │  实例化完成");
        
        // 2. 放入三级缓存（关键步骤！）
        cacheLevel3.put(name, () -> {
            System.out.println("  │  【三级缓存工厂被调用】生成" + name + "的早期引用");
            return bean;  // 可以在这里添加AOP代理逻辑
        });
        System.out.println("  │  已放入三级缓存");
        
        // 3. 属性填充（这里简化，直接模拟依赖注入）
        if ("beanA".equals(name)) {
            // A需要B
            System.out.println("  │  A需要注入B...");
            BeanB b = (BeanB) getBean("beanB", Class.forName("SimpleThreeLevelCacheDemo$1BeanB"));
            java.lang.reflect.Field field = bean.getClass().getDeclaredField("b");
            field.setAccessible(true);
            field.set(bean, b);
            System.out.println("  │  A成功注入B");
        } else if ("beanB".equals(name)) {
            // B需要A
            System.out.println("  │  B需要注入A...");
            BeanA a = (BeanA) getBean("beanA", Class.forName("SimpleThreeLevelCacheDemo$1BeanA"));
            java.lang.reflect.Field field = bean.getClass().getDeclaredField("a");
            field.setAccessible(true);
            field.set(bean, a);
            System.out.println("  │  B成功注入A");
        }
        
        // 4. 初始化
        System.out.println("  │  执行初始化");
        
        // 5. 完成，放入一级缓存
        cacheLevel1.put(name, bean);
        cacheLevel2.remove(name);
        cacheLevel3.remove(name);
        creatingBeans.remove(name);
        
        System.out.println("  └─ 创建完成，放入一级缓存: " + name);
        return bean;
    }
}
```

### 三、带AOP代理的三级缓存示例

```java
/**
 * 演示包含AOP代理的三级缓存
 */
public class ThreeLevelCacheWithAOP {
    
    static class Container {
        Map<String, Object> singletonObjects = new HashMap<>();
        Map<String, Object> earlySingletonObjects = new HashMap<>();
        Map<String, Supplier<Object>> singletonFactories = new HashMap<>();
        Set<String> creating = new HashSet<>();
        
        // AOP相关：记录哪些Bean需要代理
        Set<String> needProxyBeans = new HashSet<>();
        
        public Object getBean(String name) throws Exception {
            // 一级缓存检查
            Object bean = singletonObjects.get(name);
            if (bean != null) return bean;
            
            // 循环依赖处理
            if (creating.contains(name)) {
                bean = earlySingletonObjects.get(name);
                if (bean != null) {
                    System.out.println("【解决循环依赖】从二级缓存获取: " + name);
                    return bean;
                }
                
                Supplier<Object> factory = singletonFactories.get(name);
                if (factory != null) {
                    System.out.println("【解决循环依赖】三级缓存工厂生成: " + name + 
                                     (needProxyBeans.contains(name) ? " (需要代理)" : ""));
                    bean = factory.get();
                    earlySingletonObjects.put(name, bean);
                    singletonFactories.remove(name);
                    return bean;
                }
            }
            
            return doCreateBean(name);
        }
        
        private Object doCreateBean(String name) throws Exception {
            System.out.println("\n>>> 开始创建: " + name);
            creating.add(name);
            
            // 实例化原始对象
            Object rawBean = new Object();  // 简化，实际通过反射创建
            System.out.println("1. 实例化原始对象");
            
            // 放入三级缓存（关键！）
            singletonFactories.put(name, () -> {
                System.out.println("    【工厂回调】为 " + name + "创建早期引用");
                if (needProxyBeans.contains(name)) {
                    System.out.println("    【AOP代理】创建代理对象");
                    return createProxy(rawBean);  // 如果需要代理，创建代理
                }
                return rawBean;  // 否则返回原始对象
            });
            System.out.println("2. 工厂放入三级缓存");
            
            // 属性填充（模拟）
            System.out.println("3. 属性填充");
            if ("serviceA".equals(name)) {
                // A依赖B
                System.out.println("   A需要B，获取B...");
                Object b = getBean("serviceB");
                System.out.println("   A成功注入B");
            } else if ("serviceB".equals(name)) {
                // B依赖A
                System.out.println("   B需要A，获取A...");
                Object a = getBean("serviceA");
                System.out.println("   B成功注入A");
            }
            
            // 初始化后处理（AOP代理通常在这里创建）
            System.out.println("4. 初始化后处理");
            Object finalBean = rawBean;
            if (needProxyBeans.contains(name) && !earlySingletonObjects.containsKey(name)) {
                // 如果没有在三级缓存中创建代理，现在创建
                System.out.println("   【AOP】创建最终代理");
                finalBean = createProxy(rawBean);
            }
            
            // 完成
            singletonObjects.put(name, finalBean);
            earlySingletonObjects.remove(name);
            singletonFactories.remove(name);
            creating.remove(name);
            
            System.out.println("5. 完成，放入一级缓存: " + name);
            return finalBean;
        }
        
        private Object createProxy(Object target) {
            // 模拟创建代理
            return "Proxy[" + target + "]";
        }
    }
    
    public static void main(String[] args) throws Exception {
        Container container = new Container();
        
        // 设置serviceA需要AOP代理
        container.needProxyBeans.add("serviceA");
        
        System.out.println("=== 测试带AOP的循环依赖 ===");
        System.out.println("serviceA需要AOP代理，serviceB不需要");
        
        // 触发创建
        Object a = container.getBean("serviceA");
        System.out.println("\n最终得到的serviceA: " + a);
        
        // 打印缓存状态
        System.out.println("\n缓存状态:");
        System.out.println("一级缓存: " + container.singletonObjects.keySet());
        System.out.println("二级缓存: " + container.earlySingletonObjects.keySet());
        System.out.println("三级缓存: " + container.singletonFactories.keySet());
    }
}
```

### 四、循环依赖解决流程可视化

```java
/**
 * 循环依赖解决流程的步骤演示
 */
public class CircularDependencyFlow {
    
    public static void main(String[] args) {
        System.out.println("========== 循环依赖解决全流程 ==========\n");
        
        // 模拟场景：ServiceA ←→ ServiceB 互相依赖
        
        step1();
        step2();
        step3();
        step4();
        step5();
        
        System.out.println("\n========== 流程结束 ==========");
    }
    
    static void step1() {
        System.out.println("【步骤1】获取ServiceA，开始创建流程");
        System.out.println("  1. 检查一级缓存 → 无");
        System.out.println("  2. 标记ServiceA为'创建中'");
        System.out.println("  3. 实例化ServiceA原始对象");
        System.out.println("  4. 【关键】将ServiceA的工厂放入三级缓存");
        System.out.println("     三级缓存现在: {serviceA=Factory}");
    }
    
    static void step2() {
        System.out.println("\n【步骤2】ServiceA需要注入ServiceB");
        System.out.println("  1. 开始创建ServiceB");
        System.out.println("  2. 标记ServiceB为'创建中'");
        System.out.println("  3. 实例化ServiceB原始对象");
        System.out.println("  4. 将ServiceB的工厂放入三级缓存");
        System.out.println("     三级缓存现在: {serviceA=Factory, serviceB=Factory}");
    }
    
    static void step3() {
        System.out.println("\n【步骤3】ServiceB需要注入ServiceA（循环依赖发生！）");
        System.out.println("  1. 发现ServiceA正在创建中");
        System.out.println("  2. 检查二级缓存 → 无");
        System.out.println("  3. 检查三级缓存 → 找到ServiceA的工厂");
        System.out.println("  4. 执行工厂方法，获取ServiceA的早期引用");
        System.out.println("  5. 将早期引用放入二级缓存，移除三级缓存");
        System.out.println("     二级缓存现在: {serviceA=EarlyBean}");
        System.out.println("     三级缓存现在: {serviceB=Factory}");
    }
    
    static void step4() {
        System.out.println("\n【步骤4】ServiceB完成创建");
        System.out.println("  1. 将ServiceB的早期引用注入到ServiceA");
        System.out.println("  2. 完成ServiceB的初始化");
        System.out.println("  3. 将ServiceB放入一级缓存");
        System.out.println("     一级缓存现在: {serviceB=CompleteBean}");
        System.out.println("     二级缓存现在: {serviceA=EarlyBean}");
        System.out.println("     三级缓存现在: {}");
    }
    
    static void step5() {
        System.out.println("\n【步骤5】ServiceA完成创建");
        System.out.println("  1. 从二级缓存获取ServiceA的早期引用");
        System.out.println("  2. 注入ServiceB（已在一级缓存）");
        System.out.println("  3. 完成ServiceA的初始化");
        System.out.println("  4. 将ServiceA放入一级缓存，清理其他缓存");
        System.out.println("     一级缓存现在: {serviceA=CompleteBean, serviceB=CompleteBean}");
        System.out.println("     二级缓存现在: {}");
        System.out.println("     三级缓存现在: {}");
    }
}
```

### 五、关键点总结代码

```java
/**
 * 三级缓存机制的关键点总结
 */
public class ThreeLevelCacheKeyPoints {
    
    public static class KeyPoint {
        String title;
        String description;
        String codeExample;
        
        public KeyPoint(String title, String description, String codeExample) {
            this.title = title;
            this.description = description;
            this.codeExample = codeExample;
        }
    }
    
    public static void main(String[] args) {
        List<KeyPoint> points = Arrays.asList(
            new KeyPoint(
                "1. 三级缓存的时机",
                "只有在Bean实例化之后、属性填充之前，才会放入三级缓存",
                """
                // 在doCreateBean方法中：
                Object bean = instantiateBean(beanName);  // 1. 实例化
                addSingletonFactory(beanName, () -> {     // 2. 放入三级缓存（关键时机！）
                    return getEarlyBeanReference(beanName, bean);
                });
                populateBean(beanName, bean);             // 3. 属性填充（可能触发循环依赖）
                """
            ),
            new KeyPoint(
                "2. ObjectFactory的延迟执行",
                "工厂方法只有在发生循环依赖时才会被调用",
                """
                singletonFactories.put(beanName, () -> {
                    // 这个lambda不会立即执行！
                    // 只有当其他Bean需要注入这个Bean时才会执行
                    System.out.println("工厂方法被调用了");
                    return bean;
                });
                """
            ),
            new KeyPoint(
                "3. AOP代理的智能处理",
                "通过三级缓存统一处理普通Bean和代理Bean",
                """
                // getEarlyBeanReference方法中：
                protected Object getEarlyBeanReference(String beanName, Object bean) {
                    Object exposedObject = bean;
                    if (!earlyProxyReferences.contains(beanName) && 
                        isBeanEligibleForAop(beanName)) {
                        // 如果需要AOP，创建代理
                        exposedObject = createAopProxy(bean);
                    }
                    return exposedObject;
                }
                """
            ),
            new KeyPoint(
                "4. 从三级升级到二级缓存",
                "一旦工厂被调用，结果就升级到二级缓存",
                """
                // 在getSingleton方法中：
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    // 调用工厂
                    singletonObject = singletonFactory.getObject();
                    // 升级到二级缓存
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    // 移除三级缓存
                    this.singletonFactories.remove(beanName);
                }
                """
            ),
            new KeyPoint(
                "5. 构造器注入为什么不行",
                "构造器注入发生在实例化之前，没有机会放入三级缓存",
                """
                // 构造器注入流程：
                // 1. 需要先获取依赖才能调用构造器
                // 2. 但依赖的Bean可能也需要这个Bean
                // 3. 形成死锁
                
                // 错误的时序：
                // 创建A → 需要B（调用A的构造器）→ 创建B → 需要A（但A还没实例化）
                // 三级缓存是空的！无法解决
                """
            )
        );
        
        System.out.println("=== 三级缓存机制关键点 ===\n");
        for (KeyPoint point : points) {
            System.out.println("【" + point.title + "】");
            System.out.println(point.description);
            System.out.println("示例：");
            System.out.println(point.codeExample);
            System.out.println("---\n");
        }
    }
}
```

### 总结

通过这些代码示例，我们可以看到：

1. **三级缓存的核心**：`singletonFactories` 存放可以生成早期引用的工厂
2. **解决循环依赖的关键时机**：实例化后立即放入三级缓存
3. **AOP代理的统一处理**：通过工厂方法统一创建原始对象或代理对象
4. **缓存升级机制**：三级 → 二级 → 一级的渐进式升级

**最精简的理解**：

```java
// 伪代码总结
if (发生循环依赖) {
    // 从三级缓存获取工厂
    ObjectFactory factory = singletonFactories.get(beanName);
    // 执行工厂方法获取早期引用（可能是代理）
    Object earlyBean = factory.getObject();
    // 升级到二级缓存
    earlySingletonObjects.put(beanName, earlyBean);
    // 返回给依赖方
    return earlyBean;
}
```

这就是Spring解决Setter/字段注入循环依赖的魔法所在！

