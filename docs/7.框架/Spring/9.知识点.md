# 知识点

## Spring同名bean

- 同一个配置文件内同名的Bean，以最上面定义的为准；
- 不同配置文件中存在同名Bean，后解析的配置文件会覆盖先解析的配置文件；
- @ComponentScan和@Bean出现同名Bean：
  - 同文件下@Bean的会生效；
  - @ComponentScan扫描进来不会生效，优先级是最低的。

## Spring 用到的设计模式

1. 工厂模式：Spring使用工厂模式通过BeanFactory和ApplicationContext创建bean对象。
2. 代理模式：Spring AOP功能的实现。
3. 单例模式：Spring中的bean默认单例。

4. 模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template结尾的对数据库操作的类。
5. 包装器模式：项目需要连接多个数据库，包装器模式让我们可以根据需求能够动态切换不同的数据源。
6. 观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。
7. 适配器模式：Spring AOP的通知（Advice）使用到了适配器模式、Spring MVC中也是用到了适配器模式适配Controller。

## Spring 自动装配

- no：这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。
- byName：它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。
- byType：它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。
- 构造函数：它通过调用类的构造函数来注入依赖项。它有大量的参数。
- autodetect：首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。

## 单例bean线程安全问题

1. 创建单例bean线程安全；

2. 使用单例bean存在线程安全问题，多线程读写全局变量：实例字段、静态字段。

## 无状态bean和有状态bean

有状态就是有数据存储功能：存在实例字段，可以保存数据，是非线程安全的。

无状态就是一次操作，不能保存数据：无实例字段，不能保存数据，是不变类，是线程安全的。

## springmvc拦截器

**Spring MVC拦截器**是在**请求处理流程的特定节点**插入自定义逻辑的组件，用于对HTTP请求进行**预处理、后处理和完成处理**。

拦截器必须实现 HandlerInterceptor 接口。

```java
// 拦截器的核心接口
public interface HandlerInterceptor {
    
    // 1. 预处理：Controller方法执行前
    boolean preHandle(HttpServletRequest request, 
                     HttpServletResponse response, 
                     Object handler);
    
    // 2. 后处理：Controller方法执行后，视图渲染前
    void postHandle(HttpServletRequest request,
                   HttpServletResponse response,
                   Object handler,
                   ModelAndView modelAndView);
    
    // 3. 完成处理：请求完成，视图渲染后
    void afterCompletion(HttpServletRequest request,
                        HttpServletResponse response,
                        Object handler,
                        Exception ex);
}
```

```text
HTTP请求
    ↓
DispatcherServlet
    ↓
【拦截器preHandle】← 预处理
    ↓
HandlerAdapter执行Controller方法
    ↓
【拦截器postHandle】← 后处理（有ModelAndView）
    ↓
ViewResolver解析视图 → 视图渲染
    ↓
【拦截器afterCompletion】← 完成处理（无论成功失败）
    ↓
HTTP响应
```

## @Component和@Bean的区别

作用对象不同。

- @Component注解作用于类
- @Bean注解作用于方法

作用

- @Component注解，通过类路径扫描来自动侦测以及自动装配到Spring容器中（@ComponentScan注解定义扫描路径）

- @Bean注解，通常是在标有该注解的方法中定义产生bean。

@Bean注解的自定义性更强，很多地方只能通过@Bean注解来注册bean。

## 类声明为bean的注解

1. @Component注解。通用注解，可标注任意类为Spring组件。
2. @Repository注解。对应持久层，即Dao层，主要用于数据库相关操作。
3. @Service注解。对应服务层，即Service层，主要涉及一些复杂的逻辑，需要用到Dao层（注入）。
4. @Controller注解。对应Spring MVC的控制层，即Controller层。

## @Controller 注解

**`@Controller`** 是Spring MVC框架中的**核心注解**，用于标记一个Java类作为**Web控制器**（Controller），处理HTTP请求并返回响应。

1. **标记控制器**：告诉Spring这是一个Web控制器组件
2. **请求映射**：将HTTP请求映射到处理方法
3. **参数绑定**：自动绑定请求参数到方法参数
4. **视图解析**：返回视图名称，由视图解析器渲染
5. **模型传递**：向视图传递数据

**关键特性：**

- **与`@Component`同级**：也会被Spring扫描并管理
- **通常与`@RequestMapping`一起使用**：定义URL映射
- **支持方法级注解**：`@GetMapping`, `@PostMapping`等
- **集成验证框架**：支持JSR-303/JSR-380验证
- **灵活的返回类型**：String, ModelAndView, void, ResponseEntity等

## @RequestMapping 注解

**`@RequestMapping`** 是Spring MVC中最核心的注解，用于**将HTTP请求映射到具体的处理器方法**。

它可以标注在类上或方法上，定义URL路径、HTTP方法、请求参数等匹配条件。

**核心功能：**

1. **URL路径映射**

```java
// 类级别：定义基础路径
@RequestMapping("/api/users")
@Controller
public class UserController {
    // 方法级别：组合成完整路径 /api/users/list
    @RequestMapping("/list")
    public String listUsers() {
        return "users";
    }
}
```

2. **HTTP方法映射**

3. **请求参数映射**

4. **请求头映射**

5. **消费/生产类型**

**常用快捷注解（底层还是@RequestMapping）：**

```java
@GetMapping("/users")     // 等价于 @RequestMapping(method = RequestMethod.GET)
@PostMapping("/users")    // 等价于 @RequestMapping(method = RequestMethod.POST)
@PutMapping("/users/{id}")    // 等价于 @RequestMapping(method = RequestMethod.PUT)
@DeleteMapping("/users/{id}") // 等价于 @RequestMapping(method = RequestMethod.DELETE)
@PatchMapping("/users/{id}")  // 等价于 @RequestMapping(method = RequestMethod.PATCH)
```

## @RestController 和 @Controller

**`@Controller` 用于传统的页面渲染Web应用，返回视图名称由模板引擎渲染；**

**`@RestController` 用于RESTful API和前后端分离应用，直接返回数据对象自动转为JSON/XML。**

| 特性         | @Controller                           | @RestController                         |
| :----------- | :------------------------------------ | :-------------------------------------- |
| **本质**     | 传统的MVC控制器                       | @Controller + @ResponseBody 的组合注解  |
| **返回类型** | 返回视图名称（字符串）或 ModelAndView | 直接返回数据对象（自动转为JSON/XML）    |
| **视图解析** | 需要视图解析器（ViewResolver）        | 不需要视图解析器                        |
| **适用场景** | 传统的页面渲染Web应用                 | RESTful API、前后端分离应用             |
| **注解继承** | 单独注解                              | 元注解包含 @Controller 和 @ResponseBody |
| **内容协商** | 通过视图技术渲染HTML                  | 通过HttpMessageConverter转换数据格式    |

##  @RequestParam 和 @PathVariable

**`@PathVariable` 用于获取URL路径中的参数（RESTful资源标识）；**

**`@RequestParam` 用于获取URL查询字符串中的参数（过滤、分页、搜索条件）。**

**路径参数标识"要什么"，查询参数说明"怎么要"。**

| 特性            | @RequestParam          | @PathVariable          |
| :-------------- | :--------------------- | :--------------------- |
| **参数位置**    | URL查询字符串（?后面） | URL路径中（/后面）     |
| **URL格式**     | `/users?id=123`        | `/users/123`           |
| **作用**        | 获取查询参数           | 获取路径参数           |
| **是否必需**    | 默认必需，可设置为可选 | 默认必需               |
| **默认值**      | 可设置默认值           | 不可设置默认值         |
| **参数名匹配**  | 参数名可省略（同名时） | 必须明确指定路径变量名 |
| **多值支持**    | 支持数组/集合          | 单个值                 |
| **RESTful语义** | 过滤、分页、搜索条件   | 资源标识               |