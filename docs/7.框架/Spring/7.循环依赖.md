# 循环依赖

# Spring 循环依赖深度解析

## 一、循环依赖核心概念

### 1.1 什么是循环依赖？
**循环依赖**是指两个或多个Bean相互依赖，形成**依赖环**，导致Spring容器无法确定创建顺序。

```java
// 典型循环依赖示例
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;  // 依赖ServiceB
}

@Component
public class ServiceB {
    @Autowired
    private ServiceA serviceA;  // 依赖ServiceA，形成循环
}

// 更复杂的循环依赖
@Component
public class ServiceC {
    @Autowired
    private ServiceD serviceD;
}

@Component
public class ServiceD {
    @Autowired
    private ServiceE serviceE;
}

@Component
public class ServiceE {
    @Autowired
    private ServiceC serviceC;  // 三级循环依赖
}
```

### 1.2 Spring Bean 创建流程与循环依赖
```java
// Bean创建的关键步骤（简化版）
public Object createBean(String beanName) {
    // 1. 实例化（分配内存空间）
    Object bean = instantiateBean(beanName);
    
    // 2. 属性填充（依赖注入）
    populateBean(beanName, bean);
    
    // 3. 初始化（执行初始化方法）
    initializeBean(beanName, bean);
    
    return bean;
}

// 循环依赖问题产生：
// 创建A → 需要注入B → 创建B → 需要注入A → 但A还在创建中 → 死锁
```

## 二、Spring 解决循环依赖的底层原理

### 2.1 三级缓存机制
```java
// Spring内部使用三级缓存解决循环依赖
public class DefaultSingletonBeanRegistry {
    
    // 一级缓存：单例对象池（完整Bean）
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
    
    // 二级缓存：早期曝光对象（未完成初始化的Bean）
    private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);
    
    // 三级缓存：单例工厂（ObjectFactory）
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);
    
    // 正在创建中的Bean名称集合
    private final Set<String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap<>(16));
}
```

### 2.2 三级缓存工作流程
```java
// 解决循环依赖的完整流程（以ServiceA和ServiceB为例）
public class CircularDependencySolution {
    
    public void createBeanA() {
        // 步骤1：开始创建ServiceA
        // 标记A正在创建
        singletonsCurrentlyInCreation.add("serviceA");
        
        // 步骤2：实例化ServiceA（仅调用构造器，属性未填充）
        Object rawBeanA = instantiateBean("serviceA");
        
        // 步骤3：将ServiceA的工厂放入三级缓存（关键！）
        // 生成ObjectFactory，可以返回原始Bean或代理Bean
        singletonFactories.put("serviceA", () -> {
            // 这个lambda可能被调用多次，需要确保幂等性
            return getEarlyBeanReference("serviceA", rawBeanA);
        });
        
        // 步骤4：属性填充（注入ServiceB）
        // 发现需要注入serviceB
        populateBean("serviceA", rawBeanA);
        
        // 步骤5：获取serviceB（触发ServiceB的创建）
        Object beanB = getBean("serviceB");
        
        // 步骤6：完成A的初始化
        initializeBean("serviceA", rawBeanA);
        
        // 步骤7：从三级缓存移除，放入一级缓存
        singletonObjects.put("serviceA", rawBeanA);
        singletonFactories.remove("serviceA");
        earlySingletonObjects.remove("serviceA");
        
        return rawBeanA;
    }
    
    public void createBeanB() {
        // 步骤1：开始创建ServiceB
        singletonsCurrentlyInCreation.add("serviceB");
        
        // 步骤2：实例化ServiceB
        Object rawBeanB = instantiateBean("serviceB");
        
        // 步骤3：将ServiceB工厂放入三级缓存
        singletonFactories.put("serviceB", () -> getEarlyBeanReference("serviceB", rawBeanB));
        
        // 步骤4：属性填充（需要注入ServiceA）
        // 发现需要serviceA，但serviceA正在创建中
        
        // 步骤5：尝试获取serviceA
        Object beanA = getSingleton("serviceA");  // 核心方法！
        
        // getSingleton("serviceA")内部逻辑：
        // 1. 从一级缓存singletonObjects查找 → 没有（A未完成）
        // 2. 从二级缓存earlySingletonObjects查找 → 没有
        // 3. 从三级缓存singletonFactories获取ObjectFactory
        // 4. 执行ObjectFactory.getObject()获取早期引用
        // 5. 将结果放入二级缓存，从三级缓存移除
        // 6. 返回早期Bean引用
        
        // 步骤6：完成B的初始化
        initializeBean("serviceB", rawBeanB);
        
        // 步骤7：放入一级缓存
        singletonObjects.put("serviceB", rawBeanB);
        
        return rawBeanB;
    }
}
```

## 三、循环依赖的三种类型

### 3.1 构造器循环依赖（无法解决）
```java
// 类型1：构造器注入循环依赖（Spring无法自动解决）
@Component
public class ConstructorA {
    private final ConstructorB constructorB;
    
    // 构造器注入
    @Autowired
    public ConstructorA(ConstructorB constructorB) {
        this.constructorB = constructorB;  // 需要B的实例
    }
}

@Component
public class ConstructorB {
    private final ConstructorA constructorA;
    
    @Autowired
    public ConstructorB(ConstructorA constructorA) {
        this.constructorA = constructorA;  // 需要A的实例
    }
}

// 启动时报错：
// BeanCurrentlyInCreationException: 
// Error creating bean with name 'constructorA': 
// Requested bean is currently in creation: Is there an unsupported circular reference?
```

**为什么构造器循环依赖无法解决？**
```java
// 因为构造器注入发生在实例化阶段
// 创建A → 需要B的实例（但B还没创建）→ 创建B → 需要A的实例（但A还没完成实例化）
// 三级缓存此时还没有A的引用（因为A还没完成实例化）

// 时间线对比：
// 属性注入：实例化 → 放入三级缓存 → 属性注入
// 构造器注入：实例化（需要依赖） → 依赖不满足 → 无法完成实例化
```

### 3.2 Setter/字段循环依赖（可以解决）
```java
// 类型2：Setter注入循环依赖（可以解决）
@Component
public class SetterA {
    private SetterB setterB;
    
    // Setter注入
    @Autowired
    public void setSetterB(SetterB setterB) {
        this.setterB = setterB;
    }
}

@Component
public class SetterB {
    private SetterA setterA;
    
    @Autowired
    public void setSetterA(SetterA setterA) {
        this.setterA = setterA;
    }
}

// Spring可以解决，因为：
// 1. A实例化完成 → 放入三级缓存
// 2. A需要注入B → 创建B
// 3. B实例化完成 → 放入三级缓存  
// 4. B需要注入A → 从三级缓存获取A的早期引用
// 5. B初始化完成 → 返回给A
// 6. A完成注入 → 初始化完成
```

### 3.3 原型Bean循环依赖（无法解决）
```java
// 类型3：原型作用域循环依赖（无法解决）
@Component
@Scope("prototype")  // 原型作用域
public class PrototypeA {
    @Autowired
    private PrototypeB prototypeB;
}

@Component
@Scope("prototype")
public class PrototypeB {
    @Autowired
    private PrototypeA prototypeA;
}

// 报错：BeanCurrentlyInCreationException
// 原因：原型Bean不放入三级缓存，每次都是新实例
```

## 四、循环依赖解决方案

### 4.1 方案1：重新设计（最佳实践）
### 4.2 方案2：使用Setter/字段注入替代构造器注入
```java
// 方案2：将构造器注入改为Setter注入
// 修改前（有循环依赖问题）
@Component
public class ServiceA {
    private final ServiceB serviceB;
    
    @Autowired
    public ServiceA(ServiceB serviceB) {  // 构造器注入
        this.serviceB = serviceB;
    }
}

// 修改后（循环依赖可解决）
@Component
public class ServiceA {
    private ServiceB serviceB;
    
    @Autowired
    public void setServiceB(ServiceB serviceB) {  // Setter注入
        this.serviceB = serviceB;
    }
    
    // 或使用字段注入（不推荐）
    // @Autowired
    // private ServiceB serviceB;
}
```

### 4.3 方案3：使用@Lazy延迟加载
```java
// 方案3：使用@Lazy注解
@Component
public class LazyA {
    private final LazyB lazyB;
    
    // 关键：在构造器参数上使用@Lazy
    @Autowired
    public LazyA(@Lazy LazyB lazyB) {  // 延迟初始化B
        this.lazyB = lazyB;
    }
    
    public void doSomething() {
        // 第一次调用时才会真正初始化B
        lazyB.process();
    }
}

@Component
public class LazyB {
    private final LazyA lazyA;
    
    @Autowired
    public LazyB(LazyA lazyA) {
        this.lazyA = lazyA;
    }
}

// @Lazy的工作原理：
// 1. 创建A时，B被包装为代理对象
// 2. 只有实际调用B的方法时，才触发B的创建
// 3. 此时A已经完成初始化，可以注入给B
```

### 4.4 方案4：使用ApplicationContext获取Bean
```java
// 方案4：通过ApplicationContext延迟获取
@Component
public class ContextA implements ApplicationContextAware {
    
    private ApplicationContext context;
    private ContextB contextB;
    
    @Override
    public void setApplicationContext(ApplicationContext context) {
        this.context = context;
    }
    
    @PostConstruct
    public void init() {
        // 在初始化阶段获取B
        this.contextB = context.getBean(ContextB.class);
    }
    
    // 或者懒加载方式获取
    public ContextB getContextB() {
        if (contextB == null) {
            contextB = context.getBean(ContextB.class);
        }
        return contextB;
    }
}

@Component
public class ContextB {
    @Autowired
    private ContextA contextA;  // 正常注入
}
```

### 4.5 方案5：使用ObjectProvider（推荐）
```java
// 方案5：使用ObjectProvider（Spring 4.3+）
@Component
public class ProviderA {
    
    // 使用ObjectProvider延迟获取
    private final ObjectProvider<ProviderB> providerBProvider;
    
    // 构造器注入ObjectProvider
    @Autowired
    public ProviderA(ObjectProvider<ProviderB> providerBProvider) {
        this.providerBProvider = providerBProvider;
    }
    
    public void doWork() {
        // 需要时才获取Bean
        ProviderB providerB = providerBProvider.getIfAvailable();
        if (providerB != null) {
            providerB.process();
        }
    }
}

@Component
public class ProviderB {
    @Autowired
    private ProviderA providerA;  // 正常注入
}

// ObjectProvider的优点：
// 1. 延迟获取，避免启动时循环依赖
// 2. 支持可选依赖（getIfAvailable）
// 3. 支持流式操作（stream）
// 4. 支持条件获取（getIfUnique）
```

### 4.6 方案6：使用@DependsOn指定加载顺序
```java
// 方案6：使用@DependsOn强制顺序（适用于非循环但复杂依赖）
@Component
@DependsOn("serviceC")  // 确保ServiceC先初始化
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Component
public class ServiceB {
    @Autowired  
    private ServiceA serviceA;  // 形成循环
}

@Component
public class ServiceC {
    // 作为"垫脚石"，打破A和B的直接循环
}
```

## 五、最佳实践与预防

### 5.1 设计阶段预防循环依赖
```java
// 最佳实践1：依赖方向单向化
// 好的设计：依赖是单向的，形成有向无环图（DAG）
@Service
public class UserService {          // 高层模块
    @Autowired
    private UserRepository userRepo; // 依赖低层模块
}

@Repository
public class UserRepository {       // 低层模块
    // 不依赖UserService
}

// 最佳实践2：使用依赖倒置原则（DIP）
// 定义接口，高层和低层都依赖抽象
public interface UserService {
    void processUser();
}

public interface UserRepository {
    User findById(Long id);
}

@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserRepository userRepo;  // 依赖抽象
}

@Repository  
public class UserRepositoryImpl implements UserRepository {
    // 不依赖UserService
}

// 最佳实践3：分层架构，明确依赖方向
// Controller → Service → Repository
// 禁止反向依赖或平级循环
```

### 5.2 代码规范与检测
```java
// 规范1：强制使用构造器注入（Spring官方推荐）
// 这样能在编译期发现循环依赖问题
@Service
public class StrictA {
    private final StrictB strictB;
    
    // 构造器注入：如果有循环依赖，启动时会立即失败
    public StrictA(StrictB strictB) {
        this.strictB = strictB;
    }
}

// 规范2：定期运行循环依赖检测
@Component
public class CircularDependencyChecker {
    
    @EventListener(ContextRefreshedEvent.class)
    public void checkOnStartup() {
        // 应用启动时检查
        detectCircularDependencies();
    }
}

// 规范3：代码审查时关注
// 审查点：
// 1. Service之间是否相互注入
// 2. 是否有双向依赖
// 3. 是否违反了分层原则
```

### 5.3 架构层面解决方案
```java
// 方案1：事件驱动架构（解耦服务）
@Service
public class EventDrivenA {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    public void doSomething() {
        // 发布事件，而不是直接调用B
        eventPublisher.publishEvent(new SomethingHappenedEvent(this, data));
    }
}

@Service
public class EventDrivenB {
    
    @EventListener
    public void handleEvent(SomethingHappenedEvent event) {
        // 响应事件
    }
}

// 方案2：领域驱动设计（DDD）中的限界上下文
// 不同限界上下文之间通过防腐层通信，避免直接依赖

// 方案3：命令查询职责分离（CQRS）
// 读写分离，避免同一个Service既处理命令又处理查询
```

## 六、总结

### 6.1 循环依赖要点总结
1. **构造器循环依赖**：Spring无法自动解决，需要代码重构
2. **Setter/字段循环依赖**：Spring通过**三级缓存**可以解决
3. **原型Bean循环依赖**：无法解决，因为不缓存
4. **Spring Boot 2.6+**：默认禁止循环依赖，更加严格

### 6.2 解决循环依赖的优先级
```
第一优先级：重新设计，消除循环依赖（最佳实践）
第二优先级：使用@Lazy延迟加载（简单有效）
第三优先级：使用ObjectProvider/ApplicationContext（灵活控制）
第四优先级：使用Setter注入替代构造器注入（兼容方案）
最后手段：配置允许循环依赖（spring.main.allow-circular-references=true）
```

### 6.3 核心建议
```java
// 1. 遵守依赖方向原则：高层模块不应依赖低层模块，两者都应依赖抽象
// 2. 优先使用构造器注入：及早发现循环依赖问题
// 3. 保持依赖简单：避免复杂的网状依赖关系
// 4. 定期检测：使用工具检测潜在的循环依赖
// 5. 升级Spring Boot 2.6+：利用更严格的检查机制
```

**循环依赖的本质是设计问题，而不是技术问题。** 

真正的解决方案不是如何让Spring能处理循环依赖，而是如何设计出没有循环依赖的系统架构。

