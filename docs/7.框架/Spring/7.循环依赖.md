# 循环依赖

## 概念

在Spring Boot中，循环依赖（循环引用）是指两个或多个Bean相互依赖，形成一个依赖环。

循环依赖会导致Spring无法正确地创建这些Bean，从而引发运行时异常。

## 解决

1. 使用setter注入打破循环
2. 使用@Lazy延迟注入
3. 合理使用@Qualifier

### 1. 单例模式下的setter循环依赖

通过”**三级缓存**“处理循环依赖。

**提前暴露对象**、避免重复创建对象以及支持复杂的循环依赖链的解决。

### 2. 使用 `@Lazy` 注解

可以在其中一个依赖上使用 `@Lazy` 注解，告诉Spring在第一次使用这个Bean时再进行实例化，而不是在应用启动时进行实例化。

```java
@Component
public class BeanA {

    private final BeanB beanB;

    @Autowired
    public BeanA(@Lazy BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {

    private final BeanA beanA;

    @Autowired
    public BeanB(BeanA beanA) {
        this.beanA = beanA;
    }
}
```

### 3. 使用 `@Configuration` 和 `@Bean` 方法

通过使用配置类和@Bean方法来显式地定义Bean的创建顺序。

```java
@Configuration
public class AppConfig {

    @Bean
    public BeanA beanA() {
        return new BeanA(beanB());
    }

    @Bean
    public BeanB beanB() {
        return new BeanB();
    }
}
```

### 4. 使用 `@Lookup` 注解解决循环依赖

`@Lookup` 注解可以用来获取其他 Bean 的引用，但通常用于解决**原型作用域**的循环依赖。

```java
import org.springframework.beans.factory.annotation.Lookup;
import org.springframework.stereotype.Component;

@Component
public class ClassA {
    private ClassB classB;

    // 使用 @Lookup 获取 ClassB 的实例
    @Lookup
    public ClassB getMyClassB() {
        return this.classB;
    }

    // ClassA 的其他方法...
}

@Component
public class ClassB {
    private ClassA classA;

    // 构造器注入 ClassA
    public ClassB(ClassA classA) {
        this.classA = classA;
    }

    // ClassB 的其他方法...
}
```