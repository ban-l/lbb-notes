# Spring 事务

Spring事务管理是Spring框架最核心的功能之一，它提供了**声明式**和**编程式**两种事务管理方式，极大地简化了企业级应用中的事务处理。

## 一、事务基础概念回顾

### 1.1 ACID原则
- **原子性（Atomicity）**：事务的所有操作要么全部完成，要么全部不完成
- **一致性（Consistency）**：事务执行前后，数据保持一致状态
- **隔离性（Isolation）**：多个事务并发执行时互不干扰
- **持久性（Durability）**：事务完成后，对数据的修改是永久的

### 1.2 事务问题（并发问题）
- **脏读**：读取到其他事务未提交的数据
- **不可重复读**：同一事务内两次读取同一数据，结果不一致
- **幻读**：同一事务内两次查询，返回的记录数不同
- **丢失更新**：两个事务同时修改同一数据，一个修改被覆盖

## 二、Spring事务核心架构

### 2.1 事务抽象层
```java
// Spring事务核心接口
public interface PlatformTransactionManager {
    // 获取事务状态
    TransactionStatus getTransaction(TransactionDefinition definition) 
        throws TransactionException;
    
    // 提交事务
    void commit(TransactionStatus status) throws TransactionException;
    
    // 回滚事务
    void rollback(TransactionStatus status) throws TransactionException;
}

// 事务定义（传播行为、隔离级别等）
public interface TransactionDefinition {
    int getPropagationBehavior();
    int getIsolationLevel();
    int getTimeout();
    boolean isReadOnly();
    String getName();
}

// 事务状态
public interface TransactionStatus extends SavepointManager {
    boolean isNewTransaction();
    boolean hasSavepoint();
    void setRollbackOnly();
    boolean isRollbackOnly();
    boolean isCompleted();
}
```

### 2.2 Spring事务管理器实现

| 数据访问技术  | 事务管理器实现                 | 使用场景        |
| ------------- | ------------------------------ | --------------- |
| **JDBC**      | `DataSourceTransactionManager` | 纯JDBC或MyBatis |
| **JPA**       | `JpaTransactionManager`        | JPA/Hibernate   |
| **JTA**       | `JtaTransactionManager`        | 分布式事务      |
| **Hibernate** | `HibernateTransactionManager`  | Hibernate       |
| **MongoDB**   | `MongoTransactionManager`      | MongoDB         |
| **Redis**     | `RedisTransactionManager`      | Redis           |

## 三、事务传播行为（Propagation）

### 3.1 七种传播行为详解

```java
@Service
public class UserService {
    
    @Autowired
    private OrderService orderService;
    
    // 1. REQUIRED（默认）：如果当前没有事务，就新建一个事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void createUserWithOrder(User user, Order order) {
        // 方法A：创建用户
        userRepository.save(user);
        
        try {
            // 方法B：创建订单（使用REQUIRED）
            // 会加入方法A的事务
            orderService.createOrder(order);
        } catch (Exception e) {
            // 如果createOrder失败，整个事务回滚
        }
    }
    
    // 2. SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行
    @Transactional(propagation = Propagation.SUPPORTS)
    public User getUser(Long id) {
        // 如果调用方有事务，则在此事务中执行
        // 如果调用方没有事务，则以非事务方式执行
        return userRepository.findById(id);
    }
    
    // 3. MANDATORY：必须在一个已有的事务中执行，否则抛出异常
    @Transactional(propagation = Propagation.MANDATORY)
    public void updateUser(User user) {
        // 必须在事务中调用，否则抛异常：
        // IllegalTransactionStateException: No existing transaction found
        userRepository.update(user);
    }
    
    // 4. REQUIRES_NEW：新建事务，如果当前存在事务，则挂起当前事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void processWithLog(User user) {
        // 主事务开始
        userRepository.save(user);
        
        try {
            // 日志记录需要独立事务，即使主事务回滚，日志也要保存
            logService.auditLog("用户创建", Propagation.REQUIRES_NEW);
        } catch (Exception e) {
            // 日志事务失败不影响主事务
        }
        
        // 可能抛异常，导致主事务回滚
        if (user.getAge() < 0) {
            throw new IllegalArgumentException("年龄不能为负数");
        }
    }
    
    // 5. NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，则挂起当前事务
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void generateReport() {
        // 生成报表，不需要事务，且需要避免大事务
        // 执行时间可能很长，不希望阻塞其他事务
    }
    
    // 6. NEVER：以非事务方式执行，如果当前存在事务，则抛出异常
    @Transactional(propagation = Propagation.NEVER)
    public void validateData(User user) {
        // 纯验证操作，不应该在事务中执行
        if (user.getName() == null) {
            throw new ValidationException("用户名不能为空");
        }
    }
    
    // 7. NESTED：如果当前存在事务，则在嵌套事务内执行
    // 嵌套事务是外部事务的子事务，有自己的保存点
    @Transactional(propagation = Propagation.REQUIRED)
    public void batchCreateUsers(List<User> users) {
        for (User user : users) {
            try {
                // NESTED事务：有自己的保存点
                // 失败只回滚当前用户，不影响其他用户
                userService.createUserNested(user);
            } catch (Exception e) {
                log.error("创建用户失败: {}", user.getName(), e);
                // 继续处理下一个用户
            }
        }
    }
    
    @Transactional(propagation = Propagation.NESTED)
    public void createUserNested(User user) {
        userRepository.save(user);
        // 嵌套事务回滚只影响当前保存点
    }
}
```

### 3.2 传播行为总结

| 传播行为            | 当前有事务           | 当前无事务 | 说明         |
| ------------------- | -------------------- | ---------- | ------------ |
| **REQUIRED** (默认) | 加入当前事务         | 新建事务   | 最常用       |
| **SUPPORTS**        | 加入当前事务         | 非事务运行 | 查询方法常用 |
| **MANDATORY**       | 加入当前事务         | 抛出异常   | 强制要求事务 |
| **REQUIRES_NEW**    | 挂起当前，新建事务   | 新建事务   | 独立事务     |
| **NOT_SUPPORTED**   | 挂起当前，非事务运行 | 非事务运行 | 避免事务影响 |
| **NEVER**           | 抛出异常             | 非事务运行 | 禁止事务     |
| **NESTED**          | 嵌套事务（保存点）   | 新建事务   | 部分回滚     |

## 四、事务隔离级别（Isolation）

### 4.1 四种隔离级别

```java
@Service
@Transactional
public class AccountService {
    
    // 1. DEFAULT：使用底层数据库默认隔离级别（通常是READ_COMMITTED）
    @Transactional(isolation = Isolation.DEFAULT)
    public void transferDefault(Account from, Account to, BigDecimal amount) {
        // MySQL: REPEATABLE_READ
        // Oracle: READ_COMMITTED
        // PostgreSQL: READ_COMMITTED
    }
    
    // 2. READ_UNCOMMITTED：读未提交（最低级别）
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public BigDecimal getUncommittedBalance(Long accountId) {
        // 可以读取其他事务未提交的数据
        // 可能发生：脏读、不可重复读、幻读
        // 适用场景：对数据一致性要求极低，如实时统计
        return accountRepository.getBalance(accountId);
    }
    
    // 3. READ_COMMITTED：读已提交（Oracle/PostgreSQL默认）
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void transferReadCommitted(Account from, Account to, BigDecimal amount) {
        // 避免脏读，但可能有不可重复读和幻读
        BigDecimal balance1 = accountRepository.getBalance(from.getId());
        // 此时其他事务修改并提交了余额
        BigDecimal balance2 = accountRepository.getBalance(from.getId());
        // balance1 可能不等于 balance2（不可重复读）
    }
    
    // 4. REPEATABLE_READ：可重复读（MySQL默认）
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void checkAndTransfer(Account from, Account to, BigDecimal amount) {
        // 同一事务内多次读取相同数据，结果一致
        // 避免脏读和不可重复读，可能有幻读
        BigDecimal balance1 = accountRepository.getBalance(from.getId());
        // 此时其他事务无法修改已读取的数据行
        BigDecimal balance2 = accountRepository.getBalance(from.getId());
        // balance1 一定等于 balance2
    }
    
    // 5. SERIALIZABLE：串行化（最高级别）
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void serializableTransfer(Account from, Account to, BigDecimal amount) {
        // 完全串行执行，避免所有并发问题
        // 性能最差，一般不建议使用
        // 适用场景：资金结算等对一致性要求极高的操作
    }
}
```

### 4.2 隔离级别与并发问题

| 隔离级别             | 脏读 | 不可重复读 | 幻读 | 性能 |
| -------------------- | ---- | ---------- | ---- | ---- |
| **READ_UNCOMMITTED** | ✓    | ✓          | ✓    | 最高 |
| **READ_COMMITTED**   | ✗    | ✓          | ✓    | 高   |
| **REPEATABLE_READ**  | ✗    | ✗          | ✓    | 中   |
| **SERIALIZABLE**     | ✗    | ✗          | ✗    | 最低 |

## 五、事务其他属性

### 5.1 完整的事务注解配置
```java
@Service
public class FinancialService {
    
    @Transactional(
        // 传播行为
        propagation = Propagation.REQUIRED,
        
        // 隔离级别
        isolation = Isolation.READ_COMMITTED,
        
        // 超时时间（秒）
        timeout = 30,
        
        // 是否只读（优化提示）
        readOnly = true,
        
        // 回滚规则
        rollbackFor = {BusinessException.class, SQLException.class},
        noRollbackFor = {ValidationException.class},
        
        // 事务管理器（多数据源时指定）
        transactionManager = "primaryTransactionManager",
        
        // 事务名称（用于监控）
        label = "fund_transfer"
    )
    public void transferFunds(TransferRequest request) {
        // 复杂的转账逻辑
        validateRequest(request);
        debitSourceAccount(request);
        creditTargetAccount(request);
        recordTransaction(request);
        sendNotification(request);
    }
    
    // 5.2 超时控制
    @Transactional(timeout = 10)  // 10秒超时
    public void batchProcess(List<Data> dataList) {
        for (Data data : dataList) {
            processData(data);  // 如果总时间超过10秒，事务回滚
        }
    }
    
    // 5.3 只读事务优化
    @Transactional(readOnly = true)
    public Report generateAnnualReport(int year) {
        // 只读事务优化：
        // 1. 数据库可能使用只读副本
        // 2. Hibernate可能禁用脏检查
        // 3. 连接可能被标记为只读
        return reportRepository.findByYear(year);
    }
    
    // 5.4 回滚规则
    @Transactional(rollbackFor = Exception.class)  // 所有异常都回滚
    public void riskyOperation() {
        // 默认：RuntimeException和Error回滚
        // 受检异常默认不回滚
    }
    
    @Transactional(noRollbackFor = BusinessException.class)
    public void operationWithBusinessException() {
        // 业务异常时，事务不回滚（记录日志但继续执行）
        throw new BusinessException("业务异常，但不回滚");
    }
}
```

## 六、声明式事务实现原理

### 6.1 AOP代理机制
```java
// Spring声明式事务底层通过AOP实现
@Aspect
@Component
public class TransactionAspect {
    
    @Around("@annotation(transactional)")
    public Object manageTransaction(ProceedingJoinPoint joinPoint, 
                                    Transactional transactional) throws Throwable {
        
        // 1. 获取事务定义
        TransactionDefinition definition = createTransactionDefinition(transactional);
        
        // 2. 获取事务管理器
        PlatformTransactionManager txManager = getTransactionManager();
        
        // 3. 开启事务
        TransactionStatus status = txManager.getTransaction(definition);
        
        try {
            // 4. 执行目标方法
            Object result = joinPoint.proceed();
            
            // 5. 提交事务
            txManager.commit(status);
            return result;
            
        } catch (Throwable ex) {
            // 6. 判断是否需要回滚
            if (shouldRollback(transactional, ex)) {
                txManager.rollback(status);
            } else {
                txManager.commit(status);
            }
            throw ex;
        }
    }
    
    private boolean shouldRollback(Transactional transactional, Throwable ex) {
        // 根据rollbackFor/noRollbackFor判断
        for (Class<?> rollbackClass : transactional.rollbackFor()) {
            if (rollbackClass.isInstance(ex)) {
                return true;
            }
        }
        // 默认：RuntimeException和Error回滚
        return ex instanceof RuntimeException || ex instanceof Error;
    }
}
```

### 6.2 事务同步管理器
```java
// TransactionSynchronizationManager：保存当前线程的事务上下文
public abstract class TransactionSynchronizationManager {
    // 当前线程的事务资源（如数据库连接）
    private static final ThreadLocal<Map<Object, Object>> resources = 
        new NamedThreadLocal<>("Transactional resources");
    
    // 当前事务的同步回调
    private static final ThreadLocal<Set<TransactionSynchronization>> synchronizations = 
        new NamedThreadLocal<>("Transaction synchronizations");
    
    // 当前事务名称
    private static final ThreadLocal<String> currentTransactionName = 
        new NamedThreadLocal<>("Current transaction name");
    
    // 当前事务是否只读
    private static final ThreadLocal<Boolean> currentTransactionReadOnly = 
        new NamedThreadLocal<>("Current transaction read-only status");
    
    // 当前事务隔离级别
    private static final ThreadLocal<Integer> currentTransactionIsolationLevel = 
        new NamedThreadLocal<>("Current transaction isolation level");
    
    // 当前事务是否活跃
    private static final ThreadLocal<Boolean> actualTransactionActive = 
        new NamedThreadLocal<>("Actual transaction active");
}
```

## 七、编程式事务管理

### 7.1 TransactionTemplate方式（推荐）
```java
@Service
public class ManualTransactionService {
    
    @Autowired
    private TransactionTemplate transactionTemplate;
    
    public void complexOperation() {
        // 1. 配置事务模板
        transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        transactionTemplate.setTimeout(30);
        transactionTemplate.setReadOnly(false);
        
        // 2. 执行带事务的操作
        Boolean result = transactionTemplate.execute(new TransactionCallback<Boolean>() {
            @Override
            public Boolean doInTransaction(TransactionStatus status) {
                try {
                    // 业务逻辑
                    step1();
                    step2();
                    step3();
                    
                    // 可以手动设置回滚
                    if (needRollback()) {
                        status.setRollbackOnly();
                        return false;
                    }
                    
                    return true;
                } catch (Exception e) {
                    // 异常会自动回滚
                    throw e;
                }
            }
        });
        
        // 3. 无返回值版本
        transactionTemplate.executeWithoutResult(status -> {
            // 业务逻辑
            batchProcess();
        });
    }
}
```

### 7.2 PlatformTransactionManager方式
```java
@Service
public class RawTransactionService {
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    public void manualTransaction() {
        // 1. 定义事务属性
        DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
        definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
        definition.setTimeout(30);
        definition.setReadOnly(false);
        definition.setName("manualTransaction");
        
        // 2. 开启事务
        TransactionStatus status = transactionManager.getTransaction(definition);
        
        try {
            // 3. 业务逻辑
            businessOperation1();
            businessOperation2();
            
            // 4. 提交事务
            transactionManager.commit(status);
            
        } catch (Exception e) {
            // 5. 回滚事务
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

## 八、多数据源事务管理

### 8.1 JTA分布式事务
```java
@Configuration
@EnableTransactionManagement
public class JtaConfig {
    
    // 配置Atomikos JTA事务管理器
    @Bean(initMethod = "init", destroyMethod = "shutdownForce")
    public UserTransactionManager userTransactionManager() {
        UserTransactionManager manager = new UserTransactionManager();
        manager.setForceShutdown(false);
        return manager;
    }
    
    @Bean
    public UserTransaction userTransaction() throws SystemException {
        UserTransactionImp userTransaction = new UserTransactionImp();
        userTransaction.setTransactionTimeout(300);
        return userTransaction;
    }
    
    @Bean
    public JtaTransactionManager transactionManager() {
        return new JtaTransactionManager(userTransaction(), userTransactionManager());
    }
}

@Service
public class DistributedService {
    
    @Transactional  // 使用JTA管理分布式事务
    public void distributedOperation() {
        // 操作数据库1
        userRepository.save(user);
        
        // 操作数据库2
        orderRepository.save(order);
        
        // 发送消息到MQ
        jmsTemplate.send("queue.order", messageCreator);
        
        // 所有操作在一个分布式事务中
        // 要么全部成功，要么全部回滚
    }
}
```

### 8.2 ChainedTransactionManager（最终一致性）
```java
@Configuration
public class ChainedTransactionConfig {
    
    @Primary
    @Bean
    public PlatformTransactionManager chainedTransactionManager(
            DataSourceTransactionManager dsTxManager,
            JpaTransactionManager jpaTxManager,
            MongoTransactionManager mongoTxManager) {
        
        // 链式事务管理器：按顺序提交，逆序回滚
        return new ChainedTransactionManager(
            dsTxManager,    // 第一个提交，最后一个回滚
            jpaTxManager,   // 第二个提交，倒数第二个回滚
            mongoTxManager  // 最后一个提交，第一个回滚
        );
    }
}

@Service
public class MultiStoreService {
    
    @Transactional
    public void saveToMultipleStores(User user) {
        // 保存到MySQL
        mysqlUserRepository.save(user);
        
        // 保存到MongoDB
        mongoUserRepository.save(user);
        
        // 不是真正的ACID事务，而是最终一致性
        // 如果MongoDB保存失败，MySQL已提交的数据不会回滚
    }
}
```

## 九、事务最佳实践与陷阱

### 9.1 最佳实践
```java
@Service
@Slf4j
public class BestPracticeService {
    
    // 实践1：在Service层使用事务，而不是DAO层
    @Transactional
    public void businessOperation() {
        // 一个完整的业务操作
        validate();
        process();
        audit();
    }
    
    // 实践2：合理设置事务边界
    @Transactional(
        propagation = Propagation.REQUIRED,
        isolation = Isolation.READ_COMMITTED,
        timeout = 30,
        readOnly = false
    )
    public void wellDefinedTransaction() {
        // 明确的事务属性
    }
    
    // 实践3：避免大事务
    public void avoidBigTransaction() {
        // 错误：整个批量处理在一个事务中
        // @Transactional
        // public void batchProcess(List<Data> list) {
        //     for (Data data : list) {
        //         process(data);  // 可能很耗时
        //     }
        // }
        
        // 正确：分批次提交
        for (List<Data> batch : partitionList(list, 100)) {
            processBatch(batch);
        }
    }
    
    @Transactional
    public void processBatch(List<Data> batch) {
        // 每个批次独立事务
        for (Data data : batch) {
            process(data);
        }
    }
    
    // 实践4：正确处理异常
    @Transactional
    public void handleExceptionProperly() {
        try {
            riskyOperation();
        } catch (BusinessException e) {
            // 业务异常，记录日志但继续执行
            log.error("业务异常", e);
            // 注意：默认情况下受检异常不会导致回滚
            // 如果需要回滚，要设置rollbackFor或抛出RuntimeException
            throw new RuntimeException(e);
        }
    }
    
    // 实践5：使用只读事务优化查询
    @Transactional(readOnly = true)
    public List<User> findActiveUsers() {
        // 只读查询，数据库可能使用只读副本
        return userRepository.findByActiveTrue();
    }
}
```

### 9.2 常见陷阱
```java
@Service
public class TransactionTrapService {
    
    // 陷阱1：自调用失效
    public void selfInvocationTrap() {
        // 调用同类中的@Transactional方法
        this.transactionalMethod();  // 事务不会生效！
    }
    
    @Transactional
    public void transactionalMethod() {
        // 由于自调用，不走代理，事务无效
    }
    
    // 解决方案：
    // 1. 注入自身代理（不推荐）
    // 2. 使用AopContext.currentProxy()
    // 3. 重构代码结构
    
    // 陷阱2：异常被捕获
    @Transactional
    public void catchExceptionTrap() {
        try {
            operationThatMayFail();
        } catch (Exception e) {
            // 异常被捕获，事务不会回滚！
            log.error("操作失败", e);
        }
    }
    
    // 陷阱3：非public方法
    @Transactional
    private void privateMethodTrap() {
        // private方法上的@Transactional无效！
    }
    
    // 陷阱4：不同数据源混用
    @Transactional("primaryTxManager")
    public void multiDataSourceTrap() {
        primaryRepository.save(data);  // 使用primary数据源
        
        // 错误：secondaryRepository也使用了primary的事务
        secondaryRepository.save(data); // 应该使用不同的事务管理器
    }
    
    // 正确做法：使用嵌套事务或编程式事务
    @Transactional("primaryTxManager")
    public void correctMultiDataSource() {
        primaryRepository.save(data);
        
        // 使用REQUIRES_NEW或编程式事务
        secondaryTransactionTemplate.execute(status -> {
            secondaryRepository.save(data);
            return null;
        });
    }
    
    // 陷阱5：事务中执行长时间操作
    @Transactional
    public void longRunningInTransaction() {
        // 长时间操作
        generateLargeReport();  // 可能执行几分钟
        
        // 持有数据库连接，影响其他事务
        // 可能导致锁超时或连接池耗尽
    }
}
```

## 十、Spring事务配置

### 10.1 注解配置
```java
@Configuration
@EnableTransactionManagement(
    mode = AdviceMode.PROXY,           // 使用代理模式
    proxyTargetClass = false,           // 使用JDK动态代理
    order = Ordered.LOWEST_PRECEDENCE  // AOP顺序
)
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    
    // 配置事务拦截器（高级配置）
    @Bean
    public TransactionInterceptor transactionInterceptor() {
        TransactionInterceptor interceptor = new TransactionInterceptor();
        interceptor.setTransactionManager(transactionManager());
        
        // 配置事务属性源
        Properties properties = new Properties();
        properties.setProperty("save*", "PROPAGATION_REQUIRED");
        properties.setProperty("get*", "PROPAGATION_SUPPORTS,readOnly");
        properties.setProperty("update*", "PROPAGATION_REQUIRED,-Exception");
        
        interceptor.setTransactionAttributes(properties);
        return interceptor;
    }
}
```

### 10.2 XML配置
```xml
<!-- 启用注解驱动事务 -->
<tx:annotation-driven 
    transaction-manager="transactionManager"
    proxy-target-class="true"
    order="1"/>

<!-- 配置事务管理器 -->
<bean id="transactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>

<!-- AOP方式配置事务 -->
<aop:config>
    <aop:pointcut id="serviceMethods" 
                  expression="execution(* com.example.service.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="serviceMethods"/>
</aop:config>

<!-- 事务增强配置 -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="save*" propagation="REQUIRED"/>
        <tx:method name="update*" propagation="REQUIRED"/>
        <tx:method name="delete*" propagation="REQUIRED"/>
        <tx:method name="get*" propagation="SUPPORTS" read-only="true"/>
        <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>
        <tx:method name="*" propagation="SUPPORTS" read-only="true"/>
    </tx:attributes>
</tx:advice>
```

## 总结

Spring事务管理的核心要点：

1. **两种管理方式**：
   - 声明式事务（@Transactional）：简单、推荐
   - 编程式事务：灵活、可控

2. **核心属性**：
   - 传播行为（7种）：控制事务边界
   - 隔离级别（4种）：控制并发问题
   - 超时、只读、回滚规则

3. **实现原理**：
   - 基于AOP动态代理
   - 使用TransactionSynchronizationManager管理线程绑定资源

4. **最佳实践**：
   - 在Service层使用事务
   - 避免大事务和长事务
   - 合理选择传播行为和隔离级别
   - 注意自调用和异常处理

5. **多数据源场景**：
   - JTA：强一致性分布式事务
   - ChainedTransactionManager：最终一致性

Spring事务管理虽然强大，但需要深入理解其原理和配置，避免常见陷阱，才能在实际项目中发挥最大作用。

 