## 线程安全的实现

Java线程安全的实现：不可变、互斥同步、非阻塞同步、无同步方案（栈封闭、ThreadLocal ）。

## 一 不可变

### 1.不可变的类型

- `final` 关键字修饰的基本数据类型
- `String`
- 枚举类型
- `Number` 部分子类
  - `Integer`、`Long` 、 `Double` 等数值包装类型
  - `BigInteger` 和 `BigDecimal` 等大数据类型

### 2.不可变的集合类型

`Collections.unmodifiableXXX()` 方法来获取一个不可变的集合。
`Collections.unmodifiableXXX()` 会对原始集合进行拷贝，对集合修改的方法都直接抛出异常。

## 二 互斥同步（阻塞同步）

显式锁：`ReentrantLock` 和 隐式锁：`synchronized`

互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

互斥同步属于一种**悲观并发策略**，无论共享数据是否出现竞争，它都要进行：

1. 加锁（这里只讨论概念模型，实际JVM会进行锁优化）
2. 用户态核心态转换
3. 维护锁计数器
4. 检查是否有被阻塞的线程需要唤醒 等操作

## 三 非阻塞同步

基于冲突检测的**乐观并发策略**。

互斥同步有性能问题，可能额外操作的时间消耗远⼤于线程⾃⾝的业务执⾏时间，所以引⼊⾮阻塞同步，即CAS操作。

- 先进行操作，如果没有其它线程竞争共享数据，操作成功；否则采取补偿措施（循环CAS）
- 存在三个问题：ABA、自旋、单个变量

CAS实现最直接的实现是JUC下的各种原⼦类。

虽然CAS避免了锁带来的性能开销，不过其仅适⽤于少部分同步场景，没有阻塞同步更加具有普适性。

## 四 无同步方案

要保证线程安全，并不是一定就要进行同步。

如果一个方法不涉及共享数据，自然就无须任何同步措施去保证正确性。

### 1. 栈封闭

多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。

### 2.线程本地存储(Thread Local Storage)

主要⽤于对于⼀个共享资源都尽可能的在同⼀个线程中执⾏，使⽤场景：

1. ⽣产者-消费者模型中，消费者消费⼀个内容
2. web服务中，⼀个请求对⽤于⼀个服务线程（⽣产者-消费者模型）
3. 链路跟踪中，动态采集⽅法的执⾏信息 

### 3. 可重入代码/纯代码(Reentrant Code/Pure  Code)

- 可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。
- 可重入代码有一些共同的特征：
  - 不依赖存储在堆上的数据和公用的系统资源；
  - 用到的状态量都由参数中传入；
  - 不调用非可重入的方法等。